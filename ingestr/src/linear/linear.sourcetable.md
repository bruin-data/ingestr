# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

"""
A bot actor is an actor that is not a user, but an application or integration.
"""
type ActorBot {
  """A url pointing to the avatar representing this bot."""
  avatarUrl: String
  id: ID

  """The display name of the bot."""
  name: String

  """The sub type of the bot."""
  subType: String

  """The type of bot."""
  type: String!

  """
  The display name of the external user on behalf of which the bot acted.
  """
  userDisplayName: String
}

"""An activity within an agent context."""
type AgentActivity implements Node {
  """The agent session this activity belongs to."""
  agentSession: AgentSession!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The content of the activity"""
  content: AgentActivityContent!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The comment this activity is linked to."""
  sourceComment: Comment

  """Metadata about the external source that created this agent activity."""
  sourceMetadata: JSON

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""Content for an action activity (tool call or action)."""
type AgentActivityActionContent {
  """The action being performed."""
  action: String!

  """The parameters for the action, e.g. a file path, a keyword, etc."""
  parameter: String!

  """The result of the action in Markdown format."""
  result: String

  """The type of activity."""
  type: AgentActivityType!
}

type AgentActivityConnection {
  edges: [AgentActivityEdge!]!
  nodes: [AgentActivity!]!
  pageInfo: PageInfo!
}

"""Content for different types of agent activities."""
union AgentActivityContent = AgentActivityActionContent | AgentActivityElicitationContent | AgentActivityErrorContent | AgentActivityPromptContent | AgentActivityResponseContent | AgentActivityThoughtContent

input AgentActivityCreateInput {
  """The agent session this activity belongs to."""
  agentSessionId: String!

  """
  The content payload of the agent activity. This object is not strictly typed.
  See https://linear.app/developers/agents for typing details.
  """
  content: JSONObject!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String
}

input AgentActivityCreatePromptInput {
  """The agent session this activity belongs to."""
  agentSessionId: String!

  """The content payload of the prompt agent activity."""
  content: JSONObject!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The comment that contains the content of this activity."""
  sourceCommentId: String!
}

type AgentActivityEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: AgentActivity!
}

"""Content for an elicitation activity."""
type AgentActivityElicitationContent {
  """The elicitation message in Markdown format."""
  body: String!

  """The type of activity."""
  type: AgentActivityType!
}

"""Content for an error activity."""
type AgentActivityErrorContent {
  """The error message in Markdown format."""
  body: String!

  """The type of activity."""
  type: AgentActivityType!
}

"""Agent activity filtering options."""
input AgentActivityFilter {
  """Comparator for the agent session ID."""
  agentSessionId: StringComparator

  """
  Compound filters, all of which need to be matched by the agent activity.
  """
  and: [AgentActivityFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """
  Compound filters, one of which need to be matched by the agent activity.
  """
  or: [AgentActivityFilter!]

  """Filters that the source comment must satisfy."""
  sourceComment: NullableCommentFilter

  """Comparator for the agent activity's content type."""
  type: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type AgentActivityPayload {
  """The agent activity that was created or updated."""
  agentActivity: AgentActivity!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Content for a prompt activity."""
type AgentActivityPromptContent {
  """A message requesting additional information or action from user."""
  body: String!

  """The type of activity."""
  type: AgentActivityType!
}

"""Content for a response activity."""
type AgentActivityResponseContent {
  """The response content in Markdown format."""
  body: String!

  """The type of activity."""
  type: AgentActivityType!
}

"""Content for a thought activity."""
type AgentActivityThoughtContent {
  """The thought content in Markdown format."""
  body: String!

  """The type of activity."""
  type: AgentActivityType!
}

"""The type of an agent activity."""
enum AgentActivityType {
  action
  elicitation
  error
  prompt
  response
  thought
}

"""A session for agent activities and state management."""
type AgentSession implements Node {
  """Activities associated with this agent session."""
  activities(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned agent activities."""
    filter: AgentActivityFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AgentActivityConnection!

  """The agent user that is associated with this agent session."""
  appUser: User!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The comment this agent session is associated with."""
  comment: Comment

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user that created this agent session."""
  creator: User

  """The time the agent session ended."""
  endedAt: DateTime

  """The URL of an external agent-hosted page associated with this session."""
  externalLink: String

  """The unique identifier of the entity."""
  id: ID!

  """The issue this agent session is associated with."""
  issue: Issue

  """Metadata about the external source that created this agent session."""
  sourceMetadata: JSON

  """The time the agent session started."""
  startedAt: DateTime

  """The current status of the agent session."""
  status: AgentSessionStatus!

  """A summary of the activities in this session."""
  summary: String

  """The type of the agent session."""
  type: AgentSessionType!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type AgentSessionConnection {
  edges: [AgentSessionEdge!]!
  nodes: [AgentSession!]!
  pageInfo: PageInfo!
}

type AgentSessionEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: AgentSession!
}

type AgentSessionPayload {
  """The agent session that was created or updated."""
  agentSession: AgentSession!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The status of an agent session."""
enum AgentSessionStatus {
  active
  awaitingInput
  complete
  error
  pending
  stale
}

"""The type of an agent session."""
enum AgentSessionType {
  commentThread
}

input AgentSessionUpdateExternalUrlInput {
  """The URL of an external agent-hosted page associated with this session."""
  externalLink: String
}

input AirbyteConfigurationInput {
  """Linear export API key."""
  apiKey: String!
}

"""An API key. Grants access to the user's resources."""
type ApiKey implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The label of the API key."""
  label: String!

  """Organization the API key belongs to."""
  organization: Organization!

  """
  The sync groups that this API key requests access to. If null, the API key has access to all sync groups the user has access to. The final set of sync groups is computed as the intersection of these requested groups with the user's base sync groups.
  """
  requestedSyncGroups: [String!]

  """Scopes associated with the API key."""
  scope: [String!]

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type ApiKeyConnection {
  edges: [ApiKeyEdge!]!
  nodes: [ApiKey!]!
  pageInfo: PageInfo!
}

input ApiKeyCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The API key value."""
  key: String!

  """The label for the API key."""
  label: String!

  """Scopes the API key has access to. Default is all scopes."""
  scope: [String!]

  """
  List of team IDs to restrict this API key to. Default is all teams the user has access to.
  """
  teamIds: [String!]
}

type ApiKeyEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ApiKey!
}

type ApiKeyPayload {
  """The API key that was created."""
  apiKey: ApiKey!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input ApiKeyUpdateInput {
  """The new label for the API key."""
  label: String

  """Scopes the API key has access to. Default is all scopes."""
  scope: [String!]

  """
  List of team IDs to restrict this API key to. Default is all teams the user has access to.
  """
  teamIds: [String!]
}

"""[INTERNAL] Details of the app user's existing token."""
type AppUserAuthentication {
  """The user that authorized the application, if known."""
  authorizingUser: AuthorizingUser

  """The timestamp at which the token was created."""
  createdAt: DateTime!

  """Whether the application has requested custom sync groups."""
  requestedSyncGroups: Boolean!

  """The scopes that the token has."""
  scope: [String!]!
}

"""Public information of the OAuth application."""
type Application {
  """OAuth application's client ID."""
  clientId: String!

  """Information about the application."""
  description: String

  """Name of the developer."""
  developer: String!

  """Url of the developer (homepage or docs)."""
  developerUrl: String!

  """OAuth application's ID."""
  id: String!

  """Image of the application."""
  imageUrl: String

  """Application name."""
  name: String!
}

"""Customer approximate need count sorting options."""
input ApproximateNeedCountSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A generic payload return from entity archive or deletion mutations."""
interface ArchivePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Contains requested archived model objects."""
type ArchiveResponse {
  """A JSON serialized collection of model objects loaded from the archive"""
  archive: String!

  """
  The version of the remote database. Incremented by 1 for each migration run on the database.
  """
  databaseVersion: Float!

  """
  Whether the dependencies for the model objects are included in the archive.
  """
  includesDependencies: [String!]!

  """The total number of entities in the archive."""
  totalCount: Float!
}

type AsksChannelConnectPayload {
  """Whether the bot needs to be manually added to the channel."""
  addBot: Boolean!

  """The integration that was created or updated."""
  integration: Integration

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The new Asks Slack channel mapping for the connected channel."""
  mapping: SlackChannelNameMapping!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Issue assignee sorting options."""
input AssigneeSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Issue attachment (e.g. support ticket, pull request)."""
type Attachment implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The body data of the attachment, if any."""
  bodyData: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The creator of the attachment."""
  creator: User

  """The non-Linear user who created the attachment."""
  externalUserCreator: ExternalUser

  """
  Indicates if attachments for the same source application should be grouped in the Linear UI.
  """
  groupBySource: Boolean!

  """The unique identifier of the entity."""
  id: ID!

  """The issue this attachment belongs to."""
  issue: Issue!

  """Custom metadata related to the attachment."""
  metadata: JSONObject!

  """
  The issue this attachment was originally created on. Will be undefined if the attachment hasn't been moved.
  """
  originalIssue: Issue

  """Information about the source which created the attachment."""
  source: JSONObject

  """
  An accessor helper to source.type, defines the source type of the attachment.
  """
  sourceType: String

  """Content for the subtitle line in the Linear attachment widget."""
  subtitle: String

  """Content for the title line in the Linear attachment widget."""
  title: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Location of the attachment which is also used as an identifier."""
  url: String!
}

"""Attachment collection filtering options."""
input AttachmentCollectionFilter {
  """Compound filters, all of which need to be matched by the attachment."""
  and: [AttachmentCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the attachments creator must satisfy."""
  creator: NullableUserFilter

  """Filters that needs to be matched by all attachments."""
  every: AttachmentFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Compound filters, one of which need to be matched by the attachment."""
  or: [AttachmentCollectionFilter!]

  """Filters that needs to be matched by some attachments."""
  some: AttachmentFilter

  """Comparator for the source type."""
  sourceType: SourceTypeComparator

  """Comparator for the subtitle."""
  subtitle: NullableStringComparator

  """Comparator for the title."""
  title: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the url."""
  url: StringComparator
}

type AttachmentConnection {
  edges: [AttachmentEdge!]!
  nodes: [Attachment!]!
  pageInfo: PageInfo!
}

input AttachmentCreateInput {
  """Create a linked comment with markdown body."""
  commentBody: String

  """
  [Internal] Create a linked comment with Prosemirror body. Please use `commentBody` instead.
  """
  commentBodyData: JSONObject

  """
  Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  """
  createAsUser: String

  """
  Indicates if attachments for the same source application should be grouped in the Linear UI.
  """
  groupBySource: Boolean

  """
  An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality.
  """
  iconUrl: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The issue to associate the attachment with."""
  issueId: String!

  """Attachment metadata object with string and number values."""
  metadata: JSONObject

  """The attachment subtitle."""
  subtitle: String

  """The attachment title."""
  title: String!

  """
  Attachment location which is also used as an unique identifier for the attachment. If another attachment is created with the same `url` value, existing record is updated instead.
  """
  url: String!
}

type AttachmentEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Attachment!
}

"""Attachment filtering options."""
input AttachmentFilter {
  """Compound filters, all of which need to be matched by the attachment."""
  and: [AttachmentFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the attachments creator must satisfy."""
  creator: NullableUserFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Compound filters, one of which need to be matched by the attachment."""
  or: [AttachmentFilter!]

  """Comparator for the source type."""
  sourceType: SourceTypeComparator

  """Comparator for the subtitle."""
  subtitle: NullableStringComparator

  """Comparator for the title."""
  title: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Comparator for the url."""
  url: StringComparator
}

type AttachmentPayload {
  """The issue attachment that was created."""
  attachment: Attachment!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type AttachmentSourcesPayload {
  """A unique list of all source types used in this workspace."""
  sources: JSONObject!
}

input AttachmentUpdateInput {
  """
  An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality.
  """
  iconUrl: String

  """Attachment metadata object with string and number values."""
  metadata: JSONObject

  """The attachment subtitle."""
  subtitle: String

  """The attachment title."""
  title: String!
}

"""Workspace audit log entry object."""
type AuditEntry implements Node {
  """The user that caused the audit entry to be created."""
  actor: User

  """The ID of the user that caused the audit entry to be created."""
  actorId: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Country code of request resulting to audit entry."""
  countryCode: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """IP from actor when entry was recorded."""
  ip: String

  """Additional metadata related to the audit entry."""
  metadata: JSONObject

  """The organization the audit log belongs to."""
  organization: Organization

  """
  Additional information related to the request which performed the action.
  """
  requestInformation: JSONObject
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type AuditEntryConnection {
  edges: [AuditEntryEdge!]!
  nodes: [AuditEntry!]!
  pageInfo: PageInfo!
}

type AuditEntryEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: AuditEntry!
}

"""Audit entry filtering options."""
input AuditEntryFilter {
  """Filters that the audit entry actor must satisfy."""
  actor: NullableUserFilter

  """Compound filters, all of which need to be matched by the issue."""
  and: [AuditEntryFilter!]

  """Comparator for the country code."""
  countryCode: StringComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the IP address."""
  ip: StringComparator

  """Compound filters, one of which need to be matched by the issue."""
  or: [AuditEntryFilter!]

  """Comparator for the type."""
  type: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type AuditEntryType {
  """Description of the audit entry type."""
  description: String!

  """The audit entry type."""
  type: String!
}

"""[INTERNAL] An OAuth userId/createdDate tuple"""
type AuthMembership {
  """The user ID associated with the authorization"""
  authorizingUserId: String

  """The date of the authorization"""
  createdAt: DateTime!

  """The user ID the authorization was done for"""
  userId: String!
}

"""
An organization. Organizations are root-level objects that contain users and teams.
"""
type AuthOrganization {
  """Allowed authentication providers, empty array means all are allowed"""
  allowedAuthServices: [String!]!

  """The time at which deletion of the organization was requested."""
  deletionRequestedAt: DateTime

  """
  Whether the organization is enabled. Used as a superuser tool to lock down the org.
  """
  enabled: Boolean!

  """The unique identifier of the entity."""
  id: ID!

  """The organization's logo URL."""
  logoUrl: String

  """The organization's name."""
  name: String!

  """
  Previously used URL keys for the organization (last 3 are kept and redirected).
  """
  previousUrlKeys: [String!]!

  """The region the organization is hosted in."""
  region: String!

  """The feature release channel the organization belongs to."""
  releaseChannel: ReleaseChannel!

  """Whether SAML authentication is enabled for organization."""
  samlEnabled: Boolean!

  """[INTERNAL] SAML settings"""
  samlSettings: JSONObject

  """Whether SCIM provisioning is enabled for organization."""
  scimEnabled: Boolean!

  """The email domain or URL key for the organization."""
  serviceId: String!

  """The organization's unique URL key."""
  urlKey: String!
  userCount: Float!
}

type AuthResolverResponse {
  """Should the signup flow allow access for the domain."""
  allowDomainAccess: Boolean

  """
  List of organizations allowing this user account to join automatically.
  """
  availableOrganizations: [AuthOrganization!]

  """Email for the authenticated account."""
  email: String!

  """User account ID."""
  id: String!

  """ID of the organization last accessed by the user."""
  lastUsedOrganizationId: String

  """
  List of organization available to this user account but locked due to the current auth method.
  """
  lockedOrganizations: [AuthOrganization!]

  """List of locked users that are locked by login restrictions"""
  lockedUsers: [AuthUser!]!

  """Application token."""
  token: String @deprecated(reason: "Deprecated and not used anymore. Never populated.")

  """List of active users that belong to the user account."""
  users: [AuthUser!]!
}

"""A user that has access to the the resources of an organization."""
type AuthUser {
  """Whether the user is active."""
  active: Boolean!

  """An URL to the user's avatar image."""
  avatarUrl: String

  """The user's display (nick) name. Unique within each organization."""
  displayName: String!

  """The user's email address."""
  email: String!
  id: ID!

  """The user's full name."""
  name: String!

  """Organization the user belongs to."""
  organization: AuthOrganization!

  """
  Whether the user is an organization admin or guest on a database level.
  """
  role: UserRoleType!

  """User account ID the user belongs to."""
  userAccountId: String!
}

"""Authentication session information."""
type AuthenticationSessionResponse {
  """Used web browser."""
  browserType: String

  """Client used for the session"""
  client: String

  """Country codes of all seen locations."""
  countryCodes: [String!]!

  """Date when the session was created."""
  createdAt: DateTime!
  id: String!

  """IP address."""
  ip: String

  """Identifies the session used to make the request."""
  isCurrentSession: Boolean!

  """When was the session last seen"""
  lastActiveAt: DateTime

  """Human readable location"""
  location: String

  """Location city name."""
  locationCity: String

  """Location country name."""
  locationCountry: String

  """Location country code."""
  locationCountryCode: String

  """Location region code."""
  locationRegionCode: String

  """Name of the session, derived from the client and operating system"""
  name: String!

  """Operating system used for the session"""
  operatingSystem: String

  """Service used for logging in."""
  service: String

  """Type of application used to authenticate."""
  type: AuthenticationSessionType!

  """Date when the session was last updated."""
  updatedAt: DateTime!

  """Session's user-agent."""
  userAgent: String
}

enum AuthenticationSessionType {
  android
  desktop
  ios
  web
}

"""
[INTERNAL] Public information of the OAuth application, plus the authorized scopes for a given user.
"""
type AuthorizedApplication {
  """OAuth application's ID."""
  appId: String!

  """OAuth application's client ID."""
  clientId: String!

  """Description of the application."""
  description: String

  """Developer of the application."""
  developer: String

  """Developer URL of the application."""
  developerUrl: String

  """Image of the application."""
  imageUrl: String

  """Application name."""
  name: String!

  """Scopes that are authorized for this application for a given user."""
  scope: [String!]!

  """Whether or not webhooks are enabled for the application."""
  webhooksEnabled: Boolean!
}

"""Details of the app user's authorizing user."""
type AuthorizingUser {
  """The user's display name."""
  displayName: String!

  """The user's full name."""
  name: String!
}

"""Comparator for booleans."""
input BooleanComparator {
  """Equals constraint."""
  eq: Boolean

  """Not equals constraint."""
  neq: Boolean
}

"""A comment associated with an issue."""
type Comment implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The comment content in markdown format."""
  body: String!

  """[Internal] The comment content as a Prosemirror document."""
  bodyData: String!

  """The bot that created the comment."""
  botActor: ActorBot

  """The children of the comment."""
  children(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The document content that the comment is associated with."""
  documentContent: DocumentContent

  """The time user edited the comment."""
  editedAt: DateTime

  """The external thread that the comment is synced with."""
  externalThread: SyncedExternalThread

  """The external user who wrote the comment."""
  externalUser: ExternalUser

  """The unique identifier of the entity."""
  id: ID!

  """The initiative update that the comment is associated with."""
  initiativeUpdate: InitiativeUpdate

  """The issue that the comment is associated with."""
  issue: Issue

  """The parent comment under which the current comment is nested."""
  parent: Comment

  """The post that the comment is associated with."""
  post: Post

  """The project update that the comment is associated with."""
  projectUpdate: ProjectUpdate

  """
  The text that this comment references. Only defined for inline comments.
  """
  quotedText: String

  """Emoji reaction summary, grouped by emoji type."""
  reactionData: JSONObject!

  """Reactions associated with the comment."""
  reactions: [Reaction!]!

  """The time the resolvingUser resolved the thread."""
  resolvedAt: DateTime

  """The comment that resolved the thread."""
  resolvingComment: Comment

  """The user that resolved the thread."""
  resolvingUser: User

  """The external services the comment is synced with."""
  syncedWith: [ExternalEntityInfo!]

  """[Internal] A generated summary of the comment thread."""
  threadSummary: JSONObject

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Comment's URL."""
  url: String!

  """The user who wrote the comment."""
  user: User
}

"""Comment filtering options."""
input CommentCollectionFilter {
  """Compound filters, all of which need to be matched by the comment."""
  and: [CommentCollectionFilter!]

  """Comparator for the comment's body."""
  body: StringComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the comment's document content must satisfy."""
  documentContent: NullableDocumentContentFilter

  """Filters that needs to be matched by all comments."""
  every: CommentFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the comment's issue must satisfy."""
  issue: NullableIssueFilter

  """Comparator for the collection length."""
  length: NumberComparator

  """Filters that the comment's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Compound filters, one of which need to be matched by the comment."""
  or: [CommentCollectionFilter!]

  """Filters that the comment parent must satisfy."""
  parent: NullableCommentFilter

  """Filters that the comment's project update must satisfy."""
  projectUpdate: NullableProjectUpdateFilter

  """Filters that the comment's reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """Filters that needs to be matched by some comments."""
  some: CommentFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Filters that the comment's creator must satisfy."""
  user: UserFilter
}

type CommentConnection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
}

input CommentCreateInput {
  """The comment content in markdown format."""
  body: String

  """[Internal] The comment content as a Prosemirror document."""
  bodyData: JSON

  """
  Create comment as a user with the provided name. This option is only available to OAuth applications creating comments in `actor=app` mode.
  """
  createAsUser: String

  """
  Flag to indicate this comment should be created on the issue's synced Slack comment thread. If no synced Slack comment thread exists, the mutation will fail.
  """
  createOnSyncedSlackThread: Boolean

  """
  The date when the comment was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now.
  """
  createdAt: DateTime

  """
  Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
  """
  displayIconUrl: String

  """
  Flag to prevent auto subscription to the issue the comment is created on.
  """
  doNotSubscribeToIssue: Boolean

  """The document content to associate the comment with."""
  documentContentId: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The initiative update to associate the comment with."""
  initiativeUpdateId: String

  """The issue to associate the comment with."""
  issueId: String

  """The parent comment under which to nest a current comment."""
  parentId: String

  """The post to associate the comment with."""
  postId: String

  """The project update to associate the comment with."""
  projectUpdateId: String

  """
  The text that this comment references. Only defined for inline comments.
  """
  quotedText: String

  """
  [INTERNAL] The identifiers of the users subscribing to this comment thread.
  """
  subscriberIds: [String!]
}

type CommentEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Comment!
}

"""Comment filtering options."""
input CommentFilter {
  """Compound filters, all of which need to be matched by the comment."""
  and: [CommentFilter!]

  """Comparator for the comment's body."""
  body: StringComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the comment's document content must satisfy."""
  documentContent: NullableDocumentContentFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the comment's issue must satisfy."""
  issue: NullableIssueFilter

  """Filters that the comment's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Compound filters, one of which need to be matched by the comment."""
  or: [CommentFilter!]

  """Filters that the comment parent must satisfy."""
  parent: NullableCommentFilter

  """Filters that the comment's project update must satisfy."""
  projectUpdate: NullableProjectUpdateFilter

  """Filters that the comment's reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Filters that the comment's creator must satisfy."""
  user: UserFilter
}

type CommentPayload {
  """The comment that was created or updated."""
  comment: Comment!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input CommentUpdateInput {
  """The comment content."""
  body: String

  """[Internal] The comment content as a Prosemirror document."""
  bodyData: JSON

  """
  [INTERNAL] Flag to prevent auto subscription to the issue the comment is updated on.
  """
  doNotSubscribeToIssue: Boolean

  """
  The text that this comment references. Only defined for inline comments.
  """
  quotedText: String

  """[INTERNAL] The child comment that resolves this thread."""
  resolvingCommentId: String

  """[INTERNAL] The user who resolved this thread."""
  resolvingUserId: String

  """[INTERNAL] The identifiers of the users subscribing to this comment."""
  subscriberIds: [String!]
}

"""Issue completion date sorting options."""
input CompletedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input ContactCreateInput {
  """User's browser information."""
  browser: String

  """User's Linear client information."""
  clientVersion: String

  """User's device information."""
  device: String

  """How disappointed the user would be if they could no longer use Linear."""
  disappointmentRating: Int

  """The message the user sent."""
  message: String!

  """User's operating system."""
  operatingSystem: String

  """The type of support contact."""
  type: String!
}

type ContactPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""[INTERNAL] Input for sending a message to the Linear Sales team."""
input ContactSalesCreateInput {
  """Size of the company."""
  companySize: String

  """Work email of the person requesting information."""
  email: String!

  """The message the user sent."""
  message: String

  """Name of the person requesting information."""
  name: String!
}

"""[Internal] Comparator for content."""
input ContentComparator {
  """[Internal] Contains constraint."""
  contains: String

  """[Internal] Not-contains constraint."""
  notContains: String
}

enum ContextViewType {
  activeCycle
  activeIssues
  backlog
  triage
  upcomingCycle
}

type CreateCsvExportReportPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

type CreateOrJoinOrganizationResponse {
  organization: AuthOrganization!
  user: AuthUser!
}

input CreateOrganizationInput {
  """Whether the organization should allow email domain access."""
  domainAccess: Boolean

  """The name of the organization."""
  name: String!

  """The timezone of the organization, passed in by client."""
  timezone: String

  """The URL key of the organization."""
  urlKey: String!

  """
  JSON serialized UTM parameters associated with the creation of the workspace.
  """
  utm: String
}

"""Issue creation date sorting options."""
input CreatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A custom view that has been saved by a user."""
type CustomView implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The color of the icon of the custom view."""
  color: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the custom view."""
  creator: User!

  """The description of the custom view."""
  description: String

  """[INTERNAL] The facet associated with the custom view."""
  facet: Facet

  """The filter applied to feed items in the custom view."""
  feedItemFilterData: JSONObject

  """The filter applied to issues in the custom view."""
  filterData: JSONObject!

  """The filters applied to issues in the custom view."""
  filters: JSONObject! @deprecated(reason: "Will be replaced by `filterData` in a future update")

  """The icon of the custom view."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """The filter applied to initiatives in the custom view."""
  initiativeFilterData: JSONObject

  """Initiatives associated with the custom view."""
  initiatives(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned initiatives."""
    filter: InitiativeFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): InitiativeConnection!

  """Issues associated with the custom view."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    Include issues from sub-teams when the custom view is associated with a team.
    """
    includeSubTeams: Boolean = false

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned issues."""
    sort: [IssueSortInput!]
  ): IssueConnection!

  """The model name of the custom view."""
  modelName: String!

  """The name of the custom view."""
  name: String!

  """The organization of the custom view."""
  organization: Organization!

  """The organizations default view preferences for this custom view."""
  organizationViewPreferences: ViewPreferences

  """The user who owns the custom view."""
  owner: User!

  """The filter applied to projects in the custom view."""
  projectFilterData: JSONObject

  """Projects associated with the custom view."""
  projects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned projects."""
    filter: ProjectFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    Include projects from sub-teams when the custom view is associated with a team.
    """
    includeSubTeams: Boolean = false

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned projects."""
    sort: [ProjectSortInput!]
  ): ProjectConnection!

  """Whether the custom view is shared with everyone in the organization."""
  shared: Boolean!

  """The custom view's unique URL slug."""
  slugId: String

  """The team associated with the custom view."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user who last updated the custom view."""
  updatedBy: User

  """Feed items associated with the custom view."""
  updates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned feed items."""
    filter: FeedItemFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    Include updates from sub-teams when the custom view is associated with a team.
    """
    includeSubTeams: Boolean = false

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): FeedItemConnection!

  """The current users view preferences for this custom view."""
  userViewPreferences: ViewPreferences

  """The calculated view preferences values for this custom view."""
  viewPreferencesValues: ViewPreferencesValues
}

type CustomViewConnection {
  edges: [CustomViewEdge!]!
  nodes: [CustomView!]!
  pageInfo: PageInfo!
}

input CustomViewCreateInput {
  """The color of the icon of the custom view."""
  color: String

  """The description of the custom view."""
  description: String

  """The feed item filter applied to issues in the custom view."""
  feedItemFilterData: FeedItemFilter

  """The filter applied to issues in the custom view."""
  filterData: IssueFilter

  """The filters applied to issues in the custom view."""
  filters: JSONObject @deprecated(reason: "Use `filterData` instead.")

  """The icon of the custom view."""
  icon: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """[ALPHA] The initiative filter applied to issues in the custom view."""
  initiativeFilterData: InitiativeFilter

  """The id of the initiative associated with the custom view."""
  initiativeId: String

  """The name of the custom view."""
  name: String!

  """The owner of the custom view."""
  ownerId: String

  """The project filter applied to issues in the custom view."""
  projectFilterData: ProjectFilter

  """The id of the project associated with the custom view."""
  projectId: String

  """Whether the custom view is shared with everyone in the organization."""
  shared: Boolean

  """The id of the team associated with the custom view."""
  teamId: String
}

"""Custom view creation date sorting options."""
input CustomViewCreatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

type CustomViewEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: CustomView!
}

"""Custom view filtering options."""
input CustomViewFilter {
  """Compound filters, all of which need to be matched by the custom view."""
  and: [CustomViewFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the custom view creator must satisfy."""
  creator: UserFilter

  """[INTERNAL] Filter based on whether the custom view has a facet."""
  hasFacet: Boolean

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the custom view model name."""
  modelName: StringComparator

  """Comparator for the custom view name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the custom view."""
  or: [CustomViewFilter!]

  """Comparator for whether the custom view is shared."""
  shared: BooleanComparator

  """Filters that the custom view's team must satisfy."""
  team: NullableTeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type CustomViewHasSubscribersPayload {
  """Whether the custom view has subscribers."""
  hasSubscribers: Boolean!
}

"""Custom view name sorting options."""
input CustomViewNameSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A custom view notification subscription."""
type CustomViewNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The custom view subscribed to."""
  customView: CustomView!

  """The customer associated with the notification subscription."""
  customer: Customer

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

type CustomViewPayload {
  """The custom view that was created or updated."""
  customView: CustomView!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""
Custom view shared status sorting options. Ascending order puts shared views last.
"""
input CustomViewSharedSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input CustomViewSortInput {
  """Sort by custom view creation date."""
  createdAt: CustomViewCreatedAtSort

  """Sort by custom view name."""
  name: CustomViewNameSort

  """Sort by custom view shared status."""
  shared: CustomViewSharedSort

  """Sort by custom view update date."""
  updatedAt: CustomViewUpdatedAtSort
}

type CustomViewSuggestionPayload {
  """The suggested view description."""
  description: String

  """The suggested view icon."""
  icon: String

  """The suggested view name."""
  name: String
}

input CustomViewUpdateInput {
  """The color of the icon of the custom view."""
  color: String

  """The description of the custom view."""
  description: String

  """The feed item filter applied to issues in the custom view."""
  feedItemFilterData: FeedItemFilter

  """The filter applied to issues in the custom view."""
  filterData: IssueFilter

  """The filters applied to issues in the custom view."""
  filters: JSONObject @deprecated(reason: "Use `filterData` instead.")

  """The icon of the custom view."""
  icon: String

  """[ALPHA] The initiative filter applied to issues in the custom view."""
  initiativeFilterData: InitiativeFilter

  """[Internal] The id of the initiative associated with the custom view."""
  initiativeId: String

  """The name of the custom view."""
  name: String

  """The owner of the custom view."""
  ownerId: String

  """The project filter applied to issues in the custom view."""
  projectFilterData: ProjectFilter

  """[Internal] The id of the project associated with the custom view."""
  projectId: String

  """Whether the custom view is shared with everyone in the organization."""
  shared: Boolean

  """The id of the team associated with the custom view."""
  teamId: String
}

"""Custom view update date sorting options."""
input CustomViewUpdatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A customer whose needs will be tied to issues or projects."""
type Customer implements Node {
  """The approximate number of needs of the customer."""
  approximateNeedCount: Float!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The domains associated with this customer."""
  domains: [String!]!

  """The ids of the customers in external systems."""
  externalIds: [String!]!

  """The unique identifier of the entity."""
  id: ID!

  """The integration that manages the Customer."""
  integration: Integration

  """The customer's logo URL."""
  logoUrl: String

  """
  The ID of the main source, when a customer has multiple sources. Must be one of externalIds.
  """
  mainSourceId: String

  """The customer's name."""
  name: String!

  """The user who owns the customer."""
  owner: User

  """The annual revenue generated by the customer."""
  revenue: Float

  """The size of the customer."""
  size: Float

  """The ID of the Slack channel used to interact with the customer."""
  slackChannelId: String

  """The customer's unique URL slug."""
  slugId: String!

  """The current status of the customer."""
  status: CustomerStatus!

  """The tier of the customer."""
  tier: CustomerTier

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type CustomerConnection {
  edges: [CustomerEdge!]!
  nodes: [Customer!]!
  pageInfo: PageInfo!
}

"""Issue customer count sorting options."""
input CustomerCountSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input CustomerCreateInput {
  """The domains associated with this customer."""
  domains: [String!] = []

  """The ids of the customers in external systems."""
  externalIds: [String!] = []

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The URL of the customer's logo."""
  logoUrl: String

  """
  The main source of the customer, for customers with multiple sources. Must be one of externalIds.
  """
  mainSourceId: String

  """The name of the customer."""
  name: String!

  """The user who owns the customer."""
  ownerId: String

  """The annual revenue generated by the customer."""
  revenue: Int

  """The size of the customer."""
  size: Int

  """The ID of the Slack channel used to interact with the customer."""
  slackChannelId: String

  """The status of the customer."""
  statusId: String

  """The tier of the customer customer."""
  tierId: String
}

"""Customer creation date sorting options."""
input CustomerCreatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

type CustomerEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Customer!
}

"""Customer filtering options."""
input CustomerFilter {
  """Compound filters, all of which need to be matched by the customer."""
  and: [CustomerFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the customer's domains."""
  domains: StringArrayComparator

  """Comparator for the customer's external IDs."""
  externalIds: StringArrayComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the customer name."""
  name: StringComparator

  """Filters that the customer's needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Compound filters, one of which need to be matched by the customer."""
  or: [CustomerFilter!]

  """Filters that the customer owner must satisfy."""
  owner: NullableUserFilter

  """Comparator for the customer generated revenue."""
  revenue: NumberComparator

  """Comparator for the customer size."""
  size: NumberComparator

  """Comparator for the customer slack channel ID."""
  slackChannelId: StringComparator

  """Filters that the customer's status must satisfy."""
  status: CustomerStatusFilter

  """Filters that the customer's tier must satisfy."""
  tier: CustomerTierFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Issue customer important count sorting options."""
input CustomerImportantCountSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""
A customer need, expressed through a reference to an issue, project, or comment.
"""
type CustomerNeed implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The attachment this need is referencing."""
  attachment: Attachment

  """The need content in markdown format."""
  body: String

  """[Internal] The content of the need as a Prosemirror document."""
  bodyData: String

  """The comment this need is referencing."""
  comment: Comment

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The creator of the customer need."""
  creator: User

  """The customer that this need is attached to."""
  customer: Customer

  """The unique identifier of the entity."""
  id: ID!

  """The issue this need is referencing."""
  issue: Issue

  """
  The issue this customer need was originally created on. Will be undefined if the customer need hasn't been moved.
  """
  originalIssue: Issue

  """
  Whether the customer need is important or not. 0 = Not important, 1 = Important.
  """
  priority: Float!

  """The project this need is referencing."""
  project: Project

  """The project attachment this need is referencing."""
  projectAttachment: ProjectAttachment

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The URL of the underlying attachment, if any"""
  url: String
}

"""A generic payload return from entity archive mutations."""
type CustomerNeedArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: CustomerNeed

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Customer needs filtering options."""
input CustomerNeedCollectionFilter {
  """
  Compound filters, all of which need to be matched by the customer needs.
  """
  and: [CustomerNeedCollectionFilter!]

  """Filters that the need's comment must satisfy."""
  comment: NullableCommentFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the need's customer must satisfy."""
  customer: NullableCustomerFilter

  """Filters that needs to be matched by all customer needs."""
  every: CustomerNeedFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the need's issue must satisfy."""
  issue: NullableIssueFilter

  """Comparator for the collection length."""
  length: NumberComparator

  """
  Compound filters, one of which need to be matched by the customer needs.
  """
  or: [CustomerNeedCollectionFilter!]

  """Comparator for the customer need priority."""
  priority: NumberComparator

  """Filters that the need's project must satisfy."""
  project: NullableProjectFilter

  """Filters that needs to be matched by some customer needs."""
  some: CustomerNeedFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type CustomerNeedConnection {
  edges: [CustomerNeedEdge!]!
  nodes: [CustomerNeed!]!
  pageInfo: PageInfo!
}

input CustomerNeedCreateFromAttachmentInput {
  """The attachment this need is created from."""
  attachmentId: String!
}

input CustomerNeedCreateInput {
  """The attachment this need is referencing."""
  attachmentId: String

  """Optional URL for the attachment associated with the customer need."""
  attachmentUrl: String

  """The content of the need in markdown format."""
  body: String

  """[Internal] The content of the need as a Prosemirror document."""
  bodyData: JSON

  """The comment this need is referencing."""
  commentId: String

  """
  Create need as a user with the provided name. This option is only available to OAuth applications creating needs in `actor=app` mode.
  """
  createAsUser: String

  """The external ID of the customer the need belongs to."""
  customerExternalId: String

  """The uuid of the customer the need belongs to."""
  customerId: String

  """
  Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating needs in `actor=app` mode.
  """
  displayIconUrl: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The issue this need is referencing."""
  issueId: String

  """
  Whether the customer need is important or not. 0 = Not important, 1 = Important.
  """
  priority: Float

  """[INTERNAL] The project this need is referencing."""
  projectId: String

  """[DEPRECATED] Optional URL to the source of the customer need."""
  url: String @deprecated(reason: "Use attachmentUrl instead")
}

type CustomerNeedEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: CustomerNeed!
}

"""Customer filtering options."""
input CustomerNeedFilter {
  """
  Compound filters, all of which need to be matched by the customer need.
  """
  and: [CustomerNeedFilter!]

  """Filters that the need's comment must satisfy."""
  comment: NullableCommentFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the need's customer must satisfy."""
  customer: NullableCustomerFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the need's issue must satisfy."""
  issue: NullableIssueFilter

  """
  Compound filters, one of which need to be matched by the customer need.
  """
  or: [CustomerNeedFilter!]

  """Comparator for the customer need priority."""
  priority: NumberComparator

  """Filters that the need's project must satisfy."""
  project: NullableProjectFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""A customer need related notification."""
type CustomerNeedNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The customer need related to the notification."""
  customerNeed: CustomerNeed!

  """Related customer need."""
  customerNeedId: String!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """The issue related to the notification."""
  relatedIssue: Issue

  """The project related to the notification."""
  relatedProject: Project

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

type CustomerNeedPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The customer need that was created or updated."""
  need: CustomerNeed!

  """Whether the operation was successful."""
  success: Boolean!
}

input CustomerNeedUpdateInput {
  """
  Whether to also update the priority of needs from the same customer on the same issue/project.
  """
  applyPriorityToRelatedNeeds: Boolean

  """Optional URL for the attachment associated with the customer need."""
  attachmentUrl: String

  """The content of the need in markdown format."""
  body: String

  """[Internal] The content of the need as a Prosemirror document."""
  bodyData: JSON

  """The external ID of the customer the need belongs to."""
  customerExternalId: String

  """The uuid of the customer the need belongs to."""
  customerId: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The issue this need is referencing."""
  issueId: String

  """
  Whether the customer need is important or not. 0 = Not important, 1 = Important.
  """
  priority: Float

  """[INTERNAL] The project this need is referencing."""
  projectId: String

  """[DEPRECATED] Optional URL to the source of the customer need."""
  url: String @deprecated(reason: "Use attachmentUrl instead")
}

type CustomerNeedUpdatePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The customer need that was created or updated."""
  need: CustomerNeed!

  """Whether the operation was successful."""
  success: Boolean!

  """The related customer needs that were updated."""
  updatedRelatedNeeds: [CustomerNeed!]!
}

"""A customer related notification."""
type CustomerNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The customer related to the notification."""
  customer: Customer!

  """Related customer."""
  customerId: String!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

"""A customer notification subscription."""
type CustomerNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer subscribed to."""
  customer: Customer!

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

type CustomerPayload {
  """The customer that was created or updated."""
  customer: Customer!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Issue customer revenue sorting options."""
input CustomerRevenueSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Issue customer sorting options."""
input CustomerSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Customer sorting options."""
input CustomerSortInput {
  """Sort by approximate customer need count"""
  approximateNeedCount: ApproximateNeedCountSort

  """Sort by customer creation date"""
  createdAt: CustomerCreatedAtSort

  """Sort by name"""
  name: NameSort

  """Sort by owner name"""
  owner: OwnerSort

  """Sort by customer generated revenue"""
  revenue: RevenueSort

  """Sort by customer size"""
  size: SizeSort

  """Sort by customer status"""
  status: CustomerStatusSort

  """Sort by customer tier"""
  tier: TierSort
}

"""A customer status."""
type CustomerStatus implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The UI color of the status as a HEX string."""
  color: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Description of the status."""
  description: String

  """The display name of the status."""
  displayName: String!

  """The unique identifier of the entity."""
  id: ID!

  """The name of the status."""
  name: String!

  """The position of the status in the workspace's customers flow."""
  position: Float!

  """The type of the customer status."""
  type: CustomerStatusType @deprecated(reason: "Customer statuses are no longer grouped by type.")

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type CustomerStatusConnection {
  edges: [CustomerStatusEdge!]!
  nodes: [CustomerStatus!]!
  pageInfo: PageInfo!
}

input CustomerStatusCreateInput {
  """The UI color of the status as a HEX string."""
  color: String!

  """Description of the status."""
  description: String

  """The display name of the status."""
  displayName: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the status."""
  name: String

  """The position of the status in the workspace's customer flow."""
  position: Float
}

type CustomerStatusEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: CustomerStatus!
}

"""Customer status filtering options."""
input CustomerStatusFilter {
  """
  Compound filters, all of which need to be matched by the customer status.
  """
  and: [CustomerStatusFilter!]

  """Comparator for the customer status color."""
  color: StringComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the customer status description."""
  description: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the customer status name."""
  name: StringComparator

  """
  Compound filters, one of which needs to be matched by the customer status.
  """
  or: [CustomerStatusFilter!]

  """Comparator for the customer status position."""
  position: NumberComparator

  """Comparator for the customer status type."""
  type: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type CustomerStatusPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The customer status that was created or updated."""
  status: CustomerStatus!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Customer status sorting options."""
input CustomerStatusSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""[DEPRECATED] A type of customer status."""
enum CustomerStatusType {
  active
  inactive
}

input CustomerStatusUpdateInput {
  """The UI color of the status as a HEX string."""
  color: String

  """Description of the status."""
  description: String

  """The display name of the status."""
  displayName: String

  """The name of the status."""
  name: String

  """The position of the status in the workspace's customer flow."""
  position: Float
}

"""A customer tier."""
type CustomerTier implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The UI color of the tier as a HEX string."""
  color: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Description of the tier."""
  description: String

  """The display name of the tier."""
  displayName: String!

  """The unique identifier of the entity."""
  id: ID!

  """The name of the tier."""
  name: String!

  """The position of the tier in the workspace's customers flow."""
  position: Float!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type CustomerTierConnection {
  edges: [CustomerTierEdge!]!
  nodes: [CustomerTier!]!
  pageInfo: PageInfo!
}

input CustomerTierCreateInput {
  """The UI color of the tier as a HEX string."""
  color: String!

  """Description of the tier."""
  description: String

  """The display name of the tier."""
  displayName: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the tier."""
  name: String

  """The position of the tier in the workspace's customer flow."""
  position: Float
}

type CustomerTierEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: CustomerTier!
}

"""Customer tier filtering options."""
input CustomerTierFilter {
  """
  Compound filters, all of which need to be matched by the customer tier.
  """
  and: [CustomerTierFilter!]

  """Comparator for the customer tier color."""
  color: StringComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the customer tier description."""
  description: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the customer tier name."""
  name: StringComparator

  """
  Compound filters, one of which needs to be matched by the customer tier.
  """
  or: [CustomerTierFilter!]

  """Comparator for the customer tier position."""
  position: NumberComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type CustomerTierPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The customer tier that was created or updated."""
  tier: CustomerTier!
}

input CustomerTierUpdateInput {
  """The UI color of the tier as a HEX string."""
  color: String

  """Description of the tier."""
  description: String

  """The display name of the tier."""
  displayName: String

  """The name of the tier."""
  name: String

  """The position of the tier in the workspace's customer flow."""
  position: Float
}

input CustomerUpdateInput {
  """The domains associated with this customer."""
  domains: [String!]

  """The ids of the customers in external systems."""
  externalIds: [String!]

  """The URL of the customer's logo."""
  logoUrl: String

  """
  The main source of the customer, for customers with multiple sources. Must be one of externalIds.
  """
  mainSourceId: String

  """The name of the customer."""
  name: String

  """The user who owns the customer."""
  ownerId: String

  """The annual revenue generated by the customer."""
  revenue: Int

  """The size of the customer."""
  size: Int

  """The ID of the Slack channel used to interact with the customer."""
  slackChannelId: String

  """The status of the customer."""
  statusId: String

  """The tier of the customer customer."""
  tierId: String
}

input CustomerUpsertInput {
  """The domains associated with this customer."""
  domains: [String!]

  """The id of the customers in external systems."""
  externalId: String

  """The identifier in UUID v4 format."""
  id: String

  """The URL of the customer's logo."""
  logoUrl: String

  """The name of the customer."""
  name: String

  """The user who owns the customer."""
  ownerId: String

  """The annual revenue generated by the customer."""
  revenue: Int

  """The size of the customer."""
  size: Int

  """The ID of the Slack channel used to interact with the customer."""
  slackChannelId: String

  """The status of the customer."""
  statusId: String

  """The tier of the customer."""
  tierId: String

  """The name tier of the customer. Will be created if doesn't exist"""
  tierName: String
}

"""A set of issues to be resolved in a specified amount of time."""
type Cycle implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The time at which the cycle was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """
  The completion time of the cycle. If null, the cycle hasn't been completed.
  """
  completedAt: DateTime

  """The number of completed issues in the cycle after each day."""
  completedIssueCountHistory: [Float!]!

  """The number of completed estimation points after each day."""
  completedScopeHistory: [Float!]!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """[Internal] The current progress of the cycle."""
  currentProgress: JSONObject!

  """The cycle's description."""
  description: String

  """The end time of the cycle."""
  endsAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The number of in progress estimation points after each day."""
  inProgressScopeHistory: [Float!]!

  """The cycle inherited from."""
  inheritedFrom: Cycle

  """Whether the cycle is currently active."""
  isActive: Boolean!

  """Whether the cycle is in the future."""
  isFuture: Boolean!

  """Whether the cycle is the next cycle for the team."""
  isNext: Boolean!

  """Whether the cycle is in the past."""
  isPast: Boolean!

  """Whether the cycle is the previous cycle for the team."""
  isPrevious: Boolean!

  """The total number of issues in the cycle after each day."""
  issueCountHistory: [Float!]!

  """Issues associated with the cycle."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """The custom name of the cycle."""
  name: String

  """The number of the cycle."""
  number: Float!

  """
  The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  """
  progress: Float!

  """[Internal] The progress history of the cycle."""
  progressHistory: JSONObject!

  """The total number of estimation points after each day."""
  scopeHistory: [Float!]!

  """The start time of the cycle."""
  startsAt: DateTime!

  """The team that the cycle is associated with."""
  team: Team!

  """Issues that weren't completed when the cycle was closed."""
  uncompletedIssuesUponClose(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""A generic payload return from entity archive mutations."""
type CycleArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Cycle

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type CycleConnection {
  edges: [CycleEdge!]!
  nodes: [Cycle!]!
  pageInfo: PageInfo!
}

input CycleCreateInput {
  """
  The completion time of the cycle. If null, the cycle hasn't been completed.
  """
  completedAt: DateTime

  """The description of the cycle."""
  description: String

  """The end date of the cycle."""
  endsAt: DateTime!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The custom name of the cycle."""
  name: String

  """The start date of the cycle."""
  startsAt: DateTime!

  """The team to associate the cycle with."""
  teamId: String!
}

type CycleEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Cycle!
}

"""Cycle filtering options."""
input CycleFilter {
  """Compound filters, all of which need to be matched by the cycle."""
  and: [CycleFilter!]

  """Comparator for the cycle completed at date."""
  completedAt: DateComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the cycle ends at date."""
  endsAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the filtering active cycle."""
  isActive: BooleanComparator

  """Comparator for the filtering future cycles."""
  isFuture: BooleanComparator

  """
  Comparator for filtering for whether the cycle is currently in cooldown.
  """
  isInCooldown: BooleanComparator

  """Comparator for the filtering next cycle."""
  isNext: BooleanComparator

  """Comparator for the filtering past cycles."""
  isPast: BooleanComparator

  """Comparator for the filtering previous cycle."""
  isPrevious: BooleanComparator

  """Filters that the cycles issues must satisfy."""
  issues: IssueCollectionFilter

  """Comparator for the cycle name."""
  name: StringComparator

  """Comparator for the cycle number."""
  number: NumberComparator

  """Compound filters, one of which need to be matched by the cycle."""
  or: [CycleFilter!]

  """Comparator for the cycle start date."""
  startsAt: DateComparator

  """Filters that the cycles team must satisfy."""
  team: TeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""A cycle notification subscription."""
type CycleNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer associated with the notification subscription."""
  customer: Customer

  """The cycle subscribed to."""
  cycle: Cycle!

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

type CyclePayload {
  """The Cycle that was created or updated."""
  cycle: Cycle

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

enum CyclePeriod {
  after
  before
  during
}

"""Comparator for period when issue was added to a cycle."""
input CyclePeriodComparator {
  """Equals constraint."""
  eq: CyclePeriod

  """In-array constraint."""
  in: [CyclePeriod!]

  """Not-equals constraint."""
  neq: CyclePeriod

  """Not-in-array constraint."""
  nin: [CyclePeriod!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean
}

"""
Input for shifting all cycles from a certain cycle onwards by a certain number of days
"""
input CycleShiftAllInput {
  """The number of days to shift the cycles by."""
  daysToShift: Float!

  """The cycle ID at which to start the shift."""
  id: String!
}

"""Issue cycle sorting options."""
input CycleSort {
  """
  When set to true, cycles will be ordered with a custom order. Current cycle comes first, followed by upcoming cycles in ASC order, followed by previous cycles in DESC order.
  """
  currentCycleFirst: Boolean = false

  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input CycleUpdateInput {
  """The end date of the cycle."""
  completedAt: DateTime

  """The description of the cycle."""
  description: String

  """The end date of the cycle."""
  endsAt: DateTime

  """The custom name of the cycle."""
  name: String

  """The start date of the cycle."""
  startsAt: DateTime
}

"""
[Internal] A dashboard, usually a collection of widgets to display several insights at once.
"""
type Dashboard implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The color of the icon of the dashboard."""
  color: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the dashboard."""
  creator: User

  """The description of the dashboard."""
  description: String

  """The icon of the dashboard."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """The filter applied to all dashboard widgets showing issues data."""
  issueFilter: JSONObject

  """The name of the dashboard."""
  name: String!

  """The organization of the dashboard."""
  organization: Organization!

  """The owner of the dashboard."""
  owner: User

  """The filter applied to all dashboard widgets showing projects data."""
  projectFilter: JSONObject

  """Whether the dashboard is shared with everyone in the organization."""
  shared: Boolean!

  """The dashboard's unique URL slug."""
  slugId: String!

  """The sort order of the dashboard within the organization or its team."""
  sortOrder: Float!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user who last updated the dashboard."""
  updatedBy: User

  """The widgets on the dashboard."""
  widgets: JSONObject!
}

"""Comparator for dates."""
input DateComparator {
  """Equals constraint."""
  eq: DateTimeOrDuration

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: DateTimeOrDuration

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: DateTimeOrDuration

  """In-array constraint."""
  in: [DateTimeOrDuration!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: DateTimeOrDuration

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: DateTimeOrDuration

  """Not-equals constraint."""
  neq: DateTimeOrDuration

  """Not-in-array constraint."""
  nin: [DateTimeOrDuration!]
}

"""By which resolution is a date defined."""
enum DateResolutionType {
  halfYear
  month
  quarter
  year
}

"""
Represents a date and time in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) 
"""
scalar DateTime

"""
Represents a date and time in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) 
"""
scalar DateTimeOrDuration

"""The day of the week."""
enum Day {
  Friday
  Monday
  Saturday
  Sunday
  Thursday
  Tuesday
  Wednesday
}

"""Issue delegate sorting options."""
input DelegateSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input DeleteOrganizationInput {
  """The deletion code to confirm operation."""
  deletionCode: String!
}

"""A generic payload return from entity deletion mutations."""
type DeletePayload implements ArchivePayload {
  """The identifier of the deleted entity."""
  entityId: String!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""A document that can be attached to different entities."""
type Document implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The color of the icon."""
  color: String

  """Comments associated with the document."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The documents content in markdown format."""
  content: String

  """[Internal] The documents content as YJS state."""
  contentState: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the document."""
  creator: User

  """The ID of the document content associated with the document."""
  documentContentId: String

  """
  The time at which the document was hidden. Null if the entity has not been hidden.
  """
  hiddenAt: DateTime

  """The icon of the document."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """The initiative that the document is associated with."""
  initiative: Initiative

  """The last template that was applied to this document."""
  lastAppliedTemplate: Template

  """The project that the document is associated with."""
  project: Project

  """The document's unique URL slug."""
  slugId: String!

  """The order of the item in the resources list."""
  sortOrder: Float!

  """[Internal] The team that the document is associated with."""
  team: Team

  """The document title."""
  title: String!

  """A flag that indicates whether the document is in the trash bin."""
  trashed: Boolean

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user who last updated the document."""
  updatedBy: User

  """The canonical url for the document."""
  url: String!
}

"""A generic payload return from entity archive mutations."""
type DocumentArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Document

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type DocumentConnection {
  edges: [DocumentEdge!]!
  nodes: [Document!]!
  pageInfo: PageInfo!
}

"""A document content for a project."""
type DocumentContent implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The document content in markdown format."""
  content: String

  """The document content state as a base64 encoded string."""
  contentState: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The document that the content is associated with."""
  document: Document

  """The unique identifier of the entity."""
  id: ID!

  """The initiative that the content is associated with."""
  initiative: Initiative

  """The issue that the content is associated with."""
  issue: Issue

  """The project that the content is associated with."""
  project: Project

  """The project milestone that the content is associated with."""
  projectMilestone: ProjectMilestone

  """
  The time at which the document content was restored from a previous version.
  """
  restoredAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type DocumentContentHistoryPayload {
  """The document content history entries."""
  history: [DocumentContentHistoryType!]!

  """Whether the operation was successful."""
  success: Boolean!
}

type DocumentContentHistoryType {
  """The ID of the author of the change."""
  actorIds: [String!]

  """[Internal] The document content as Prosemirror document."""
  contentData: JSON

  """
  The date when the document content history snapshot was taken. This can be different than createdAt since the content is captured from its state at the previously known updatedAt timestamp in the case of an update. On document create, these timestamps can be the same.
  """
  contentDataSnapshotAt: DateTime!

  """The date when the document content history entry was created."""
  createdAt: DateTime!

  """The UUID of the document content history entry."""
  id: String!
}

input DocumentCreateInput {
  """The color of the icon."""
  color: String

  """The document content as markdown."""
  content: String

  """[Internal] The document content as a Prosemirror document."""
  contentData: JSONObject @deprecated(reason: "Use content instead")

  """The icon of the document."""
  icon: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """[Internal] Related initiative for the document."""
  initiativeId: String

  """The ID of the last template applied to the document."""
  lastAppliedTemplateId: String

  """Related project for the document."""
  projectId: String

  """[Internal] The resource folder containing the document."""
  resourceFolderId: String

  """The order of the item in the resources list."""
  sortOrder: Float

  """[INTERNAL] The identifiers of the users subscribing to this document."""
  subscriberIds: [String!]

  """[Internal] Related team for the document."""
  teamId: String

  """The title of the document."""
  title: String!
}

type DocumentEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Document!
}

"""Document filtering options."""
input DocumentFilter {
  """Compound filters, all of which need to be matched by the document."""
  and: [DocumentFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the document's creator must satisfy."""
  creator: UserFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the document's initiative must satisfy."""
  initiative: InitiativeFilter

  """Compound filters, one of which need to be matched by the document."""
  or: [DocumentFilter!]

  """Filters that the document's project must satisfy."""
  project: ProjectFilter

  """Comparator for the document slug ID."""
  slugId: StringComparator

  """Comparator for the document title."""
  title: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""A document related notification."""
type DocumentNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """
  Related comment ID. Null if the notification is not related to a comment.
  """
  commentId: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Related document ID."""
  documentId: String!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """
  Related parent comment ID. Null if the notification is not related to a comment.
  """
  parentCommentId: String

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """Name of the reaction emoji related to the notification."""
  reactionEmoji: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

type DocumentPayload {
  """The document that was created or updated."""
  document: Document!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type DocumentSearchPayload {
  """
  Archived entities matching the search term along with all their dependencies.
  """
  archivePayload: ArchiveResponse!
  edges: [DocumentSearchResultEdge!]!
  nodes: [DocumentSearchResult!]!
  pageInfo: PageInfo!

  """Total number of results for query without filters applied."""
  totalCount: Float!
}

type DocumentSearchResult implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The color of the icon."""
  color: String

  """Comments associated with the document."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The documents content in markdown format."""
  content: String

  """[Internal] The documents content as YJS state."""
  contentState: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the document."""
  creator: User

  """The ID of the document content associated with the document."""
  documentContentId: String

  """
  The time at which the document was hidden. Null if the entity has not been hidden.
  """
  hiddenAt: DateTime

  """The icon of the document."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """The initiative that the document is associated with."""
  initiative: Initiative

  """The last template that was applied to this document."""
  lastAppliedTemplate: Template

  """Metadata related to search result."""
  metadata: JSONObject!

  """The project that the document is associated with."""
  project: Project

  """The document's unique URL slug."""
  slugId: String!

  """The order of the item in the resources list."""
  sortOrder: Float!

  """[Internal] The team that the document is associated with."""
  team: Team

  """The document title."""
  title: String!

  """A flag that indicates whether the document is in the trash bin."""
  trashed: Boolean

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user who last updated the document."""
  updatedBy: User

  """The canonical url for the document."""
  url: String!
}

type DocumentSearchResultEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: DocumentSearchResult!
}

input DocumentUpdateInput {
  """The color of the icon."""
  color: String

  """The document content as markdown."""
  content: String

  """[Internal] The document content as a Prosemirror document."""
  contentData: JSONObject @deprecated(reason: "Use content instead")

  """The time at which the document was hidden."""
  hiddenAt: DateTime

  """The icon of the document."""
  icon: String

  """[Internal] Related initiative for the document."""
  initiativeId: String

  """The ID of the last template applied to the document."""
  lastAppliedTemplateId: String

  """Related project for the document."""
  projectId: String

  """[Internal] The resource folder containing the document."""
  resourceFolderId: String

  """The order of the item in the resources list."""
  sortOrder: Float

  """[INTERNAL] The identifiers of the users subscribing to this document."""
  subscriberIds: [String!]

  """[Internal] Related team for the document."""
  teamId: String

  """The title of the document."""
  title: String

  """Whether the document has been trashed."""
  trashed: Boolean
}

"""A general purpose draft. Used for comments, project updates, etc."""
type Draft implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The text content as a Prosemirror document."""
  bodyData: JSON!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The customer need that this draft is referencing."""
  customerNeed: CustomerNeed

  """Additional properties for the draft."""
  data: JSONObject

  """The unique identifier of the entity."""
  id: ID!

  """The initiative for which this is a draft initiative update."""
  initiative: Initiative

  """The initiative update for which this is a draft comment."""
  initiativeUpdate: InitiativeUpdate

  """Whether the draft was autogenerated for the user."""
  isAutogenerated: Boolean!

  """The issue for which this is a draft comment."""
  issue: Issue

  """The comment for which this is a draft comment reply."""
  parentComment: Comment

  """The post for which this is a draft comment."""
  post: Post

  """The project for which this is a draft project update."""
  project: Project

  """The project update for which this is a draft comment."""
  projectUpdate: ProjectUpdate

  """The team for which this is a draft post."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user who created the draft."""
  user: User!

  """[INTERNAL] Whether the draft was ported from a local draft."""
  wasLocalDraft: Boolean!
}

type DraftConnection {
  edges: [DraftEdge!]!
  nodes: [Draft!]!
  pageInfo: PageInfo!
}

type DraftEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Draft!
}

"""Issue due date sorting options."""
input DueDateSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""
Represents a duration in ISO 8601 format. Accepts ISO 8601 duration strings or integers in milliseconds.
"""
scalar Duration

"""An email address that can be used for submitting issues."""
type EmailIntakeAddress implements Node {
  """Unique email address user name (before @) used for incoming email."""
  address: String!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the email intake address."""
  creator: User

  """
  Whether issues created from that email address will be turned into customer requests.
  """
  customerRequestsEnabled: Boolean!

  """Whether the email address is enabled."""
  enabled: Boolean!

  """The email address used to forward emails to the intake address."""
  forwardingEmailAddress: String

  """The unique identifier of the entity."""
  id: ID!

  """The organization that the email address is associated with."""
  organization: Organization!

  """Whether email replies are enabled."""
  repliesEnabled: Boolean!

  """The name to be used for outgoing emails."""
  senderName: String

  """The SES domain identity that the email address is associated with."""
  sesDomainIdentity: SesDomainIdentity

  """The team that the email address is associated with."""
  team: Team

  """The template that the email address is associated with."""
  template: Template

  """The type of the email address."""
  type: EmailIntakeAddressType!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

input EmailIntakeAddressCreateInput {
  """Whether customer requests are enabled."""
  customerRequestsEnabled: Boolean

  """The email address used to forward emails to the intake address."""
  forwardingEmailAddress: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """Whether email replies are enabled."""
  repliesEnabled: Boolean

  """The name to be used for outgoing emails."""
  senderName: String

  """
  The identifier or key of the team this email address will intake issues for.
  """
  teamId: String

  """
  The identifier of the template this email address will intake issues for.
  """
  templateId: String

  """
  The type of the email address. If not provided, the backend will default to team or template.
  """
  type: EmailIntakeAddressType
}

type EmailIntakeAddressPayload {
  """The email address that was created or updated."""
  emailIntakeAddress: EmailIntakeAddress!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The type of the email address."""
enum EmailIntakeAddressType {
  asks
  team
  template
}

input EmailIntakeAddressUpdateInput {
  """Whether customer requests are enabled."""
  customerRequestsEnabled: Boolean

  """
  Whether the email address is currently enabled. If set to false, the email address will be disabled and no longer accept incoming emails.
  """
  enabled: Boolean

  """The email address used to forward emails to the intake address."""
  forwardingEmailAddress: String

  """Whether email replies are enabled."""
  repliesEnabled: Boolean

  """The name to be used for outgoing emails."""
  senderName: String

  """
  The identifier or key of the team this email address will intake issues for.
  """
  teamId: String

  """
  The identifier of the template this email address will intake issues for.
  """
  templateId: String
}

input EmailUnsubscribeInput {
  """The user's email validation token."""
  token: String!

  """Email type to unsubscribe from."""
  type: String!

  """The identifier of the user."""
  userId: String!
}

type EmailUnsubscribePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input EmailUserAccountAuthChallengeInput {
  """Auth code for the client initiating the sequence."""
  clientAuthCode: String

  """The email for which to generate the magic login code."""
  email: String!

  """The organization invite link to associate with this authentication."""
  inviteLink: String

  """Whether the login was requested from the desktop app."""
  isDesktop: Boolean

  """
  Whether to only return the login code. This is used by mobile apps to skip showing the login link.
  """
  loginCodeOnly: Boolean

  """Signup code."""
  signupCode: String @deprecated(reason: "Not used anymore")
}

type EmailUserAccountAuthChallengeResponse {
  """
  Supported challenge for this user account. Can be either verificationCode or password.
  """
  authType: String!

  """Whether the operation was successful."""
  success: Boolean!
}

"""A custom emoji."""
type Emoji implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the emoji."""
  creator: User

  """The unique identifier of the entity."""
  id: ID!

  """The emoji's name."""
  name: String!

  """The organization that the emoji belongs to."""
  organization: Organization!

  """The source of the emoji."""
  source: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The emoji image URL."""
  url: String!
}

type EmojiConnection {
  edges: [EmojiEdge!]!
  nodes: [Emoji!]!
  pageInfo: PageInfo!
}

input EmojiCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the custom emoji."""
  name: String!

  """The URL for the emoji."""
  url: String!
}

type EmojiEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Emoji!
}

type EmojiPayload {
  """The emoji that was created."""
  emoji: Emoji!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""A basic entity."""
interface Entity implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""An external link for an entity like initiative, etc..."""
type EntityExternalLink implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the link."""
  creator: User!

  """The unique identifier of the entity."""
  id: ID!

  """The initiative that the link is associated with."""
  initiative: Initiative

  """The link's label."""
  label: String!

  """The order of the item in the resources list."""
  sortOrder: Float!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The link's URL."""
  url: String!
}

type EntityExternalLinkConnection {
  edges: [EntityExternalLinkEdge!]!
  nodes: [EntityExternalLink!]!
  pageInfo: PageInfo!
}

input EntityExternalLinkCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The initiative associated with the link."""
  initiativeId: String

  """The label for the link."""
  label: String!

  """The project associated with the link."""
  projectId: String

  """[Internal] The resource folder containing the link."""
  resourceFolderId: String

  """The order of the item in the entities resources list."""
  sortOrder: Float

  """[Internal] The team associated with the link."""
  teamId: String

  """The URL of the link."""
  url: String!
}

type EntityExternalLinkEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: EntityExternalLink!
}

type EntityExternalLinkPayload {
  """The link that was created or updated."""
  entityExternalLink: EntityExternalLink!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input EntityExternalLinkUpdateInput {
  """The label for the link."""
  label: String

  """[Internal] The resource folder containing the link."""
  resourceFolderId: String

  """The order of the item in the entities resources list."""
  sortOrder: Float

  """The URL of the link."""
  url: String
}

"""Comparator for estimates."""
input EstimateComparator {
  """Compound filters, one of which need to be matched by the estimate."""
  and: [NullableNumberComparator!]

  """Equals constraint."""
  eq: Float

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: Float

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: Float

  """In-array constraint."""
  in: [Float!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: Float

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: Float

  """Not-equals constraint."""
  neq: Float

  """Not-in-array constraint."""
  nin: [Float!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean

  """Compound filters, all of which need to be matched by the estimate."""
  or: [NullableNumberComparator!]
}

"""Issue estimate sorting options."""
input EstimateSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Information about an external entity."""
type ExternalEntityInfo {
  """The id of the external entity."""
  id: String!

  """Metadata about the external entity."""
  metadata: ExternalEntityInfoMetadata

  """The name of the service this entity is synced with."""
  service: ExternalSyncService!
}

"""Metadata about the external GitHub entity."""
type ExternalEntityInfoGithubMetadata {
  """The number of the issue."""
  number: Float

  """The owner of the repository."""
  owner: String

  """The repository name."""
  repo: String
}

"""Metadata about the external Jira entity."""
type ExternalEntityInfoJiraMetadata {
  """The key of the Jira issue."""
  issueKey: String

  """The id of the Jira issue type."""
  issueTypeId: String

  """The id of the Jira project."""
  projectId: String
}

union ExternalEntityInfoMetadata = ExternalEntityInfoGithubMetadata | ExternalEntityInfoJiraMetadata | ExternalEntitySlackMetadata

"""Metadata about the external Slack entity."""
type ExternalEntitySlackMetadata {
  """The id of the Slack channel."""
  channelId: String

  """The name of the Slack channel."""
  channelName: String

  """Whether the entity originated from Slack (not Linear)."""
  isFromSlack: Boolean!

  """The URL of the Slack message."""
  messageUrl: String
}

"""The service that syncs an external entity to Linear."""
enum ExternalSyncService {
  github
  jira
  slack
}

"""
An external authenticated (e.g., through Slack) user which doesn't have a Linear account, but can create and update entities in Linear from the external system that authenticated them.
"""
type ExternalUser implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """An URL to the external user's avatar image."""
  avatarUrl: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The external user's display name. Unique within each organization. Can match the display name of an actual user.
  """
  displayName: String!

  """The external user's email address."""
  email: String

  """The unique identifier of the entity."""
  id: ID!

  """The last time the external user was seen interacting with Linear."""
  lastSeen: DateTime

  """The external user's full name."""
  name: String!

  """Organization the external user belongs to."""
  organization: Organization!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type ExternalUserConnection {
  edges: [ExternalUserEdge!]!
  nodes: [ExternalUser!]!
  pageInfo: PageInfo!
}

type ExternalUserEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ExternalUser!
}

"""
A facet. Facets are joins between entities. A facet can tie a custom view to a project, or a a project to a roadmap for example.
"""
type Facet implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The sort order of the facet."""
  sortOrder: Float!

  """The owning feed user."""
  sourceFeedUser: User

  """The owning initiative."""
  sourceInitiative: Initiative

  """The owning organization."""
  sourceOrganization: Organization

  """The owning page."""
  sourcePage: FacetPageSource

  """The owning project."""
  sourceProject: Project

  """The owning team."""
  sourceTeam: Team

  """The targeted custom view."""
  targetCustomView: CustomView

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

enum FacetPageSource {
  feed
  projects
  teamIssues
}

"""User favorites presented in the sidebar."""
type Favorite implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Children of the favorite. Only applies to favorites of type folder."""
  children(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): FavoriteConnection!

  """
  [Internal] Returns the color of the favorite's icon. Unavailable for avatars and views with fixed icons (e.g. cycle).
  """
  color: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The favorited custom view."""
  customView: CustomView

  """The favorited customer."""
  customer: Customer

  """The favorited cycle."""
  cycle: Cycle

  """The favorited dashboard."""
  dashboard: Dashboard

  """
  [Internal] Detail text for favorite's `title` (e.g. team's name for a project).
  """
  detail: String

  """The favorited document."""
  document: Document

  """[INTERNAL] The favorited facet."""
  facet: Facet

  """The name of the folder. Only applies to favorites of type folder."""
  folderName: String

  """
  [Internal] Name of the favorite's icon. Unavailable for standard views, issues, and avatars
  """
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """The favorited initiative."""
  initiative: Initiative

  """The targeted tab of the initiative."""
  initiativeTab: InitiativeTab

  """The favorited issue."""
  issue: Issue

  """The favorited label."""
  label: IssueLabel

  """The owner of the favorite."""
  owner: User!

  """The parent folder of the favorite."""
  parent: Favorite

  """The team of the favorited predefined view."""
  predefinedViewTeam: Team

  """The type of favorited predefined view."""
  predefinedViewType: String

  """The favorited project."""
  project: Project

  """The favorited project label."""
  projectLabel: ProjectLabel

  """The targeted tab of the project."""
  projectTab: ProjectTab

  """[DEPRECATED] The favorited team of the project."""
  projectTeam: Team

  """The favorited pull request."""
  pullRequest: PullRequest

  """The order of the item in the favorites list."""
  sortOrder: Float!

  """
  [Internal] Favorite's title text (name of the favorite'd object or folder).
  """
  title: String!

  """The type of the favorite."""
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """URL of the favorited entity. Folders return 'null' value."""
  url: String

  """The favorited user."""
  user: User
}

type FavoriteConnection {
  edges: [FavoriteEdge!]!
  nodes: [Favorite!]!
  pageInfo: PageInfo!
}

input FavoriteCreateInput {
  """The identifier of the custom view to favorite."""
  customViewId: String

  """The identifier of the customer to favorite."""
  customerId: String

  """The identifier of the cycle to favorite."""
  cycleId: String

  """The identifier of the dashboard to favorite."""
  dashboardId: String

  """The identifier of the document to favorite."""
  documentId: String

  """The identifier of the facet to favorite."""
  facetId: String

  """The name of the favorite folder."""
  folderName: String

  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """[INTERNAL] The identifier of the initiative to favorite."""
  initiativeId: String

  """The tab of the initiative to favorite."""
  initiativeTab: InitiativeTab

  """The identifier of the issue to favorite."""
  issueId: String

  """The identifier of the label to favorite."""
  labelId: String

  """The parent folder of the favorite."""
  parentId: String

  """The identifier of team for the predefined view to favorite."""
  predefinedViewTeamId: String

  """The type of the predefined view to favorite."""
  predefinedViewType: String

  """The identifier of the project to favorite."""
  projectId: String

  """The identifier of the label to favorite."""
  projectLabelId: String

  """The tab of the project to favorite."""
  projectTab: ProjectTab

  """The identifier of the pull request to favorite."""
  pullRequestId: String

  """The position of the item in the favorites list."""
  sortOrder: Float

  """The identifier of the user to favorite."""
  userId: String
}

type FavoriteEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Favorite!
}

type FavoritePayload {
  """The object that was added as a favorite."""
  favorite: Favorite!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input FavoriteUpdateInput {
  """The name of the favorite folder."""
  folderName: String

  """
  The identifier (in UUID v4 format) of the folder to move the favorite under.
  """
  parentId: String

  """The position of the item in the favorites list."""
  sortOrder: Float
}

"""[Internal] An item in a users feed."""
type FeedItem implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The initiative update that is in the feed."""
  initiativeUpdate: InitiativeUpdate

  """The organization that will see this feed item."""
  organization: Organization!

  """The post that is in the feed."""
  post: Post

  """The project update that is in the feed."""
  projectUpdate: ProjectUpdate

  """The team that will see this feed item."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user that will see this feed item."""
  user: User
}

type FeedItemConnection {
  edges: [FeedItemEdge!]!
  nodes: [FeedItem!]!
  pageInfo: PageInfo!
}

type FeedItemEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: FeedItem!
}

"""Feed item filtering options"""
input FeedItemFilter {
  """Compound filters, all of which need to be matched by the feed item."""
  and: [FeedItemFilter!]

  """Filters that the feed item author must satisfy."""
  author: UserFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Compound filters, one of which need to be matched by the feed item."""
  or: [FeedItemFilter!]

  """Filters that the feed item's project update must satisfy."""
  projectUpdate: ProjectUpdateFilter

  """Filters that the related feed item initiatives must satisfy."""
  relatedInitiatives: InitiativeCollectionFilter

  """Filters that the related feed item team must satisfy."""
  relatedTeams: TeamCollectionFilter

  """
  Comparator for the project or initiative update health: onTrack, atRisk, offTrack
  """
  updateHealth: StringComparator

  """Comparator for the update type: initiative, project, team"""
  updateType: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Cadence to generate feed summary"""
enum FeedSummarySchedule {
  daily
  never
  weekly
}

type FetchDataPayload {
  """The fetched data based on the natural language query."""
  data: JSONObject

  """Whether the fetch operation was successful."""
  success: Boolean!
}

"""By which resolution is frequency defined."""
enum FrequencyResolutionType {
  daily
  weekly
}

type FrontAttachmentPayload {
  """The issue attachment that was created."""
  attachment: Attachment!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input FrontSettingsInput {
  """
  Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
  """
  automateTicketReopeningOnCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
  """
  automateTicketReopeningOnComment: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear issue is completed.
  """
  automateTicketReopeningOnCompletion: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is cancelled.
  """
  automateTicketReopeningOnProjectCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is completed.
  """
  automateTicketReopeningOnProjectCompletion: Boolean

  """
  [ALPHA] Whether customer and customer requests should not be automatically created when conversations are linked to a Linear issue.
  """
  disableCustomerRequestsAutoCreation: Boolean

  """
  Whether an internal message should be added when someone comments on an issue.
  """
  sendNoteOnComment: Boolean

  """
  Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
  """
  sendNoteOnStatusChange: Boolean
}

"""A trigger that updates the issue status according to Git automations."""
type GitAutomationState implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  [DEPRECATED] The target branch, if null, the automation will be triggered on any branch.
  """
  branchPattern: String @deprecated(reason: "Use targetBranch instead.")

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The event that triggers the automation."""
  event: GitAutomationStates!

  """The unique identifier of the entity."""
  id: ID!

  """The associated workflow state."""
  state: WorkflowState

  """The target branch associated to this automation state."""
  targetBranch: GitAutomationTargetBranch

  """The team to which this automation state belongs."""
  team: Team!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type GitAutomationStateConnection {
  edges: [GitAutomationStateEdge!]!
  nodes: [GitAutomationState!]!
  pageInfo: PageInfo!
}

input GitAutomationStateCreateInput {
  """
  [DEPRECATED] The target branch pattern. If null, all branches are targeted.
  """
  branchPattern: String @deprecated(reason: "Use targetBranchId instead.")

  """The event that triggers the automation."""
  event: GitAutomationStates!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """
  The associated workflow state. If null, will override default behaviour and take no action.
  """
  stateId: String

  """The associated target branch. If null, all branches are targeted."""
  targetBranchId: String

  """The team associated with the automation state."""
  teamId: String!
}

type GitAutomationStateEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: GitAutomationState!
}

type GitAutomationStatePayload {
  """The automation state that was created or updated."""
  gitAutomationState: GitAutomationState!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input GitAutomationStateUpdateInput {
  """
  [DEPRECATED] The target branch pattern. If null, all branches are targeted.
  """
  branchPattern: String @deprecated(reason: "Use targetBranchId instead.")

  """The event that triggers the automation."""
  event: GitAutomationStates

  """The associated workflow state."""
  stateId: String

  """The associated target branch. If null, all branches are targeted."""
  targetBranchId: String
}

"""The various states of a pull/merge request."""
enum GitAutomationStates {
  draft
  merge
  mergeable
  review
  start
}

"""
A Git target branch for which there are automations (GitAutomationState).
"""
type GitAutomationTargetBranch implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Automation states associated with the target branch."""
  automationStates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): GitAutomationStateConnection!

  """The target branch pattern."""
  branchPattern: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """Whether the branch pattern is a regular expression."""
  isRegex: Boolean!

  """The team to which this Git target branch automation belongs."""
  team: Team!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

input GitAutomationTargetBranchCreateInput {
  """The target branch pattern."""
  branchPattern: String!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """Whether the branch pattern is a regular expression."""
  isRegex: Boolean = false

  """The team associated with the Git target branch automation."""
  teamId: String!
}

type GitAutomationTargetBranchPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The Git target branch automation that was created or updated."""
  targetBranch: GitAutomationTargetBranch!
}

input GitAutomationTargetBranchUpdateInput {
  """The target branch pattern."""
  branchPattern: String

  """Whether the branch pattern is a regular expression."""
  isRegex: Boolean
}

type GitHubCommitIntegrationPayload {
  """The integration that was created or updated."""
  integration: Integration

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The webhook secret to provide to GitHub."""
  webhookSecret: String!
}

type GitHubEnterpriseServerInstallVerificationPayload {
  """Has the install been successful."""
  success: Boolean!
}

type GitHubEnterpriseServerPayload {
  """The app install address."""
  installUrl: String!

  """The integration that was created or updated."""
  integration: Integration

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The setup address."""
  setupUrl: String!

  """Whether the operation was successful."""
  success: Boolean!

  """The webhook secret to provide to GitHub."""
  webhookSecret: String!
}

input GitHubImportSettingsInput {
  """A map storing all available issue labels per repository"""
  labels: JSONObject

  """The avatar URL for the GitHub organization."""
  orgAvatarUrl: String!

  """The GitHub organization's name."""
  orgLogin: String!

  """The type of Github org"""
  orgType: GithubOrgType!

  """The names of the repositories connected for the GitHub integration."""
  repositories: [GitHubRepoInput!]!
}

input GitHubPersonalSettingsInput {
  """The GitHub user's name."""
  login: String!
}

input GitHubRepoInput {
  """Whether the repository is archived."""
  archived: Boolean

  """The full name of the repository."""
  fullName: String!

  """The GitHub repo id."""
  id: Float!
}

input GitHubRepoMappingInput {
  """Whether the sync for this mapping is bidirectional."""
  bidirectional: Boolean

  """Whether this mapping is the default one for issue creation."""
  default: Boolean

  """Labels to filter incoming GitHub issue creation by."""
  gitHubLabels: [String!]

  """The GitHub repo id."""
  gitHubRepoId: Float!

  """The unique identifier for this mapping."""
  id: String!

  """The Linear team id to map to the given project."""
  linearTeamId: String!
}

input GitHubSettingsInput {
  """Whether the integration has code access"""
  codeAccess: Boolean

  """The avatar URL for the GitHub organization."""
  orgAvatarUrl: String

  """The GitHub organization's name."""
  orgLogin: String!

  """The type of Github org"""
  orgType: GithubOrgType
  pullRequestReviewTool: PullRequestReviewTool

  """The names of the repositories connected for the GitHub integration."""
  repositories: [GitHubRepoInput!]

  """Mapping of team to repository for syncing."""
  repositoriesMapping: [GitHubRepoMappingInput!]
}

type GitLabIntegrationCreatePayload {
  """The integration that was created or updated."""
  integration: Integration

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The webhook secret to provide to GitLab."""
  webhookSecret: String!
}

input GitLabSettingsInput {
  """The ISO timestamp the GitLab access token expires."""
  expiresAt: String

  """Whether the token is limited to a read-only scope."""
  readonly: Boolean

  """The self-hosted URL of the GitLab instance."""
  url: String
}

"""[Internal] The kind of link between an issue and a pull request."""
enum GitLinkKind {
  closes
  contributes
  links
}

enum GithubOrgType {
  organization
  user
}

input GoogleSheetsExportSettings {
  """Whether the export is enabled."""
  enabled: Boolean

  """The ID of the target sheet (tab) within the Google Sheet."""
  sheetId: Float

  """The ID of the exported Google Sheet."""
  spreadsheetId: String

  """The URL of the exported Google Sheet."""
  spreadsheetUrl: String

  """The date of the most recent export."""
  updatedAt: DateTime
}

input GoogleSheetsSettingsInput {
  """The export settings for initiatives."""
  initiative: GoogleSheetsExportSettings

  """The export settings for issues."""
  issue: GoogleSheetsExportSettings

  """The export settings for projects."""
  project: GoogleSheetsExportSettings

  """[Deprecated] The ID of the target sheet (tab) within the Google Sheet."""
  sheetId: Float

  """[Deprecated] The ID of the exported Google Sheet."""
  spreadsheetId: String

  """[Deprecated] The URL of the exported Google Sheet."""
  spreadsheetUrl: String

  """[Deprecated] The date of the most recent export."""
  updatedIssuesAt: DateTime
}

input GoogleUserAccountAuthInput {
  """Code returned from Google's OAuth flow."""
  code: String!

  """
  An optional parameter to disable new user signup and force login. Default: false.
  """
  disallowSignup: Boolean

  """
  An optional invite link for an organization used to populate available organizations.
  """
  inviteLink: String

  """The URI to redirect the user to."""
  redirectUri: String

  """Signup code."""
  signupCode: String @deprecated(reason: "Not used anymore")

  """The identifiers of the teams to auto-join."""
  teamIdsToJoin: [String!] @deprecated(reason: "Not used anymore")

  """The timezone of the user's browser."""
  timezone: String!
}

"""Comparator for identifiers."""
input IDComparator {
  """Equals constraint."""
  eq: ID

  """In-array constraint."""
  in: [ID!]

  """Not-equals constraint."""
  neq: ID

  """Not-in-array constraint."""
  nin: [ID!]
}

"""An identity provider."""
type IdentityProvider implements Node {
  """[INTERNAL] SCIM admins group push settings."""
  adminsGroupPush: JSONObject

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  Whether the identity provider is the default identity provider migrated from organization level settings.
  """
  defaultMigrated: Boolean!

  """[INTERNAL] SCIM guests group push settings."""
  guestsGroupPush: JSONObject

  """The unique identifier of the entity."""
  id: ID!

  """The issuer's custom entity ID."""
  issuerEntityId: String

  """
  The SAML priority used to pick default workspace in SAML SP initiated flow, when same domain is claimed for SAML by multiple workspaces. Lower priority value means higher preference.
  """
  priority: Float

  """Whether SAML authentication is enabled for organization."""
  samlEnabled: Boolean!

  """Whether SCIM provisioning is enabled for organization."""
  scimEnabled: Boolean!

  """
  Binding method for authentication call. Can be either `post` (default) or `redirect`.
  """
  ssoBinding: String

  """Sign in endpoint URL for the identity provider."""
  ssoEndpoint: String

  """
  The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
  """
  ssoSignAlgo: String

  """X.509 Signing Certificate in string form."""
  ssoSigningCert: String

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type ImageUploadFromUrlPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The URL containing the image."""
  url: String
}

input InheritanceEntityMapping {
  """Mapping of the IssueLabel ID to the new IssueLabel name."""
  issueLabels: JSONObject

  """Mapping of the WorkflowState ID to the new WorkflowState ID."""
  workflowStates: JSONObject!
}

"""An initiative to group projects."""
type Initiative implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The initiative's color."""
  color: String

  """The time at which the initiative was moved into completed status."""
  completedAt: DateTime

  """The initiative's content in markdown format."""
  content: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the initiative."""
  creator: User

  """The description of the initiative."""
  description: String

  """The content of the initiative description."""
  documentContent: DocumentContent

  """Documents associated with the initiative."""
  documents(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned documents."""
    filter: DocumentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): DocumentConnection!

  """[Internal] Facets associated with the initiative."""
  facets: [Facet!]!

  """The resolution of the reminder frequency."""
  frequencyResolution: FrequencyResolutionType!

  """The health of the initiative."""
  health: InitiativeUpdateHealthType

  """The time at which the initiative health was updated."""
  healthUpdatedAt: DateTime

  """History entries associated with the initiative."""
  history(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): InitiativeHistoryConnection!

  """The icon of the initiative."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """Settings for all integrations associated with that initiative."""
  integrationsSettings: IntegrationsSettings

  """The last initiative update posted for this initiative."""
  lastUpdate: InitiativeUpdate

  """Links associated with the initiative."""
  links(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): EntityExternalLinkConnection!

  """The name of the initiative."""
  name: String!

  """The organization of the initiative."""
  organization: Organization!

  """The user who owns the initiative."""
  owner: User

  """Parent initiative associated with the initiative."""
  parentInitiative: Initiative

  """Projects associated with the initiative."""
  projects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned projects."""
    filter: ProjectFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Whether to include projects from sub-initiatives. Defaults to true."""
    includeSubInitiatives: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned projects."""
    sort: [ProjectSortInput!]
  ): ProjectConnection!

  """The initiative's unique URL slug."""
  slugId: String!

  """The sort order of the initiative within the organization."""
  sortOrder: Float!

  """The time at which the initiative was moved into active status."""
  startedAt: DateTime

  """The status of the initiative. One of Planned, Active, Completed"""
  status: InitiativeStatus!

  """Sub-initiatives associated with the initiative."""
  subInitiatives(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned sub-initiatives."""
    filter: InitiativeFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned initiatives."""
    sort: [InitiativeSortInput!]
  ): InitiativeConnection!

  """The estimated completion date of the initiative."""
  targetDate: TimelessDate

  """The resolution of the initiative's estimated completion date."""
  targetDateResolution: DateResolutionType

  """A flag that indicates whether the initiative is in the trash bin."""
  trashed: Boolean

  """
  The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequency: Float

  """
  The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequencyInWeeks: Float

  """The day at which to prompt for updates."""
  updateRemindersDay: Day

  """The hour at which to prompt for updates."""
  updateRemindersHour: Float

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Initiative URL."""
  url: String!
}

"""A generic payload return from entity archive mutations."""
type InitiativeArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Initiative

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Initiative collection filtering options."""
input InitiativeCollectionFilter {
  """Comparator for the initiative activity type."""
  activityType: StringComparator

  """Filters that the initiative must be an ancestor of."""
  ancestors: InitiativeCollectionFilter

  """Compound filters, all of which need to be matched by the initiative."""
  and: [InitiativeCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the initiative creator must satisfy."""
  creator: NullableUserFilter

  """Filters that needs to be matched by all initiatives."""
  every: InitiativeFilter

  """Comparator for the initiative health: onTrack, atRisk, offTrack"""
  health: StringComparator

  """
  Comparator for the initiative health (with age): onTrack, atRisk, offTrack, outdated, noUpdate
  """
  healthWithAge: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Comparator for the initiative name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the initiative."""
  or: [InitiativeCollectionFilter!]

  """Filters that the initiative owner must satisfy."""
  owner: NullableUserFilter

  """Comparator for the initiative slug ID."""
  slugId: StringComparator

  """Filters that needs to be matched by some initiatives."""
  some: InitiativeFilter

  """Comparator for the initiative status: Planned, Active, Completed"""
  status: StringComparator

  """Comparator for the initiative target date."""
  targetDate: NullableDateComparator

  """Filters that the initiative teams must satisfy."""
  teams: TeamCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type InitiativeConnection {
  edges: [InitiativeEdge!]!
  nodes: [Initiative!]!
  pageInfo: PageInfo!
}

"""The properties of the initiative to create."""
input InitiativeCreateInput {
  """The initiative's color."""
  color: String

  """The initiative's content in markdown format."""
  content: String

  """The description of the initiative."""
  description: String

  """The initiative's icon."""
  icon: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the initiative."""
  name: String!

  """The owner of the initiative."""
  ownerId: String

  """The sort order of the initiative within the organization."""
  sortOrder: Float

  """The initiative's status."""
  status: InitiativeStatus

  """The estimated completion date of the initiative."""
  targetDate: TimelessDate

  """The resolution of the initiative's estimated completion date."""
  targetDateResolution: DateResolutionType
}

"""Initiative creation date sorting options."""
input InitiativeCreatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

type InitiativeEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Initiative!
}

"""Initiative filtering options."""
input InitiativeFilter {
  """Comparator for the initiative activity type."""
  activityType: StringComparator

  """Filters that the initiative must be an ancestor of."""
  ancestors: InitiativeCollectionFilter

  """Compound filters, all of which need to be matched by the initiative."""
  and: [InitiativeFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the initiative creator must satisfy."""
  creator: NullableUserFilter

  """Comparator for the initiative health: onTrack, atRisk, offTrack"""
  health: StringComparator

  """
  Comparator for the initiative health (with age): onTrack, atRisk, offTrack, outdated, noUpdate
  """
  healthWithAge: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the initiative name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the initiative."""
  or: [InitiativeFilter!]

  """Filters that the initiative owner must satisfy."""
  owner: NullableUserFilter

  """Comparator for the initiative slug ID."""
  slugId: StringComparator

  """Comparator for the initiative status: Planned, Active, Completed"""
  status: StringComparator

  """Comparator for the initiative target date."""
  targetDate: NullableDateComparator

  """Filters that the initiative teams must satisfy."""
  teams: TeamCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Initiative health sorting options."""
input InitiativeHealthSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Initiative health update date sorting options."""
input InitiativeHealthUpdatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A initiative history containing relevant change events."""
type InitiativeHistory implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The events that happened while recording that history."""
  entries: JSONObject!

  """The unique identifier of the entity."""
  id: ID!

  """The initiative that the history is associated with."""
  initiative: Initiative!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type InitiativeHistoryConnection {
  edges: [InitiativeHistoryEdge!]!
  nodes: [InitiativeHistory!]!
  pageInfo: PageInfo!
}

type InitiativeHistoryEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: InitiativeHistory!
}

"""Initiative manual sorting options."""
input InitiativeManualSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Initiative name sorting options."""
input InitiativeNameSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""An initiative related notification."""
type InitiativeNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """The comment related to the notification."""
  comment: Comment

  """
  Related comment ID. Null if the notification is not related to a comment.
  """
  commentId: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The document related to the notification."""
  document: Document

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """The initiative related to the notification."""
  initiative: Initiative

  """Related initiative ID."""
  initiativeId: String!

  """The initiative update related to the notification."""
  initiativeUpdate: InitiativeUpdate

  """Related initiative update ID."""
  initiativeUpdateId: String

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """
  The parent comment related to the notification, if a notification is a reply comment notification.
  """
  parentComment: Comment

  """
  Related parent comment ID. Null if the notification is not related to a comment.
  """
  parentCommentId: String

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """Name of the reaction emoji related to the notification."""
  reactionEmoji: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

"""An initiative notification subscription."""
type InitiativeNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer associated with the notification subscription."""
  customer: Customer

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """The initiative subscribed to."""
  initiative: Initiative!

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

"""Initiative owner sorting options."""
input InitiativeOwnerSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""The payload returned by the initiative mutations."""
type InitiativePayload {
  """The initiative that was created or updated."""
  initiative: Initiative!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""A relation representing the dependency between two initiatives."""
type InitiativeRelation implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The parent initiative."""
  initiative: Initiative!

  """The child initiative."""
  relatedInitiative: Initiative!

  """The sort order of the relation within the initiative."""
  sortOrder: Float!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The last user who created or modified the relation."""
  user: User
}

type InitiativeRelationConnection {
  edges: [InitiativeRelationEdge!]!
  nodes: [InitiativeRelation!]!
  pageInfo: PageInfo!
}

input InitiativeRelationCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the parent initiative."""
  initiativeId: String!

  """The identifier of the child initiative."""
  relatedInitiativeId: String!

  """The sort order of the initiative relation."""
  sortOrder: Float
}

type InitiativeRelationEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: InitiativeRelation!
}

type InitiativeRelationPayload {
  """The initiative relation that was created or updated."""
  initiativeRelation: InitiativeRelation!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The properties of the initiativeRelation to update."""
input InitiativeRelationUpdateInput {
  """The sort order of the initiative relation."""
  sortOrder: Float
}

"""Initiative sorting options."""
input InitiativeSortInput {
  """Sort by initiative creation date."""
  createdAt: InitiativeCreatedAtSort

  """Sort by initiative health status."""
  health: InitiativeHealthSort

  """Sort by initiative health update date."""
  healthUpdatedAt: InitiativeHealthUpdatedAtSort

  """Sort by manual order."""
  manual: InitiativeManualSort

  """Sort by initiative name."""
  name: InitiativeNameSort

  """Sort by initiative owner name."""
  owner: InitiativeOwnerSort

  """Sort by initiative target date."""
  targetDate: InitiativeTargetDateSort

  """Sort by initiative update date."""
  updatedAt: InitiativeUpdatedAtSort
}

enum InitiativeStatus {
  Active
  Completed
  Planned
}

"""Different tabs available inside an initiative."""
enum InitiativeTab {
  overview
  projects
}

"""Initiative target date sorting options."""
input InitiativeTargetDateSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Join table between projects and initiatives."""
type InitiativeToProject implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The initiative that the project is associated with."""
  initiative: Initiative!

  """The project that the initiative is associated with."""
  project: Project!

  """The sort order of the project within the initiative."""
  sortOrder: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type InitiativeToProjectConnection {
  edges: [InitiativeToProjectEdge!]!
  nodes: [InitiativeToProject!]!
  pageInfo: PageInfo!
}

"""The properties of the initiativeToProject to create."""
input InitiativeToProjectCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the initiative."""
  initiativeId: String!

  """The identifier of the project."""
  projectId: String!

  """The sort order for the project within its organization."""
  sortOrder: Float
}

type InitiativeToProjectEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: InitiativeToProject!
}

"""The result of a initiativeToProject mutation."""
type InitiativeToProjectPayload {
  """The initiativeToProject that was created or updated."""
  initiativeToProject: InitiativeToProject!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The properties of the initiativeToProject to update."""
input InitiativeToProjectUpdateInput {
  """The sort order for the project within its organization."""
  sortOrder: Float
}

"""An initiative update."""
type InitiativeUpdate implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The update content in markdown format."""
  body: String!

  """[Internal] The content of the update as a Prosemirror document."""
  bodyData: String!

  """Comments associated with the initiative update."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The diff between the current update and the previous one."""
  diff: JSONObject

  """
  The diff between the current update and the previous one, formatted as markdown.
  """
  diffMarkdown: String

  """The time the update was edited."""
  editedAt: DateTime

  """The health at the time of the update."""
  health: InitiativeUpdateHealthType!

  """The unique identifier of the entity."""
  id: ID!

  """
  [Internal] Serialized JSON representing current state of the initiative properties when posting the initiative update.
  """
  infoSnapshot: JSONObject

  """The initiative that the update is associated with."""
  initiative: Initiative!

  """Whether initiative update diff should be hidden."""
  isDiffHidden: Boolean!

  """Whether the initiative update is stale."""
  isStale: Boolean!

  """Emoji reaction summary, grouped by emoji type."""
  reactionData: JSONObject!

  """Reactions associated with the initiative update."""
  reactions: [Reaction!]!

  """The update's unique URL slug."""
  slugId: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The URL to the initiative update."""
  url: String!

  """The user who wrote the update."""
  user: User!
}

"""A generic payload return from entity archive mutations."""
type InitiativeUpdateArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: InitiativeUpdate

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type InitiativeUpdateConnection {
  edges: [InitiativeUpdateEdge!]!
  nodes: [InitiativeUpdate!]!
  pageInfo: PageInfo!
}

input InitiativeUpdateCreateInput {
  """The content of the update in markdown format."""
  body: String

  """[Internal] The content of the update as a Prosemirror document."""
  bodyData: JSON

  """The health of the initiative at the time of the update."""
  health: InitiativeUpdateHealthType

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The initiative to associate the update with."""
  initiativeId: String!

  """
  Whether the diff between the current update and the previous one should be hidden.
  """
  isDiffHidden: Boolean
}

type InitiativeUpdateEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: InitiativeUpdate!
}

"""Options for filtering initiative updates."""
input InitiativeUpdateFilter {
  """
  Compound filters, all of which need to be matched by the InitiativeUpdate.
  """
  and: [InitiativeUpdateFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the initiative update initiative must satisfy."""
  initiative: InitiativeFilter

  """
  Compound filters, one of which need to be matched by the InitiativeUpdate.
  """
  or: [InitiativeUpdateFilter!]

  """Filters that the initiative updates reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Filters that the initiative update creator must satisfy."""
  user: UserFilter
}

"""The health type when the update is created."""
enum InitiativeUpdateHealthType {
  atRisk
  offTrack
  onTrack
}

"""The properties of the initiative to update."""
input InitiativeUpdateInput {
  """The initiative's color."""
  color: String

  """The initiative's content in markdown format."""
  content: String

  """The description of the initiative."""
  description: String

  """The frequency resolution."""
  frequencyResolution: FrequencyResolutionType

  """The initiative's icon."""
  icon: String

  """The name of the initiative."""
  name: String

  """The owner of the initiative."""
  ownerId: String

  """The sort order of the initiative within the organization."""
  sortOrder: Float

  """The initiative's status."""
  status: InitiativeStatus

  """The estimated completion date of the initiative."""
  targetDate: TimelessDate

  """The resolution of the initiative's estimated completion date."""
  targetDateResolution: DateResolutionType

  """Whether the initiative has been trashed."""
  trashed: Boolean

  """
  The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequency: Float

  """
  The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequencyInWeeks: Float

  """The day at which to prompt for updates."""
  updateRemindersDay: Day

  """The hour at which to prompt for updates."""
  updateRemindersHour: Int
}

type InitiativeUpdatePayload {
  """The initiative update that was created."""
  initiativeUpdate: InitiativeUpdate!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type InitiativeUpdateReminderPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input InitiativeUpdateUpdateInput {
  """The content of the update in markdown format."""
  body: String

  """The content of the update as a Prosemirror document."""
  bodyData: JSON

  """The health of the initiative at the time of the update."""
  health: InitiativeUpdateHealthType

  """
  Whether the diff between the current update and the previous one should be hidden.
  """
  isDiffHidden: Boolean
}

"""Initiative update date sorting options."""
input InitiativeUpdatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""An integration with an external service."""
type Integration implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user that added the integration."""
  creator: User!

  """The unique identifier of the entity."""
  id: ID!

  """The organization that the integration is associated with."""
  organization: Organization!

  """The integration's type."""
  service: String!

  """The team that the integration is associated with."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type IntegrationConnection {
  edges: [IntegrationEdge!]!
  nodes: [Integration!]!
  pageInfo: PageInfo!
}

input IntegrationCustomerDataAttributesRefreshInput {
  """The integration service to refresh customer data attributes from."""
  service: String!
}

type IntegrationEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Integration!
}

type IntegrationHasScopesPayload {
  """Whether the integration has the required scopes."""
  hasAllScopes: Boolean!

  """The missing scopes."""
  missingScopes: [String!]
}

type IntegrationPayload {
  """The integration that was created or updated."""
  integration: Integration

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input IntegrationRequestInput {
  """Email associated with the request."""
  email: String

  """Name of the requested integration."""
  name: String!
}

type IntegrationRequestPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""Linear supported integration services."""
enum IntegrationService {
  airbyte
  discord
  email
  figma
  figmaPlugin
  front
  github
  githubCodeAccessPersonal
  githubCommit
  githubEnterpriseServer
  githubImport
  githubPersonal
  gitlab
  googleCalendarPersonal
  googleSheets
  intercom
  jira
  jiraPersonal
  launchDarkly
  launchDarklyPersonal
  loom
  notion
  opsgenie
  pagerDuty
  salesforce
  sentry
  slack
  slackAsks
  slackCustomViewNotifications
  slackInitiativePost
  slackOrgInitiativeUpdatesPost
  slackOrgProjectUpdatesPost
  slackPersonal
  slackPost
  slackProjectPost
  slackProjectUpdatesPost
  zendesk
}

input IntegrationSettingsInput {
  front: FrontSettingsInput
  gitHub: GitHubSettingsInput
  gitHubImport: GitHubImportSettingsInput
  gitHubPersonal: GitHubPersonalSettingsInput
  gitLab: GitLabSettingsInput
  googleSheets: GoogleSheetsSettingsInput
  intercom: IntercomSettingsInput
  jira: JiraSettingsInput
  jiraPersonal: JiraPersonalSettingsInput
  launchDarkly: LaunchDarklySettingsInput
  notion: NotionSettingsInput
  opsgenie: OpsgenieInput
  pagerDuty: PagerDutyInput
  salesforce: SalesforceSettingsInput
  sentry: SentrySettingsInput
  slack: SlackSettingsInput
  slackAsks: SlackAsksSettingsInput
  slackCustomViewNotifications: SlackPostSettingsInput
  slackInitiativePost: SlackPostSettingsInput
  slackOrgInitiativeUpdatesPost: SlackPostSettingsInput
  slackOrgProjectUpdatesPost: SlackPostSettingsInput
  slackPost: SlackPostSettingsInput
  slackProjectPost: SlackPostSettingsInput
  zendesk: ZendeskSettingsInput
}

"""Join table between templates and integrations."""
type IntegrationTemplate implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  ID of the foreign entity in the external integration this template is for, e.g., Slack channel ID.
  """
  foreignEntityId: String

  """The unique identifier of the entity."""
  id: ID!

  """The integration that the template is associated with."""
  integration: Integration!

  """The template that the integration is associated with."""
  template: Template!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type IntegrationTemplateConnection {
  edges: [IntegrationTemplateEdge!]!
  nodes: [IntegrationTemplate!]!
  pageInfo: PageInfo!
}

input IntegrationTemplateCreateInput {
  """The foreign identifier in the other service."""
  foreignEntityId: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the integration."""
  integrationId: String!

  """The identifier of the template."""
  templateId: String!
}

type IntegrationTemplateEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: IntegrationTemplate!
}

type IntegrationTemplatePayload {
  """The IntegrationTemplate that was created or updated."""
  integrationTemplate: IntegrationTemplate!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input IntegrationUpdateInput {
  """The settings to update."""
  settings: IntegrationSettingsInput
}

"""The configuration of all integrations for different entities."""
type IntegrationsSettings implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the integration settings context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """Initiative which those settings apply to."""
  initiative: Initiative

  """Project which those settings apply to."""
  project: Project

  """Whether to send a Slack message when a initiate update is created."""
  slackInitiativeUpdateCreated: Boolean

  """Whether to send a Slack message when a new issue is added to triage."""
  slackIssueAddedToTriage: Boolean

  """
  Whether to send a Slack message when an issue is added to the custom view.
  """
  slackIssueAddedToView: Boolean

  """
  Whether to send a Slack message when a new issue is created for the project or the team.
  """
  slackIssueCreated: Boolean @deprecated(reason: "No longer in use. Use `slackIssueAddedToView` instead.")

  """
  Whether to send a Slack message when a comment is created on any of the project or team's issues.
  """
  slackIssueNewComment: Boolean

  """Whether to send a Slack message when an SLA is breached."""
  slackIssueSlaBreached: Boolean

  """Whether to send a Slack message when an SLA is at high risk."""
  slackIssueSlaHighRisk: Boolean

  """
  Whether to send a Slack message when any of the project or team's issues has a change in status.
  """
  slackIssueStatusChangedAll: Boolean

  """
  Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
  """
  slackIssueStatusChangedDone: Boolean

  """Whether to send a Slack message when a project update is created."""
  slackProjectUpdateCreated: Boolean

  """Whether to send a new project update to team Slack channels."""
  slackProjectUpdateCreatedToTeam: Boolean

  """Whether to send a new project update to workspace Slack channel."""
  slackProjectUpdateCreatedToWorkspace: Boolean

  """Team which those settings apply to."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

input IntegrationsSettingsCreateInput {
  """
  The type of view to which the integration settings context is associated with.
  """
  contextViewType: ContextViewType

  """The identifier of the custom view to create settings for."""
  customViewId: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the initiative to create settings for."""
  initiativeId: String

  """The identifier of the project to create settings for."""
  projectId: String

  """Whether to send a Slack message when an initiative update is created."""
  slackInitiativeUpdateCreated: Boolean

  """Whether to send a Slack message when a new issue is added to triage."""
  slackIssueAddedToTriage: Boolean

  """Whether to send a Slack message when an issue is added to a view."""
  slackIssueAddedToView: Boolean

  """
  Whether to send a Slack message when a new issue is created for the project or the team.
  """
  slackIssueCreated: Boolean

  """
  Whether to send a Slack message when a comment is created on any of the project or team's issues.
  """
  slackIssueNewComment: Boolean

  """Whether to receive notification when an SLA has breached on Slack."""
  slackIssueSlaBreached: Boolean

  """Whether to send a Slack message when an SLA is at high risk."""
  slackIssueSlaHighRisk: Boolean

  """
  Whether to send a Slack message when any of the project or team's issues has a change in status.
  """
  slackIssueStatusChangedAll: Boolean

  """
  Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
  """
  slackIssueStatusChangedDone: Boolean

  """Whether to send a Slack message when a project update is created."""
  slackProjectUpdateCreated: Boolean

  """
  Whether to send a Slack message when a project update is created to team channels.
  """
  slackProjectUpdateCreatedToTeam: Boolean

  """
  Whether to send a Slack message when a project update is created to workspace channel.
  """
  slackProjectUpdateCreatedToWorkspace: Boolean

  """The identifier of the team to create settings for."""
  teamId: String
}

type IntegrationsSettingsPayload {
  """The settings that were created or updated."""
  integrationsSettings: IntegrationsSettings!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input IntegrationsSettingsUpdateInput {
  """Whether to send a Slack message when an initiative update is created."""
  slackInitiativeUpdateCreated: Boolean

  """Whether to send a Slack message when a new issue is added to triage."""
  slackIssueAddedToTriage: Boolean

  """Whether to send a Slack message when an issue is added to a view."""
  slackIssueAddedToView: Boolean

  """
  Whether to send a Slack message when a new issue is created for the project or the team.
  """
  slackIssueCreated: Boolean

  """
  Whether to send a Slack message when a comment is created on any of the project or team's issues.
  """
  slackIssueNewComment: Boolean

  """Whether to receive notification when an SLA has breached on Slack."""
  slackIssueSlaBreached: Boolean

  """Whether to send a Slack message when an SLA is at high risk."""
  slackIssueSlaHighRisk: Boolean

  """
  Whether to send a Slack message when any of the project or team's issues has a change in status.
  """
  slackIssueStatusChangedAll: Boolean

  """
  Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
  """
  slackIssueStatusChangedDone: Boolean

  """Whether to send a Slack message when a project update is created."""
  slackProjectUpdateCreated: Boolean

  """
  Whether to send a Slack message when a project update is created to team channels.
  """
  slackProjectUpdateCreatedToTeam: Boolean

  """
  Whether to send a Slack message when a project update is created to workspace channel.
  """
  slackProjectUpdateCreatedToWorkspace: Boolean
}

input IntercomSettingsInput {
  """
  Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
  """
  automateTicketReopeningOnCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
  """
  automateTicketReopeningOnComment: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear issue is completed.
  """
  automateTicketReopeningOnCompletion: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is cancelled.
  """
  automateTicketReopeningOnProjectCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is completed.
  """
  automateTicketReopeningOnProjectCompletion: Boolean

  """
  [ALPHA] Whether customer and customer requests should not be automatically created when conversations are linked to a Linear issue.
  """
  disableCustomerRequestsAutoCreation: Boolean

  """
  Whether an internal message should be added when someone comments on an issue.
  """
  sendNoteOnComment: Boolean

  """
  Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
  """
  sendNoteOnStatusChange: Boolean
}

"""An issue."""
type Issue implements Node {
  """[Internal] The activity summary information for this issue."""
  activitySummary: JSONObject

  """The time at which the issue was added to a cycle."""
  addedToCycleAt: DateTime

  """The time at which the issue was added to a project."""
  addedToProjectAt: DateTime

  """The time at which the issue was added to a team."""
  addedToTeamAt: DateTime

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The user to whom the issue is assigned to."""
  assignee: User

  """Attachments associated with the issue."""
  attachments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned attachments."""
    filter: AttachmentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AttachmentConnection!

  """
  The time at which the issue was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """
  The time at which the issue was automatically closed by the auto pruning process.
  """
  autoClosedAt: DateTime

  """The order of the item in its column on the board."""
  boardOrder: Float! @deprecated(reason: "Will be removed in near future, please use `sortOrder` instead")

  """The bot that created the issue, if applicable."""
  botActor: ActorBot

  """Suggested branch name for the issue."""
  branchName: String!

  """The time at which the issue was moved into canceled state."""
  canceledAt: DateTime

  """Children of the issue."""
  children(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Comments associated with the issue."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The time at which the issue was moved into completed state."""
  completedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the issue."""
  creator: User

  """
  Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
  """
  customerTicketCount: Int!

  """The cycle that the issue is associated with."""
  cycle: Cycle

  """The agent user that is delegated to work on this issue."""
  delegate: User

  """The issue's description in markdown format."""
  description: String

  """[Internal] The issue's description content as YJS state."""
  descriptionState: String

  """[ALPHA] The document content representing this issue description."""
  documentContent: DocumentContent

  """The date at which the issue is due."""
  dueDate: TimelessDate

  """The estimate of the complexity of the issue.."""
  estimate: Float

  """The external user who created the issue."""
  externalUserCreator: ExternalUser

  """The users favorite associated with this issue."""
  favorite: Favorite

  """
  Attachments previously associated with the issue before being moved to another issue.
  """
  formerAttachments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned attachments."""
    filter: AttachmentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AttachmentConnection!

  """
  Customer needs previously associated with the issue before being moved to another issue.
  """
  formerNeeds(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned needs."""
    filter: CustomerNeedFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerNeedConnection!

  """History entries associated with the issue."""
  history(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueHistoryConnection!

  """The unique identifier of the entity."""
  id: ID!

  """Issue's human readable identifier (e.g. ENG-123)."""
  identifier: String!

  """
  [Internal] Incoming product intelligence relation suggestions for the issue.
  """
  incomingSuggestions(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueSuggestionConnection!

  """Integration type that created this issue, if applicable."""
  integrationSourceType: IntegrationService

  """Inverse relations associated with this issue."""
  inverseRelations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """Id of the labels associated with this issue."""
  labelIds: [String!]!

  """Labels associated with this issue."""
  labels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issue labels."""
    filter: IssueLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """The last template that was applied to this issue."""
  lastAppliedTemplate: Template

  """Customer needs associated with the issue."""
  needs(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned needs."""
    filter: CustomerNeedFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerNeedConnection!

  """The issue's unique number."""
  number: Float!

  """The parent of the issue."""
  parent: Issue

  """Previous identifiers of the issue if it has been moved between teams."""
  previousIdentifiers: [String!]!

  """
  The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Float!

  """Label for the priority."""
  priorityLabel: String!

  """
  The order of the item in relation to other items in the organization, when ordered by priority.
  """
  prioritySortOrder: Float!

  """The project that the issue is associated with."""
  project: Project

  """The projectMilestone that the issue is associated with."""
  projectMilestone: ProjectMilestone

  """Emoji reaction summary, grouped by emoji type."""
  reactionData: JSONObject!

  """Reactions associated with the issue."""
  reactions: [Reaction!]!

  """The recurring issue template that created this issue."""
  recurringIssueTemplate: Template

  """Relations associated with this issue."""
  relations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """The time at which the issue's SLA will breach."""
  slaBreachesAt: DateTime

  """The time at which the issue's SLA will enter high risk state."""
  slaHighRiskAt: DateTime

  """The time at which the issue's SLA will enter medium risk state."""
  slaMediumRiskAt: DateTime

  """The time at which the issue's SLA began."""
  slaStartedAt: DateTime

  """The type of SLA set on the issue. Calendar days or business days."""
  slaType: String

  """The user who snoozed the issue."""
  snoozedBy: User

  """The time until an issue will be snoozed in Triage view."""
  snoozedUntilAt: DateTime

  """The order of the item in relation to other items in the organization."""
  sortOrder: Float!

  """The comment that this issue was created from."""
  sourceComment: Comment

  """The time at which the issue was moved into started state."""
  startedAt: DateTime

  """The time at which the issue entered triage."""
  startedTriageAt: DateTime

  """The workflow state that the issue is associated with."""
  state: WorkflowState!

  """
  The order of the item in the sub-issue list. Only set if the issue has a parent.
  """
  subIssueSortOrder: Float

  """Users who are subscribed to the issue."""
  subscribers(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned subscribers."""
    filter: UserFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """[Internal] Product intelligence suggestions for the issue."""
  suggestions(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueSuggestionConnection!

  """
  [Internal] The time at which the most recent suggestions for this issue were generated.
  """
  suggestionsGeneratedAt: DateTime

  """
  [DEPRECATED] [Internal] The user who has delegated this issue to be completed by an agent.
  """
  supervisor: User

  """The external services the issue is synced with."""
  syncedWith: [ExternalEntityInfo!]

  """The team that the issue is associated with."""
  team: Team!

  """The issue's title."""
  title: String!

  """A flag that indicates whether the issue is in the trash bin."""
  trashed: Boolean

  """The time at which the issue left triage."""
  triagedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Issue URL."""
  url: String!
}

"""A generic payload return from entity archive mutations."""
type IssueArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Issue

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input IssueBatchCreateInput {
  """The issues to create."""
  issues: [IssueCreateInput!]!
}

type IssueBatchPayload {
  """The issues that were updated."""
  issues: [Issue!]!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Issue filtering options."""
input IssueCollectionFilter {
  """Comparator for the issues added to cycle at date."""
  addedToCycleAt: NullableDateComparator

  """Comparator for the period when issue was added to a cycle."""
  addedToCyclePeriod: CyclePeriodComparator

  """
  [Internal] Age (created -> now) comparator, defined if the issue is still open.
  """
  ageTime: NullableDurationComparator

  """Compound filters, all of which need to be matched by the issue."""
  and: [IssueCollectionFilter!]

  """Comparator for the issues archived at date."""
  archivedAt: NullableDateComparator

  """Filters that the issues assignee must satisfy."""
  assignee: NullableUserFilter

  """Filters that the issues attachments must satisfy."""
  attachments: AttachmentCollectionFilter

  """Comparator for the issues auto archived at date."""
  autoArchivedAt: NullableDateComparator

  """Comparator for the issues auto closed at date."""
  autoClosedAt: NullableDateComparator

  """Comparator for the issues canceled at date."""
  canceledAt: NullableDateComparator

  """Filters that the child issues must satisfy."""
  children: IssueCollectionFilter

  """Filters that the issues comments must satisfy."""
  comments: CommentCollectionFilter

  """Comparator for the issues completed at date."""
  completedAt: NullableDateComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the issues creator must satisfy."""
  creator: NullableUserFilter

  """Count of customers"""
  customerCount: NumberComparator

  """Count of important customers"""
  customerImportantCount: NumberComparator

  """Filters that the issues cycle must satisfy."""
  cycle: NullableCycleFilter

  """[Internal] Cycle time (started -> completed) comparator."""
  cycleTime: NullableDurationComparator

  """Filters that the issue's delegated agent must satisfy."""
  delegate: NullableUserFilter

  """Comparator for the issues description."""
  description: NullableStringComparator

  """Comparator for the issues due date."""
  dueDate: NullableTimelessDateComparator

  """Comparator for the issues estimate."""
  estimate: EstimateComparator

  """Filters that needs to be matched by all issues."""
  every: IssueFilter

  """Comparator for filtering issues which are blocked."""
  hasBlockedByRelations: RelationExistsComparator

  """Comparator for filtering issues which are blocking."""
  hasBlockingRelations: RelationExistsComparator

  """Comparator for filtering issues which are duplicates."""
  hasDuplicateRelations: RelationExistsComparator

  """Comparator for filtering issues with relations."""
  hasRelatedRelations: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested assignees.
  """
  hasSuggestedAssignees: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested labels.
  """
  hasSuggestedLabels: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested projects.
  """
  hasSuggestedProjects: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested related issues.
  """
  hasSuggestedRelatedIssues: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested similar issues.
  """
  hasSuggestedSimilarIssues: RelationExistsComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that issue labels must satisfy."""
  labels: IssueLabelCollectionFilter

  """Filters that the last applied template must satisfy."""
  lastAppliedTemplate: NullableTemplateFilter

  """[Internal] Lead time (created -> completed) comparator."""
  leadTime: NullableDurationComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Filters that the issue's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Comparator for the issues number."""
  number: NumberComparator

  """Compound filters, one of which need to be matched by the issue."""
  or: [IssueCollectionFilter!]

  """Filters that the issue parent must satisfy."""
  parent: NullableIssueFilter

  """Comparator for the issues priority."""
  priority: NullableNumberComparator

  """Filters that the issues project must satisfy."""
  project: NullableProjectFilter

  """Filters that the issues project milestone must satisfy."""
  projectMilestone: NullableProjectMilestoneFilter

  """Filters that the issues reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """[ALPHA] Filters that the recurring issue template must satisfy."""
  recurringIssueTemplate: NullableTemplateFilter

  """[Internal] Comparator for the issues content."""
  searchableContent: ContentComparator

  """Comparator for the issues sla status."""
  slaStatus: SlaStatusComparator

  """Filters that the issues snoozer must satisfy."""
  snoozedBy: NullableUserFilter

  """Comparator for the issues snoozed until date."""
  snoozedUntilAt: NullableDateComparator

  """Filters that needs to be matched by some issues."""
  some: IssueFilter

  """Filters that the source must satisfy."""
  sourceMetadata: SourceMetadataComparator

  """Comparator for the issues started at date."""
  startedAt: NullableDateComparator

  """Filters that the issues state must satisfy."""
  state: WorkflowStateFilter

  """Filters that issue subscribers must satisfy."""
  subscribers: UserCollectionFilter

  """Filters that the issues team must satisfy."""
  team: TeamFilter

  """Comparator for the issues title."""
  title: StringComparator

  """[Internal] Triage time (entered triaged -> triaged) comparator."""
  triageTime: NullableDurationComparator

  """Comparator for the issues triaged at date."""
  triagedAt: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type IssueConnection {
  edges: [IssueEdge!]!
  nodes: [Issue!]!
  pageInfo: PageInfo!
}

input IssueCreateInput {
  """The identifier of the user to assign the issue to."""
  assigneeId: String

  """The position of the issue in its column on the board view."""
  boardOrder: Float @deprecated(reason: "Will be removed in near future, please use `sortOrder` instead")

  """
  The date when the issue was completed (e.g. if importing from another system). Must be a date in the past and after createdAt date. Cannot be provided with an incompatible workflow state.
  """
  completedAt: DateTime

  """
  Create issue as a user with the provided name. This option is only available to OAuth applications creating issues in `actor=app` mode.
  """
  createAsUser: String

  """
  The date when the issue was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now.
  """
  createdAt: DateTime

  """The cycle associated with the issue."""
  cycleId: String

  """The identifier of the agent user to delegate the issue to."""
  delegateId: String

  """The issue description in markdown format."""
  description: String

  """[Internal] The issue description as a Prosemirror document."""
  descriptionData: JSON

  """
  Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
  """
  displayIconUrl: String

  """The date at which the issue is due."""
  dueDate: TimelessDate

  """The estimated complexity of the issue."""
  estimate: Int

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifiers of the issue labels associated with this ticket."""
  labelIds: [String!]

  """The ID of the last template applied to the issue."""
  lastAppliedTemplateId: String

  """The identifier of the parent issue."""
  parentId: String

  """Whether the passed sort order should be preserved."""
  preserveSortOrderOnCreate: Boolean

  """
  The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Int

  """
  The position of the issue related to other issues, when ordered by priority.
  """
  prioritySortOrder: Float

  """The project associated with the issue."""
  projectId: String

  """The project milestone associated with the issue."""
  projectMilestoneId: String

  """The comment the issue is referencing."""
  referenceCommentId: String

  """
  [Internal] The timestamp at which an issue will be considered in breach of SLA.
  """
  slaBreachesAt: DateTime

  """[Internal] The timestamp at which the issue's SLA was started."""
  slaStartedAt: DateTime

  """
  The SLA day count type for the issue. Whether SLA should be business days only or calendar days (default).
  """
  slaType: SLADayCountType

  """The position of the issue related to other issues."""
  sortOrder: Float

  """The comment the issue is created from."""
  sourceCommentId: String

  """[Internal] The pull request comment the issue is created from."""
  sourcePullRequestCommentId: String

  """The team state of the issue."""
  stateId: String

  """The position of the issue in parent's sub-issue list."""
  subIssueSortOrder: Float

  """The identifiers of the users subscribing to this ticket."""
  subscriberIds: [String!]

  """The identifier of the team associated with the issue."""
  teamId: String!

  """
  The identifier of a template the issue should be created from. If other values are provided in the input, they will override template values.
  """
  templateId: String

  """The title of the issue."""
  title: String

  """
  Whether to use the default template for the team. When set to true, the default template of this team based on user's membership will be applied.
  """
  useDefaultTemplate: Boolean
}

"""[Internal] A draft issue."""
type IssueDraft implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The user assigned to the draft."""
  assigneeId: String

  """Serialized array of JSONs representing attachments."""
  attachments: JSONObject

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the draft."""
  creator: User!

  """The cycle associated with the draft."""
  cycleId: String

  """The agent user delegated to work on the issue being drafted."""
  delegateId: String

  """The draft's description in markdown format."""
  description: String

  """[Internal] The draft's description as a Prosemirror document."""
  descriptionData: JSON

  """The date at which the issue would be due."""
  dueDate: TimelessDate

  """The estimate of the complexity of the draft."""
  estimate: Float

  """The unique identifier of the entity."""
  id: ID!

  """The IDs of labels added to the draft."""
  labelIds: [String!]!

  """Serialized array of JSONs representing customer needs."""
  needs: JSONObject

  """The parent draft of the draft."""
  parent: IssueDraft

  """The ID of the parent issue draft, if any."""
  parentId: String

  """The parent issue of the draft."""
  parentIssue: Issue

  """The ID of the parent issue, if any."""
  parentIssueId: String

  """The priority of the draft."""
  priority: Float!

  """Label for the priority."""
  priorityLabel: String!

  """The project associated with the draft."""
  projectId: String

  """The project milestone associated with the draft."""
  projectMilestoneId: String

  """Serialized array of JSONs representing the recurring issue's schedule."""
  schedule: JSONObject

  """The ID of the comment that the draft was created from."""
  sourceCommentId: String

  """The workflow state associated with the draft."""
  stateId: String!

  """
  The order of items in the sub-draft list. Only set if the draft has `parent` set.
  """
  subIssueSortOrder: Float

  """The team associated with the draft."""
  teamId: String!

  """The draft's title."""
  title: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type IssueDraftConnection {
  edges: [IssueDraftEdge!]!
  nodes: [IssueDraft!]!
  pageInfo: PageInfo!
}

type IssueDraftEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: IssueDraft!
}

type IssueEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Issue!
}

"""Issue filtering options."""
input IssueFilter {
  """Comparator for the issues added to cycle at date."""
  addedToCycleAt: NullableDateComparator

  """Comparator for the period when issue was added to a cycle."""
  addedToCyclePeriod: CyclePeriodComparator

  """
  [Internal] Age (created -> now) comparator, defined if the issue is still open.
  """
  ageTime: NullableDurationComparator

  """Compound filters, all of which need to be matched by the issue."""
  and: [IssueFilter!]

  """Comparator for the issues archived at date."""
  archivedAt: NullableDateComparator

  """Filters that the issues assignee must satisfy."""
  assignee: NullableUserFilter

  """Filters that the issues attachments must satisfy."""
  attachments: AttachmentCollectionFilter

  """Comparator for the issues auto archived at date."""
  autoArchivedAt: NullableDateComparator

  """Comparator for the issues auto closed at date."""
  autoClosedAt: NullableDateComparator

  """Comparator for the issues canceled at date."""
  canceledAt: NullableDateComparator

  """Filters that the child issues must satisfy."""
  children: IssueCollectionFilter

  """Filters that the issues comments must satisfy."""
  comments: CommentCollectionFilter

  """Comparator for the issues completed at date."""
  completedAt: NullableDateComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the issues creator must satisfy."""
  creator: NullableUserFilter

  """Count of customers"""
  customerCount: NumberComparator

  """Count of important customers"""
  customerImportantCount: NumberComparator

  """Filters that the issues cycle must satisfy."""
  cycle: NullableCycleFilter

  """[Internal] Cycle time (started -> completed) comparator."""
  cycleTime: NullableDurationComparator

  """Filters that the issue's delegated agent must satisfy."""
  delegate: NullableUserFilter

  """Comparator for the issues description."""
  description: NullableStringComparator

  """Comparator for the issues due date."""
  dueDate: NullableTimelessDateComparator

  """Comparator for the issues estimate."""
  estimate: EstimateComparator

  """Comparator for filtering issues which are blocked."""
  hasBlockedByRelations: RelationExistsComparator

  """Comparator for filtering issues which are blocking."""
  hasBlockingRelations: RelationExistsComparator

  """Comparator for filtering issues which are duplicates."""
  hasDuplicateRelations: RelationExistsComparator

  """Comparator for filtering issues with relations."""
  hasRelatedRelations: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested assignees.
  """
  hasSuggestedAssignees: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested labels.
  """
  hasSuggestedLabels: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested projects.
  """
  hasSuggestedProjects: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested related issues.
  """
  hasSuggestedRelatedIssues: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested similar issues.
  """
  hasSuggestedSimilarIssues: RelationExistsComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that issue labels must satisfy."""
  labels: IssueLabelCollectionFilter

  """Filters that the last applied template must satisfy."""
  lastAppliedTemplate: NullableTemplateFilter

  """[Internal] Lead time (created -> completed) comparator."""
  leadTime: NullableDurationComparator

  """Filters that the issue's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Comparator for the issues number."""
  number: NumberComparator

  """Compound filters, one of which need to be matched by the issue."""
  or: [IssueFilter!]

  """Filters that the issue parent must satisfy."""
  parent: NullableIssueFilter

  """Comparator for the issues priority."""
  priority: NullableNumberComparator

  """Filters that the issues project must satisfy."""
  project: NullableProjectFilter

  """Filters that the issues project milestone must satisfy."""
  projectMilestone: NullableProjectMilestoneFilter

  """Filters that the issues reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """[ALPHA] Filters that the recurring issue template must satisfy."""
  recurringIssueTemplate: NullableTemplateFilter

  """[Internal] Comparator for the issues content."""
  searchableContent: ContentComparator

  """Comparator for the issues sla status."""
  slaStatus: SlaStatusComparator

  """Filters that the issues snoozer must satisfy."""
  snoozedBy: NullableUserFilter

  """Comparator for the issues snoozed until date."""
  snoozedUntilAt: NullableDateComparator

  """Filters that the source must satisfy."""
  sourceMetadata: SourceMetadataComparator

  """Comparator for the issues started at date."""
  startedAt: NullableDateComparator

  """Filters that the issues state must satisfy."""
  state: WorkflowStateFilter

  """Filters that issue subscribers must satisfy."""
  subscribers: UserCollectionFilter

  """Filters that the issues team must satisfy."""
  team: TeamFilter

  """Comparator for the issues title."""
  title: StringComparator

  """[Internal] Triage time (entered triaged -> triaged) comparator."""
  triageTime: NullableDurationComparator

  """Comparator for the issues triaged at date."""
  triagedAt: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type IssueFilterSuggestionPayload {
  """The json filter that is suggested."""
  filter: JSONObject

  """The log id of the prompt, that created this filter."""
  logId: String
}

"""A record of changes to an issue."""
type IssueHistory implements Node {
  """
  The actor that performed the actions. This field may be empty in the case of integrations or automations.
  """
  actor: User

  """
  The id of user who made these changes. If null, possibly means that the change made by an integration.
  """
  actorId: String

  """
  The actors that performed the actions. This field may be empty in the case of integrations or automations.
  """
  actors: [User!] @deprecated(reason: "Use `actor` and `descriptionUpdatedBy` instead.")

  """ID's of labels that were added."""
  addedLabelIds: [String!]

  """The labels that were added to the issue."""
  addedLabels: [IssueLabel!]

  """Whether the issue is archived at the time of this history entry."""
  archived: Boolean

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The linked attachment."""
  attachment: Attachment

  """The id of linked attachment."""
  attachmentId: String

  """Whether the issue was auto-archived."""
  autoArchived: Boolean

  """Whether the issue was auto-closed."""
  autoClosed: Boolean

  """The bot that performed the action."""
  botActor: ActorBot

  """
  [Internal] Serialized JSON representing changes for certain non-relational properties.
  """
  changes: JSONObject

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The id of linked customer need."""
  customerNeedId: String

  """The actors that edited the description of the issue, if any."""
  descriptionUpdatedBy: [User!]

  """The user that was unassigned from the issue."""
  fromAssignee: User

  """The id of user from whom the issue was re-assigned from."""
  fromAssigneeId: String

  """The cycle that the issue was moved from."""
  fromCycle: Cycle

  """The id of previous cycle of the issue."""
  fromCycleId: String

  """The app user from whom the issue delegation was transferred."""
  fromDelegate: User

  """What the due date was changed from."""
  fromDueDate: TimelessDate

  """What the estimate was changed from."""
  fromEstimate: Float

  """The parent issue that the issue was moved from."""
  fromParent: Issue

  """The id of previous parent of the issue."""
  fromParentId: String

  """What the priority was changed from."""
  fromPriority: Float

  """The project that the issue was moved from."""
  fromProject: Project

  """The id of previous project of the issue."""
  fromProjectId: String

  """The state that the issue was moved from."""
  fromState: WorkflowState

  """The id of previous workflow state of the issue."""
  fromStateId: String

  """The team that the issue was moved from."""
  fromTeam: Team

  """The id of team from which the issue was moved from."""
  fromTeamId: String

  """What the title was changed from."""
  fromTitle: String

  """The unique identifier of the entity."""
  id: ID!

  """The issue that was changed."""
  issue: Issue!

  """The import record."""
  issueImport: IssueImport

  """Changed issue relationships."""
  relationChanges: [IssueRelationHistoryPayload!]

  """ID's of labels that were removed."""
  removedLabelIds: [String!]

  """The labels that were removed from the issue."""
  removedLabels: [IssueLabel!]

  """The user that was assigned to the issue."""
  toAssignee: User

  """The id of user to whom the issue was assigned to."""
  toAssigneeId: String

  """The new project created from the issue."""
  toConvertedProject: Project

  """The id of new project created from the issue."""
  toConvertedProjectId: String

  """The cycle that the issue was moved to."""
  toCycle: Cycle

  """The id of new cycle of the issue."""
  toCycleId: String

  """The app user to whom the issue delegation was transferred."""
  toDelegate: User

  """What the due date was changed to."""
  toDueDate: TimelessDate

  """What the estimate was changed to."""
  toEstimate: Float

  """The parent issue that the issue was moved to."""
  toParent: Issue

  """The id of new parent of the issue."""
  toParentId: String

  """What the priority was changed to."""
  toPriority: Float

  """The project that the issue was moved to."""
  toProject: Project

  """The id of new project of the issue."""
  toProjectId: String

  """The state that the issue was moved to."""
  toState: WorkflowState

  """The id of new workflow state of the issue."""
  toStateId: String

  """The team that the issue was moved to."""
  toTeam: Team

  """The id of team to which the issue was moved to."""
  toTeamId: String

  """What the title was changed to."""
  toTitle: String

  """Whether the issue was trashed or un-trashed."""
  trashed: Boolean

  """The users that were notified of the issue."""
  triageResponsibilityNotifiedUsers: [User!]

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Whether the issue's description was updated."""
  updatedDescription: Boolean
}

type IssueHistoryConnection {
  edges: [IssueHistoryEdge!]!
  nodes: [IssueHistory!]!
  pageInfo: PageInfo!
}

type IssueHistoryEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: IssueHistory!
}

"""An import job for data from an external service."""
type IssueImport implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The id for the user that started the job."""
  creatorId: String

  """File URL for the uploaded CSV for the import, if there is one."""
  csvFileUrl: String

  """The display name of the import service."""
  displayName: String!

  """User readable error message, if one has occurred during the import."""
  error: String

  """Error code and metadata, if one has occurred during the import."""
  errorMetadata: JSONObject

  """The unique identifier of the entity."""
  id: ID!

  """The data mapping configuration for the import job."""
  mapping: JSONObject

  """Current step progress in % (0-100)."""
  progress: Float

  """The service from which data will be imported."""
  service: String!

  """Metadata related to import service."""
  serviceMetadata: JSONObject

  """The status for the import job."""
  status: String!

  """New team's name in cases when teamId not set."""
  teamName: String

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type IssueImportCheckPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

type IssueImportDeletePayload {
  """The import job that was deleted."""
  issueImport: IssueImport

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Whether a custom JQL query is valid or not"""
type IssueImportJqlCheckPayload {
  """
  Returns an approximate number of issues matching the JQL query, if available
  """
  count: Float

  """An error message returned by Jira when validating the JQL query."""
  error: String

  """
  Returns true if the JQL query has been validated successfully, false otherwise
  """
  success: Boolean!
}

type IssueImportPayload {
  """The import job that was created or updated."""
  issueImport: IssueImport

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Whether an issue import can be synced at the end of an import or not"""
type IssueImportSyncCheckPayload {
  """Returns true if the import can be synced, false otherwise"""
  canSync: Boolean!

  """An error message with a root cause of why the import cannot be synced"""
  error: String
}

input IssueImportUpdateInput {
  """The mapping configuration for the import."""
  mapping: JSONObject!
}

"""Labels that can be associated with issues."""
type IssueLabel implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Children of the label."""
  children(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issue labels."""
    filter: IssueLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """The label's color as a HEX string."""
  color: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the label."""
  creator: User

  """The label's description."""
  description: String

  """The unique identifier of the entity."""
  id: ID!

  """The original label inherited from."""
  inheritedFrom: IssueLabel

  """Whether the label is a group."""
  isGroup: Boolean!

  """Issues associated with the label."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """The date when the label was last applied to an issue or project."""
  lastAppliedAt: DateTime

  """The label's name."""
  name: String!
  organization: Organization! @deprecated(reason: "Workspace labels are identified by their team being null.")

  """The parent label."""
  parent: IssueLabel

  """
  The team that the label is associated with. If null, the label is associated with the global workspace.
  """
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""Issue label filtering options."""
input IssueLabelCollectionFilter {
  """Compound filters, all of which need to be matched by the label."""
  and: [IssueLabelCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the issue labels creator must satisfy."""
  creator: NullableUserFilter

  """Filters that needs to be matched by all issue labels."""
  every: IssueLabelFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for whether the label is a group label."""
  isGroup: BooleanComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Comparator for the name."""
  name: StringComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the label."""
  or: [IssueLabelCollectionFilter!]

  """Filters that the issue label's parent label must satisfy."""
  parent: IssueLabelFilter

  """Filters that needs to be matched by some issue labels."""
  some: IssueLabelFilter

  """Filters that the issue labels team must satisfy."""
  team: NullableTeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type IssueLabelConnection {
  edges: [IssueLabelEdge!]!
  nodes: [IssueLabel!]!
  pageInfo: PageInfo!
}

input IssueLabelCreateInput {
  """The color of the label."""
  color: String

  """The description of the label."""
  description: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """Whether the label is a group."""
  isGroup: Boolean

  """The name of the label."""
  name: String!

  """The identifier of the parent label."""
  parentId: String

  """
  The team associated with the label. If not given, the label will be associated with the entire workspace.
  """
  teamId: String
}

type IssueLabelEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: IssueLabel!
}

"""Issue label filtering options."""
input IssueLabelFilter {
  """Compound filters, all of which need to be matched by the label."""
  and: [IssueLabelFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the issue labels creator must satisfy."""
  creator: NullableUserFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for whether the label is a group label."""
  isGroup: BooleanComparator

  """Comparator for the name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the label."""
  or: [IssueLabelFilter!]

  """Filters that the issue label's parent label must satisfy."""
  parent: IssueLabelFilter

  """Filters that the issue labels team must satisfy."""
  team: NullableTeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

input IssueLabelMoveToTeamLabelsInput {
  """The identifier of the workspace label to convert."""
  id: String!
}

type IssueLabelMoveToTeamLabelsPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type IssueLabelPayload {
  """The label that was created or updated."""
  issueLabel: IssueLabel!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input IssueLabelUpdateInput {
  """The color of the label."""
  color: String

  """The description of the label."""
  description: String

  """Whether the label is a group."""
  isGroup: Boolean

  """The name of the label."""
  name: String

  """The identifier of the parent label."""
  parentId: String
}

"""An issue related notification."""
type IssueNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """The comment related to the notification."""
  comment: Comment

  """
  Related comment ID. Null if the notification is not related to a comment.
  """
  commentId: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """The issue related to the notification."""
  issue: Issue!

  """Related issue ID."""
  issueId: String!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """
  The parent comment related to the notification, if a notification is a reply comment notification.
  """
  parentComment: Comment

  """
  Related parent comment ID. Null if the notification is not related to a comment.
  """
  parentCommentId: String

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """Name of the reaction emoji related to the notification."""
  reactionEmoji: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """The subscriptions related to the notification."""
  subscriptions: [NotificationSubscription!]

  """[Internal] Notification subtitle."""
  subtitle: String!

  """The team related to the issue notification."""
  team: Team!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

type IssuePayload {
  """The issue that was created or updated."""
  issue: Issue

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type IssuePriorityValue {
  """Priority's label."""
  label: String!

  """Priority's number value."""
  priority: Int!
}

"""A relation between two issues."""
type IssueRelation implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The issue whose relationship is being described."""
  issue: Issue!

  """The related issue."""
  relatedIssue: Issue!

  """The relationship of the issue with the related issue."""
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type IssueRelationConnection {
  edges: [IssueRelationEdge!]!
  nodes: [IssueRelation!]!
  pageInfo: PageInfo!
}

input IssueRelationCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the issue that is related to another issue."""
  issueId: String!

  """The identifier of the related issue."""
  relatedIssueId: String!

  """The type of relation of the issue to the related issue."""
  type: IssueRelationType!
}

type IssueRelationEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: IssueRelation!
}

"""Issue relation history's payload."""
type IssueRelationHistoryPayload {
  """The identifier of the related issue."""
  identifier: String!

  """The type of the change."""
  type: String!
}

type IssueRelationPayload {
  """The issue relation that was created or updated."""
  issueRelation: IssueRelation!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The type of the issue relation."""
enum IssueRelationType {
  blocks
  duplicate
  related
  similar
}

input IssueRelationUpdateInput {
  """The identifier of the issue that is related to another issue."""
  issueId: String

  """The identifier of the related issue."""
  relatedIssueId: String

  """The type of relation of the issue to the related issue."""
  type: String
}

type IssueSearchPayload {
  """
  Archived entities matching the search term along with all their dependencies.
  """
  archivePayload: ArchiveResponse!
  edges: [IssueSearchResultEdge!]!
  nodes: [IssueSearchResult!]!
  pageInfo: PageInfo!

  """Total number of results for query without filters applied."""
  totalCount: Float!
}

type IssueSearchResult implements Node {
  """[Internal] The activity summary information for this issue."""
  activitySummary: JSONObject

  """The time at which the issue was added to a cycle."""
  addedToCycleAt: DateTime

  """The time at which the issue was added to a project."""
  addedToProjectAt: DateTime

  """The time at which the issue was added to a team."""
  addedToTeamAt: DateTime

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The user to whom the issue is assigned to."""
  assignee: User

  """Attachments associated with the issue."""
  attachments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned attachments."""
    filter: AttachmentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AttachmentConnection!

  """
  The time at which the issue was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """
  The time at which the issue was automatically closed by the auto pruning process.
  """
  autoClosedAt: DateTime

  """The order of the item in its column on the board."""
  boardOrder: Float! @deprecated(reason: "Will be removed in near future, please use `sortOrder` instead")

  """The bot that created the issue, if applicable."""
  botActor: ActorBot

  """Suggested branch name for the issue."""
  branchName: String!

  """The time at which the issue was moved into canceled state."""
  canceledAt: DateTime

  """Children of the issue."""
  children(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Comments associated with the issue."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The time at which the issue was moved into completed state."""
  completedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the issue."""
  creator: User

  """
  Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
  """
  customerTicketCount: Int!

  """The cycle that the issue is associated with."""
  cycle: Cycle

  """The agent user that is delegated to work on this issue."""
  delegate: User

  """The issue's description in markdown format."""
  description: String

  """[Internal] The issue's description content as YJS state."""
  descriptionState: String

  """[ALPHA] The document content representing this issue description."""
  documentContent: DocumentContent

  """The date at which the issue is due."""
  dueDate: TimelessDate

  """The estimate of the complexity of the issue.."""
  estimate: Float

  """The external user who created the issue."""
  externalUserCreator: ExternalUser

  """The users favorite associated with this issue."""
  favorite: Favorite

  """
  Attachments previously associated with the issue before being moved to another issue.
  """
  formerAttachments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned attachments."""
    filter: AttachmentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AttachmentConnection!

  """
  Customer needs previously associated with the issue before being moved to another issue.
  """
  formerNeeds(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned needs."""
    filter: CustomerNeedFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerNeedConnection!

  """History entries associated with the issue."""
  history(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueHistoryConnection!

  """The unique identifier of the entity."""
  id: ID!

  """Issue's human readable identifier (e.g. ENG-123)."""
  identifier: String!

  """
  [Internal] Incoming product intelligence relation suggestions for the issue.
  """
  incomingSuggestions(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueSuggestionConnection!

  """Integration type that created this issue, if applicable."""
  integrationSourceType: IntegrationService

  """Inverse relations associated with this issue."""
  inverseRelations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """Id of the labels associated with this issue."""
  labelIds: [String!]!

  """Labels associated with this issue."""
  labels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issue labels."""
    filter: IssueLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """The last template that was applied to this issue."""
  lastAppliedTemplate: Template

  """Metadata related to search result."""
  metadata: JSONObject!

  """Customer needs associated with the issue."""
  needs(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned needs."""
    filter: CustomerNeedFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerNeedConnection!

  """The issue's unique number."""
  number: Float!

  """The parent of the issue."""
  parent: Issue

  """Previous identifiers of the issue if it has been moved between teams."""
  previousIdentifiers: [String!]!

  """
  The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Float!

  """Label for the priority."""
  priorityLabel: String!

  """
  The order of the item in relation to other items in the organization, when ordered by priority.
  """
  prioritySortOrder: Float!

  """The project that the issue is associated with."""
  project: Project

  """The projectMilestone that the issue is associated with."""
  projectMilestone: ProjectMilestone

  """Emoji reaction summary, grouped by emoji type."""
  reactionData: JSONObject!

  """Reactions associated with the issue."""
  reactions: [Reaction!]!

  """The recurring issue template that created this issue."""
  recurringIssueTemplate: Template

  """Relations associated with this issue."""
  relations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """The time at which the issue's SLA will breach."""
  slaBreachesAt: DateTime

  """The time at which the issue's SLA will enter high risk state."""
  slaHighRiskAt: DateTime

  """The time at which the issue's SLA will enter medium risk state."""
  slaMediumRiskAt: DateTime

  """The time at which the issue's SLA began."""
  slaStartedAt: DateTime

  """The type of SLA set on the issue. Calendar days or business days."""
  slaType: String

  """The user who snoozed the issue."""
  snoozedBy: User

  """The time until an issue will be snoozed in Triage view."""
  snoozedUntilAt: DateTime

  """The order of the item in relation to other items in the organization."""
  sortOrder: Float!

  """The comment that this issue was created from."""
  sourceComment: Comment

  """The time at which the issue was moved into started state."""
  startedAt: DateTime

  """The time at which the issue entered triage."""
  startedTriageAt: DateTime

  """The workflow state that the issue is associated with."""
  state: WorkflowState!

  """
  The order of the item in the sub-issue list. Only set if the issue has a parent.
  """
  subIssueSortOrder: Float

  """Users who are subscribed to the issue."""
  subscribers(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned subscribers."""
    filter: UserFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """[Internal] Product intelligence suggestions for the issue."""
  suggestions(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueSuggestionConnection!

  """
  [Internal] The time at which the most recent suggestions for this issue were generated.
  """
  suggestionsGeneratedAt: DateTime

  """
  [DEPRECATED] [Internal] The user who has delegated this issue to be completed by an agent.
  """
  supervisor: User

  """The external services the issue is synced with."""
  syncedWith: [ExternalEntityInfo!]

  """The team that the issue is associated with."""
  team: Team!

  """The issue's title."""
  title: String!

  """A flag that indicates whether the issue is in the trash bin."""
  trashed: Boolean

  """The time at which the issue left triage."""
  triagedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Issue URL."""
  url: String!
}

type IssueSearchResultEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: IssueSearchResult!
}

"""Issue sorting options."""
input IssueSortInput {
  """Sort by assignee name"""
  assignee: AssigneeSort

  """Sort by issue completion date"""
  completedAt: CompletedAtSort

  """Sort by issue creation date"""
  createdAt: CreatedAtSort

  """Sort by customer name"""
  customer: CustomerSort

  """Sort by number of customers associated with the issue"""
  customerCount: CustomerCountSort

  """Sort by number of important customers associated with the issue"""
  customerImportantCount: CustomerImportantCountSort

  """Sort by customer revenue"""
  customerRevenue: CustomerRevenueSort

  """Sort by Cycle start date"""
  cycle: CycleSort

  """Sort by delegate name"""
  delegate: DelegateSort

  """Sort by issue due date"""
  dueDate: DueDateSort

  """Sort by estimate"""
  estimate: EstimateSort

  """Sort by label"""
  label: LabelSort

  """Sort by label group"""
  labelGroup: LabelGroupSort

  """[ALPHA] Sort by number of links associated with the issue"""
  linkCount: LinkCountSort

  """Sort by manual order"""
  manual: ManualSort

  """Sort by Project Milestone target date"""
  milestone: MilestoneSort

  """Sort by priority"""
  priority: PrioritySort

  """Sort by Project name"""
  project: ProjectSort

  """Sort by the root issue"""
  rootIssue: RootIssueSort

  """Sort by SLA status"""
  slaStatus: SlaStatusSort

  """Sort by Team name"""
  team: TeamSort

  """Sort by issue title"""
  title: TitleSort

  """Sort by issue update date"""
  updatedAt: UpdatedAtSort

  """Sort by workflow state type"""
  workflowState: WorkflowStateSort
}

type IssueSuggestion implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!
  issue: Issue!
  issueId: String!
  metadata: IssueSuggestionMetadata
  state: IssueSuggestionState!
  stateChangedAt: DateTime!
  suggestedIssue: Issue
  suggestedIssueId: String
  suggestedLabel: IssueLabel
  suggestedLabelId: String
  suggestedProject: Project
  suggestedTeam: Team
  suggestedUser: User
  suggestedUserId: String
  type: IssueSuggestionType!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type IssueSuggestionConnection {
  edges: [IssueSuggestionEdge!]!
  nodes: [IssueSuggestion!]!
  pageInfo: PageInfo!
}

type IssueSuggestionEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: IssueSuggestion!
}

type IssueSuggestionMetadata {
  classification: String
  evalLogId: String
  rank: Float
  reasons: [String!]
  score: Float
}

enum IssueSuggestionState {
  accepted
  active
  dismissed
  stale
}

enum IssueSuggestionType {
  assignee
  label
  project
  relatedIssue
  similarIssue
  team
}

type IssueTitleSuggestionFromCustomerRequestPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """[Internal] The log id of the ai response."""
  logId: String

  """The suggested issue title."""
  title: String!
}

input IssueUpdateInput {
  """The identifiers of the issue labels to be added to this issue."""
  addedLabelIds: [String!]

  """The identifier of the user to assign the issue to."""
  assigneeId: String

  """
  Whether the issue was automatically closed because its parent issue was closed.
  """
  autoClosedByParentClosing: Boolean

  """The position of the issue in its column on the board view."""
  boardOrder: Float @deprecated(reason: "Will be removed in near future, please use `sortOrder` instead")

  """The cycle associated with the issue."""
  cycleId: String

  """The identifier of the agent user to delegate the issue to."""
  delegateId: String

  """The issue description in markdown format."""
  description: String

  """[Internal] The issue description as a Prosemirror document."""
  descriptionData: JSON

  """The date at which the issue is due."""
  dueDate: TimelessDate

  """The estimated complexity of the issue."""
  estimate: Int

  """The identifiers of the issue labels associated with this ticket."""
  labelIds: [String!]

  """The ID of the last template applied to the issue."""
  lastAppliedTemplateId: String

  """The identifier of the parent issue."""
  parentId: String

  """
  The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Int

  """
  The position of the issue related to other issues, when ordered by priority.
  """
  prioritySortOrder: Float

  """The project associated with the issue."""
  projectId: String

  """The project milestone associated with the issue."""
  projectMilestoneId: String

  """The identifiers of the issue labels to be removed from this issue."""
  removedLabelIds: [String!]

  """
  [Internal] The timestamp at which an issue will be considered in breach of SLA.
  """
  slaBreachesAt: DateTime

  """[Internal] The timestamp at which the issue's SLA was started."""
  slaStartedAt: DateTime

  """
  The SLA day count type for the issue. Whether SLA should be business days only or calendar days (default).
  """
  slaType: SLADayCountType

  """The identifier of the user who snoozed the issue."""
  snoozedById: String

  """The time until an issue will be snoozed in Triage view."""
  snoozedUntilAt: DateTime

  """The position of the issue related to other issues."""
  sortOrder: Float

  """The team state of the issue."""
  stateId: String

  """The position of the issue in parent's sub-issue list."""
  subIssueSortOrder: Float

  """The identifiers of the users subscribing to this ticket."""
  subscriberIds: [String!]

  """The identifier of the team associated with the issue."""
  teamId: String

  """The issue title."""
  title: String

  """Whether the issue has been trashed."""
  trashed: Boolean
}

"""
The `JSON` scalar type represents arbitrary values as *stringified* JSON
"""
scalar JSON

"""
The `JSONObject` scalar type represents arbitrary values as *embedded* JSON
"""
scalar JSONObject

input JiraConfigurationInput {
  """The Jira personal access token."""
  accessToken: String!

  """The Jira user's email address."""
  email: String!

  """The Jira installation hostname."""
  hostname: String!

  """Whether this integration will be setup using the manual webhook flow."""
  manualSetup: Boolean

  """[DEPRECATED] The Jira project keys to scope the integration to."""
  project: String @deprecated(reason: "This parameter is ignored, use mappings instead to scope the integration to one or more specific projects")
}

input JiraLinearMappingInput {
  """Whether the sync for this mapping is bidirectional."""
  bidirectional: Boolean

  """Whether this mapping is the default one for issue creation."""
  default: Boolean

  """The Jira id for this project."""
  jiraProjectId: String!

  """The Linear team id to map to the given project."""
  linearTeamId: String!
}

input JiraPersonalSettingsInput {
  """
  The name of the Jira site currently authorized through the integration.
  """
  siteName: String
}

input JiraProjectDataInput {
  """The Jira id for this project."""
  id: String!

  """The Jira key for this project, such as ENG."""
  key: String!

  """The Jira name for this project, such as Engineering."""
  name: String!
}

input JiraSettingsInput {
  """Whether this integration is for Jira Server or not."""
  isJiraServer: Boolean = false

  """
  The label of the Jira instance, for visual identification purposes only
  """
  label: String

  """Whether this integration is using a manual setup flow."""
  manualSetup: Boolean

  """The mapping of Jira project id => Linear team id."""
  projectMapping: [JiraLinearMappingInput!]

  """The Jira projects for the organization."""
  projects: [JiraProjectDataInput!]!

  """
  Whether the user needs to provide setup information about the webhook to complete the integration setup. Only relevant for integrations that use a manual setup flow
  """
  setupPending: Boolean
}

input JiraUpdateInput {
  """The Jira personal access token."""
  accessToken: String

  """Whether to delete the current manual webhook configuration."""
  deleteWebhook: Boolean

  """The Jira user email address associated with the personal access token."""
  email: String

  """The id of the integration to update."""
  id: String!

  """Whether to refresh Jira metadata for the integration."""
  updateMetadata: Boolean

  """Whether to refresh Jira Projects for the integration."""
  updateProjects: Boolean

  """Webhook secret for a new manual configuration."""
  webhookSecret: String
}

input JoinOrganizationInput {
  """An optional invite link for an organization."""
  inviteLink: String

  """The identifier of the organization."""
  organizationId: String!
}

"""Issue label-group sorting options."""
input LabelGroupSort {
  """The label-group id to sort by"""
  labelGroupId: String!

  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A label notification subscription."""
type LabelNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer associated with the notification subscription."""
  customer: Customer

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """The label subscribed to."""
  label: IssueLabel!

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

"""Issue label sorting options."""
input LabelSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input LabelsMergeInput {
  """The identifiers of the labels to merge."""
  fromLabelIds: [String!]!

  """The identifier of the target label."""
  toLabelId: String!
}

input LaunchDarklySettingsInput {
  """The environment of the LaunchDarkly integration."""
  environment: String!

  """The project key of the LaunchDarkly integration."""
  projectKey: String!
}

"""[ALPHA] Issue link count sorting options."""
input LinkCountSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

type LogoutResponse {
  """Whether the operation was successful."""
  success: Boolean!
}

"""Issue manual sorting options."""
input ManualSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Issue project milestone options."""
input MilestoneSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

type Mutation {
  """Creates an agent activity."""
  agentActivityCreate(
    """The agent activity object to create."""
    input: AgentActivityCreateInput!
  ): AgentActivityPayload!

  """Creates a prompt agent activity from Linear user input."""
  agentActivityCreatePrompt(
    """The prompt agent activity object to create."""
    input: AgentActivityCreatePromptInput!
  ): AgentActivityPayload!

  """
  Updates the externalUrl of an agent session, which is an agent-hosted page associated with this session.
  """
  agentSessionUpdateExternalUrl(
    """The identifier of the agent session to update."""
    id: String!

    """The agent session object to update."""
    input: AgentSessionUpdateExternalUrlInput!
  ): AgentSessionPayload!

  """Creates an integration api key for Airbyte to connect with Linear."""
  airbyteIntegrationConnect(
    """Airbyte integration settings."""
    input: AirbyteConfigurationInput!
  ): IntegrationPayload!

  """[INTERNAL] Creates a new API key."""
  apiKeyCreate(
    """The api key object to create."""
    input: ApiKeyCreateInput!
  ): ApiKeyPayload!

  """[INTERNAL] Deletes an API key."""
  apiKeyDelete(
    """The identifier of the API key to delete."""
    id: String!
  ): DeletePayload!

  """[INTERNAL] Updates an API key's allowed teams."""
  apiKeyUpdate(
    """The identifier of the API key to update."""
    id: String!

    """The update input."""
    input: ApiKeyUpdateInput!
  ): ApiKeyPayload!

  """
  Creates a new attachment, or updates existing if the same `url` and `issueId` is used.
  """
  attachmentCreate(
    """The attachment object to create."""
    input: AttachmentCreateInput!
  ): AttachmentPayload!

  """Deletes an issue attachment."""
  attachmentDelete(
    """The identifier of the attachment to delete."""
    id: String!
  ): DeletePayload!

  """Link an existing Discord message to an issue."""
  attachmentLinkDiscord(
    """The Discord channel ID for the message to link."""
    channelId: String!

    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the Discord message."""
    issueId: String!

    """The Discord message ID for the message to link."""
    messageId: String!

    """The title to use for the attachment."""
    title: String

    """The Discord message URL for the message to link."""
    url: String!
  ): AttachmentPayload!

  """Link an existing Front conversation to an issue."""
  attachmentLinkFront(
    """The Front conversation ID to link."""
    conversationId: String!

    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the Front conversation."""
    issueId: String!

    """The title to use for the attachment."""
    title: String
  ): FrontAttachmentPayload!

  """Link a GitHub issue to a Linear issue."""
  attachmentLinkGitHubIssue(
    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The Linear issue for which to link the GitHub issue."""
    issueId: String!

    """The title to use for the attachment."""
    title: String

    """The URL of the GitHub issue to link."""
    url: String!
  ): AttachmentPayload!

  """Link a GitHub pull request to an issue."""
  attachmentLinkGitHubPR(
    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the GitHub pull request."""
    issueId: String!

    """[Internal] The kind of link between the issue and the pull request."""
    linkKind: GitLinkKind

    """The GitHub pull request number to link."""
    number: Float @deprecated(reason: "No longer required")

    """The owner of the GitHub repository."""
    owner: String @deprecated(reason: "No longer required")

    """The name of the GitHub repository."""
    repo: String @deprecated(reason: "No longer required")

    """The title to use for the attachment."""
    title: String

    """The URL of the GitHub pull request to link."""
    url: String!
  ): AttachmentPayload!

  """Link an existing GitLab MR to an issue."""
  attachmentLinkGitLabMR(
    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the GitLab merge request."""
    issueId: String!

    """The GitLab merge request number to link."""
    number: Float!

    """
    The path name to the project including any (sub)groups. E.g. linear/main/client.
    """
    projectPathWithNamespace: String!

    """The title to use for the attachment."""
    title: String

    """The URL of the GitLab merge request to link."""
    url: String!
  ): AttachmentPayload!

  """Link an existing Intercom conversation to an issue."""
  attachmentLinkIntercom(
    """The Intercom conversation ID to link."""
    conversationId: String!

    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the Intercom conversation."""
    issueId: String!

    """An optional Intercom conversation part ID to link to"""
    partId: String

    """The title to use for the attachment."""
    title: String
  ): AttachmentPayload!

  """Link an existing Jira issue to an issue."""
  attachmentLinkJiraIssue(
    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the Jira issue."""
    issueId: String!

    """The Jira issue key or ID to link."""
    jiraIssueId: String!

    """The title to use for the attachment."""
    title: String

    """Optional fallback URL to use if the Jira issue cannot be found."""
    url: String
  ): AttachmentPayload!

  """Link an existing Salesforce case to an issue."""
  attachmentLinkSalesforce(
    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the Salesforce case."""
    issueId: String!

    """The title to use for the attachment."""
    title: String

    """The URL of the Salesforce case to link."""
    url: String!
  ): AttachmentPayload!

  """Link an existing Slack message to an issue."""
  attachmentLinkSlack(
    """[DEPRECATED] The Slack channel ID for the message to link."""
    channel: String @deprecated(reason: "This field is now ignored.")

    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue to which to link the Slack message."""
    issueId: String!

    """[DEPRECATED] The latest timestamp for the Slack message."""
    latest: String @deprecated(reason: "This field is now ignored.")

    """
    Whether to begin syncing the message's Slack thread with a comment thread on the issue.
    """
    syncToCommentThread: Boolean

    """The title to use for the attachment."""
    title: String

    """
    [DEPRECATED] Unique identifier of either a thread's parent message or a message in the thread.
    """
    ts: String @deprecated(reason: "This field is now ignored.")

    """The Slack message URL for the message to link."""
    url: String!
  ): AttachmentPayload!

  """Link any url to an issue."""
  attachmentLinkURL(
    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """The id for the attachment."""
    id: String

    """The issue for which to link the url."""
    issueId: String!

    """The title to use for the attachment."""
    title: String

    """The url to link."""
    url: String!
  ): AttachmentPayload!

  """Link an existing Zendesk ticket to an issue."""
  attachmentLinkZendesk(
    """
    Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=app` mode.
    """
    createAsUser: String

    """
    Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=app` mode.
    """
    displayIconUrl: String

    """Optional attachment ID that may be provided through the API."""
    id: String

    """The issue for which to link the Zendesk ticket."""
    issueId: String!

    """The Zendesk ticket ID to link."""
    ticketId: String!

    """The title to use for the attachment."""
    title: String

    """The URL of the Zendesk ticket to link."""
    url: String
  ): AttachmentPayload!

  """
  Begin syncing the thread for an existing Slack message attachment with a comment thread on its issue.
  """
  attachmentSyncToSlack(
    """The ID of the Slack attachment to begin syncing."""
    id: String!
  ): AttachmentPayload!

  """Updates an existing issue attachment."""
  attachmentUpdate(
    """The identifier of the attachment to update."""
    id: String!

    """A partial attachment object to update the attachment with."""
    input: AttachmentUpdateInput!
  ): AttachmentPayload!

  """Creates a new comment."""
  commentCreate(
    """The comment object to create."""
    input: CommentCreateInput!
  ): CommentPayload!

  """Deletes a comment."""
  commentDelete(
    """The identifier of the comment to delete."""
    id: String!
  ): DeletePayload!

  """Resolves a comment."""
  commentResolve(
    """The identifier of the comment to update."""
    id: String!
    resolvingCommentId: String
  ): CommentPayload!

  """Unresolves a comment."""
  commentUnresolve(
    """The identifier of the comment to update."""
    id: String!
  ): CommentPayload!

  """Updates a comment."""
  commentUpdate(
    """The identifier of the comment to update."""
    id: String!

    """A partial comment object to update the comment with."""
    input: CommentUpdateInput!
  ): CommentPayload!

  """Saves user message."""
  contactCreate(
    """The contact entry to create."""
    input: ContactCreateInput!
  ): ContactPayload!

  """[INTERNAL] Saves sales pricing inquiry to Front."""
  contactSalesCreate(
    """The contact entry to create."""
    input: ContactSalesCreateInput!
  ): ContactPayload!

  """Create CSV export report for the organization."""
  createCsvExportReport(includePrivateTeamIds: [String!]): CreateCsvExportReportPayload!

  """Create a notification to remind a user about an initiative update."""
  createInitiativeUpdateReminder(
    """The identifier of the initiative to remind about."""
    initiativeId: String!

    """
    The user identifier to whom the notification will be sent. By default, it is set to the initiative owner.
    """
    userId: String
  ): InitiativeUpdateReminderPayload!

  """Creates an organization from onboarding."""
  createOrganizationFromOnboarding(
    """Organization details for the new organization."""
    input: CreateOrganizationInput!

    """Onboarding survey."""
    survey: OnboardingCustomerSurvey
  ): CreateOrJoinOrganizationResponse!

  """Create a notification to remind a user about a project update."""
  createProjectUpdateReminder(
    """The identifier of the project to remind about."""
    projectId: String!

    """
    The user identifier to whom the notification will be sent. By default, it is set to the project lead.
    """
    userId: String
  ): ProjectUpdateReminderPayload!

  """Creates a new custom view."""
  customViewCreate(
    """The properties of the custom view to create."""
    input: CustomViewCreateInput!
  ): CustomViewPayload!

  """Deletes a custom view."""
  customViewDelete(
    """The identifier of the custom view to delete."""
    id: String!
  ): DeletePayload!

  """Updates a custom view."""
  customViewUpdate(
    """The identifier of the custom view to update."""
    id: String!

    """The properties of the custom view to update."""
    input: CustomViewUpdateInput!
  ): CustomViewPayload!

  """Creates a new customer."""
  customerCreate(
    """The customer to create."""
    input: CustomerCreateInput!
  ): CustomerPayload!

  """Deletes a customer."""
  customerDelete(
    """The identifier of the customer to delete."""
    id: String!
  ): DeletePayload!

  """Merges two customers."""
  customerMerge(
    """
    The ID of the customer to merge. The needs of this customer will be transferred before it gets deleted.
    """
    sourceCustomerId: String!

    """
    The ID of the target customer to merge into. The needs of this customer will be retained
    """
    targetCustomerId: String!
  ): CustomerPayload!

  """Archives a customer need."""
  customerNeedArchive(
    """The identifier of the customer need to archive."""
    id: String!
  ): CustomerNeedArchivePayload!

  """Creates a new customer need."""
  customerNeedCreate(
    """The customer need to create."""
    input: CustomerNeedCreateInput!
  ): CustomerNeedPayload!

  """Creates a new customer need out of an attachment"""
  customerNeedCreateFromAttachment(
    """The customer need to create."""
    input: CustomerNeedCreateFromAttachmentInput!
  ): CustomerNeedPayload!

  """Deletes a customer need."""
  customerNeedDelete(
    """The identifier of the customer need to delete."""
    id: String!

    """Whether to keep the attachment associated with the customer need."""
    keepAttachment: Boolean
  ): DeletePayload!

  """Unarchives a customer need."""
  customerNeedUnarchive(
    """The identifier of the customer need to unarchive."""
    id: String!
  ): CustomerNeedArchivePayload!

  """Updates a customer need"""
  customerNeedUpdate(
    """The identifier of the customer need to update."""
    id: String!

    """The properties of the customer need to update."""
    input: CustomerNeedUpdateInput!
  ): CustomerNeedUpdatePayload!

  """Creates a new customer status."""
  customerStatusCreate(
    """The CustomerStatus object to create."""
    input: CustomerStatusCreateInput!
  ): CustomerStatusPayload!

  """Deletes a customer status."""
  customerStatusDelete(
    """The identifier of the customer status to delete."""
    id: String!
  ): DeletePayload!

  """Updates a customer status."""
  customerStatusUpdate(
    """The identifier of the customer status to update."""
    id: String!

    """A partial CustomerStatus object to update the CustomerStatus with."""
    input: CustomerStatusUpdateInput!
  ): CustomerStatusPayload!

  """Creates a new customer tier."""
  customerTierCreate(
    """The CustomerTier object to create."""
    input: CustomerTierCreateInput!
  ): CustomerTierPayload!

  """Deletes a customer tier."""
  customerTierDelete(
    """The identifier of the customer tier to delete."""
    id: String!
  ): DeletePayload!

  """Updates a customer tier."""
  customerTierUpdate(
    """The identifier of the customer tier to update."""
    id: String!

    """A partial CustomerTier object to update the CustomerTier with."""
    input: CustomerTierUpdateInput!
  ): CustomerTierPayload!

  """Updates a customer"""
  customerUpdate(
    """The identifier of the customer to update."""
    id: String!

    """The properties of the customer to update."""
    input: CustomerUpdateInput!
  ): CustomerPayload!

  """
  Upserts a customer, creating it if it doesn't exists, updating it otherwise. Matches against an existing customer with `id` or `externalId`
  """
  customerUpsert(
    """The customer to create."""
    input: CustomerUpsertInput!
  ): CustomerPayload!

  """Archives a cycle."""
  cycleArchive(
    """The identifier of the cycle to archive."""
    id: String!
  ): CycleArchivePayload!

  """Creates a new cycle."""
  cycleCreate(
    """The cycle object to create."""
    input: CycleCreateInput!
  ): CyclePayload!

  """
  Shifts all cycles starts and ends by a certain number of days, starting from the provided cycle onwards.
  """
  cycleShiftAll(
    """A partial cycle object to update the cycle with."""
    input: CycleShiftAllInput!
  ): CyclePayload!

  """
  Shifts all cycles starts and ends by a certain number of days, starting from the provided cycle onwards.
  """
  cycleStartUpcomingCycleToday(
    """
    The identifier of the cycle to start as of midnight today. Must be the upcoming cycle.
    """
    id: String!
  ): CyclePayload!

  """Updates a cycle."""
  cycleUpdate(
    """The identifier of the cycle to update."""
    id: String!

    """A partial cycle object to update the cycle with."""
    input: CycleUpdateInput!
  ): CyclePayload!

  """Creates a new document."""
  documentCreate(
    """The document to create."""
    input: DocumentCreateInput!
  ): DocumentPayload!

  """Deletes (trashes) a document."""
  documentDelete(
    """The identifier of the document to delete."""
    id: String!
  ): DocumentArchivePayload!

  """Restores a document."""
  documentUnarchive(
    """The identifier of the document to restore."""
    id: String!
  ): DocumentArchivePayload!

  """Updates a document."""
  documentUpdate(
    """
    The identifier of the document to update. Also the identifier from the URL is accepted.
    """
    id: String!

    """A partial document object to update the document with."""
    input: DocumentUpdateInput!
  ): DocumentPayload!

  """Creates a new email intake address."""
  emailIntakeAddressCreate(
    """The email intake address object to create."""
    input: EmailIntakeAddressCreateInput!
  ): EmailIntakeAddressPayload!

  """Deletes an email intake address object."""
  emailIntakeAddressDelete(
    """The identifier of the email intake address to delete."""
    id: String!
  ): DeletePayload!

  """Rotates an existing email intake address."""
  emailIntakeAddressRotate(
    """The identifier of the email intake address."""
    id: String!
  ): EmailIntakeAddressPayload!

  """Updates an existing email intake address."""
  emailIntakeAddressUpdate(
    """The identifier of the email intake address."""
    id: String!

    """The properties of the email intake address to update."""
    input: EmailIntakeAddressUpdateInput!
  ): EmailIntakeAddressPayload!

  """Authenticates a user account via email and authentication token."""
  emailTokenUserAccountAuth(
    """The data used for token authentication."""
    input: TokenUserAccountAuthInput!
  ): AuthResolverResponse!

  """Unsubscribes the user from one type of email."""
  emailUnsubscribe(
    """Unsubscription details."""
    input: EmailUnsubscribeInput!
  ): EmailUnsubscribePayload!

  """
  Finds or creates a new user account by email and sends an email with token.
  """
  emailUserAccountAuthChallenge(
    """The data used for email authentication."""
    input: EmailUserAccountAuthChallengeInput!
  ): EmailUserAccountAuthChallengeResponse!

  """Creates a custom emoji."""
  emojiCreate(
    """The emoji object to create."""
    input: EmojiCreateInput!
  ): EmojiPayload!

  """Deletes an emoji."""
  emojiDelete(
    """The identifier of the emoji to delete."""
    id: String!
  ): DeletePayload!

  """Creates a new entity link."""
  entityExternalLinkCreate(
    """The entity link object to create."""
    input: EntityExternalLinkCreateInput!
  ): EntityExternalLinkPayload!

  """Deletes an entity link."""
  entityExternalLinkDelete(
    """The identifier of the entity link to delete."""
    id: String!
  ): DeletePayload!

  """Updates an entity link."""
  entityExternalLinkUpdate(
    """The identifier of the entity link to update."""
    id: String!

    """The entity link object to update."""
    input: EntityExternalLinkUpdateInput!
  ): EntityExternalLinkPayload!

  """Creates a new favorite (project, cycle etc)."""
  favoriteCreate(
    """The favorite object to create."""
    input: FavoriteCreateInput!
  ): FavoritePayload!

  """Deletes a favorite reference."""
  favoriteDelete(
    """The identifier of the favorite reference to delete."""
    id: String!
  ): DeletePayload!

  """Updates a favorite."""
  favoriteUpdate(
    """The identifier of the favorite to update."""
    id: String!

    """A partial favorite object to update the favorite with."""
    input: FavoriteUpdateInput!
  ): FavoritePayload!

  """
  XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
  """
  fileUpload(
    """MIME type of the uploaded file."""
    contentType: String!

    """Filename of the uploaded file."""
    filename: String!

    """Should the file be made publicly accessible (default: false)."""
    makePublic: Boolean

    """Optional metadata."""
    metaData: JSON

    """File size of the uploaded file."""
    size: Int!
  ): UploadPayload!

  """Creates a new automation state."""
  gitAutomationStateCreate(
    """The automation state to create."""
    input: GitAutomationStateCreateInput!
  ): GitAutomationStatePayload!

  """Archives an automation state."""
  gitAutomationStateDelete(
    """The identifier of the automation state to archive."""
    id: String!
  ): DeletePayload!

  """Updates an existing state."""
  gitAutomationStateUpdate(
    """The identifier of the state to update."""
    id: String!

    """The state to update."""
    input: GitAutomationStateUpdateInput!
  ): GitAutomationStatePayload!

  """Creates a Git target branch automation."""
  gitAutomationTargetBranchCreate(
    """The Git target branch automation to create."""
    input: GitAutomationTargetBranchCreateInput!
  ): GitAutomationTargetBranchPayload!

  """Archives a Git target branch automation."""
  gitAutomationTargetBranchDelete(
    """The identifier of the Git target branch automation to archive."""
    id: String!
  ): DeletePayload!

  """Updates an existing Git target branch automation."""
  gitAutomationTargetBranchUpdate(
    """The identifier of the Git target branch automation to update."""
    id: String!

    """The updates."""
    input: GitAutomationTargetBranchUpdateInput!
  ): GitAutomationTargetBranchPayload!

  """
  Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
  """
  googleUserAccountAuth(
    """The data used for Google authentication."""
    input: GoogleUserAccountAuthInput!
  ): AuthResolverResponse!

  """Upload an image from an URL to Linear."""
  imageUploadFromUrl(
    """URL of the file to be uploaded to Linear."""
    url: String!
  ): ImageUploadFromUrlPayload!

  """
  XHR request payload to upload a file for import, directly to Linear's cloud storage.
  """
  importFileUpload(
    """MIME type of the uploaded file."""
    contentType: String!

    """Filename of the uploaded file."""
    filename: String!

    """Optional metadata."""
    metaData: JSON

    """File size of the uploaded file."""
    size: Int!
  ): UploadPayload!

  """Archives a initiative."""
  initiativeArchive(
    """The identifier of the initiative to archive."""
    id: String!
  ): InitiativeArchivePayload!

  """Creates a new initiative."""
  initiativeCreate(
    """The properties of the initiative to create."""
    input: InitiativeCreateInput!
  ): InitiativePayload!

  """Deletes (trashes) an initiative."""
  initiativeDelete(
    """The identifier of the initiative to delete."""
    id: String!
  ): DeletePayload!

  """Creates a new initiative relation."""
  initiativeRelationCreate(
    """The initiative relation to create."""
    input: InitiativeRelationCreateInput!
  ): InitiativeRelationPayload!

  """Deletes an initiative relation."""
  initiativeRelationDelete(
    """The identifier of the initiative relation to delete."""
    id: String!
  ): DeletePayload!

  """Updates an initiative relation."""
  initiativeRelationUpdate(
    """The identifier of the initiative relation to update."""
    id: String!

    """The properties of the initiative relation to update."""
    input: InitiativeRelationUpdateInput!
  ): DeletePayload!

  """Creates a new initiativeToProject join."""
  initiativeToProjectCreate(
    """The properties of the initiativeToProject to create."""
    input: InitiativeToProjectCreateInput!
  ): InitiativeToProjectPayload!

  """Deletes a initiativeToProject."""
  initiativeToProjectDelete(
    """The identifier of the initiativeToProject to delete."""
    id: String!
  ): DeletePayload!

  """Updates a initiativeToProject."""
  initiativeToProjectUpdate(
    """The identifier of the initiativeToProject to update."""
    id: String!

    """The properties of the initiativeToProject to update."""
    input: InitiativeToProjectUpdateInput!
  ): InitiativeToProjectPayload!

  """Unarchives a initiative."""
  initiativeUnarchive(
    """The identifier of the initiative to unarchive."""
    id: String!
  ): InitiativeArchivePayload!

  """Updates a initiative."""
  initiativeUpdate(
    """The identifier of the initiative to update."""
    id: String!

    """The properties of the initiative to update."""
    input: InitiativeUpdateInput!
  ): InitiativePayload!

  """Archives an initiative update."""
  initiativeUpdateArchive(
    """The identifier of the initiative update to archive."""
    id: String!
  ): InitiativeUpdateArchivePayload!

  """Creates a initiative update."""
  initiativeUpdateCreate(
    """The initiative update object to create."""
    input: InitiativeUpdateCreateInput!
  ): InitiativeUpdatePayload!

  """Unarchives an initiative update."""
  initiativeUpdateUnarchive(
    """The identifier of the initiative update to unarchive."""
    id: String!
  ): InitiativeUpdateArchivePayload!

  """Updates an update."""
  initiativeUpdateUpdate(
    """The identifier of the update to update."""
    id: String!

    """A data to update the update with."""
    input: InitiativeUpdateUpdateInput!
  ): InitiativeUpdatePayload!

  """Archives an integration."""
  integrationArchive(
    """The identifier of the integration to archive."""
    id: String!
  ): DeletePayload!

  """Connect a Slack channel to Asks."""
  integrationAsksConnectChannel(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): AsksChannelConnectPayload!

  """
  [INTERNAL] Refreshes the customer data attributes from the specified integration service.
  """
  integrationCustomerDataAttributesRefresh(
    """The integration service to refresh customer data attributes from."""
    input: IntegrationCustomerDataAttributesRefreshInput!
  ): IntegrationPayload!

  """Deletes an integration."""
  integrationDelete(
    """The identifier of the integration to delete."""
    id: String!

    """
    Whether to skip deleting the installation on the external service side.
    """
    skipInstallationDeletion: Boolean
  ): DeletePayload!

  """Integrates the organization with Discord."""
  integrationDiscord(
    """The Discord OAuth code."""
    code: String!

    """The Discord OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """Integrates the organization with Figma."""
  integrationFigma(
    """The Figma OAuth code."""
    code: String!

    """The Figma OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """Integrates the organization with Front."""
  integrationFront(
    """The Front OAuth code."""
    code: String!

    """The Front OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """Connects the organization with a GitHub Enterprise Server."""
  integrationGitHubEnterpriseServerConnect(
    """The base URL of the GitHub Enterprise Server installation."""
    githubUrl: String!

    """The name of GitHub organization."""
    organizationName: String!
  ): GitHubEnterpriseServerPayload!

  """Connect your GitHub account to Linear."""
  integrationGitHubPersonal(
    """The GitHub OAuth code."""
    code: String!

    """Whether to connect with code access."""
    codeAccess: Boolean
  ): IntegrationPayload!

  """Generates a webhook for the GitHub commit integration."""
  integrationGithubCommitCreate: GitHubCommitIntegrationPayload!

  """Connects the organization with the GitHub App."""
  integrationGithubConnect(
    """The GitHub grant code that's exchanged for OAuth tokens."""
    code: String!

    """Whether the integration should have code access"""
    codeAccess: Boolean = false

    """The GitHub data to connect with."""
    installationId: String!
  ): IntegrationPayload!

  """Connects the organization with the GitHub Import App."""
  integrationGithubImportConnect(
    """The GitHub grant code that's exchanged for OAuth tokens."""
    code: String!

    """The GitHub data to connect with."""
    installationId: String!
  ): IntegrationPayload!

  """Refreshes the data for a GitHub import integration."""
  integrationGithubImportRefresh(
    """The id of the integration to update."""
    id: String!
  ): IntegrationPayload!

  """Connects the organization with a GitLab Access Token."""
  integrationGitlabConnect(
    """The GitLab Access Token to connect with."""
    accessToken: String!

    """The URL of the GitLab installation."""
    gitlabUrl: String!
  ): GitLabIntegrationCreatePayload!

  """
  [Internal] Connects the Google Calendar to the user to this Linear account via OAuth2.
  """
  integrationGoogleCalendarPersonalConnect(
    """[Internal] The Google OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Integrates the organization with Google Sheets."""
  integrationGoogleSheets(
    """The Google OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Integrates the organization with Intercom."""
  integrationIntercom(
    """The Intercom OAuth code."""
    code: String!

    """
    The Intercom domain URL to use for the integration. Defaults to app.intercom.com if not provided.
    """
    domainUrl: String

    """The Intercom OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """Disconnects the organization from Intercom."""
  integrationIntercomDelete: IntegrationPayload!

  """[DEPRECATED] Updates settings on the Intercom integration."""
  integrationIntercomSettingsUpdate(
    """
    A partial Intercom integration settings object to update the integration settings with.
    """
    input: IntercomSettingsInput!
  ): IntegrationPayload! @deprecated(reason: "This mutation is deprecated, please use `integrationSettingsUpdate` instead")

  """Connect your Jira account to Linear."""
  integrationJiraPersonal(
    """The Jira personal access token, when connecting using a PAT."""
    accessToken: String

    """The Jira OAuth code, when connecting using OAuth."""
    code: String
  ): IntegrationPayload!

  """[INTERNAL] Updates a Jira Integration."""
  integrationJiraUpdate(
    """Jira integration update input."""
    input: JiraUpdateInput!
  ): IntegrationPayload!

  """[INTERNAL] Integrates the organization with LaunchDarkly."""
  integrationLaunchDarklyConnect(
    """The LaunchDarkly OAuth code."""
    code: String!

    """The LaunchDarkly environment."""
    environment: String!

    """The LaunchDarkly project key."""
    projectKey: String!
  ): IntegrationPayload!

  """[INTERNAL] Integrates your personal account with LaunchDarkly."""
  integrationLaunchDarklyPersonalConnect(
    """The LaunchDarkly OAuth code."""
    code: String!
  ): IntegrationPayload!

  """Enables Loom integration for the organization."""
  integrationLoom: IntegrationPayload! @deprecated(reason: "Not available.")

  """[INTERNAL] Integrates the organization with Opsgenie."""
  integrationOpsgenieConnect(
    """The Opsgenie API key."""
    apiKey: String!
  ): IntegrationPayload!

  """[INTERNAL] Refresh Opsgenie schedule mappings."""
  integrationOpsgenieRefreshScheduleMappings: IntegrationPayload!

  """[INTERNAL] Integrates the organization with PagerDuty."""
  integrationPagerDutyConnect(
    """The PagerDuty OAuth code."""
    code: String!

    """The PagerDuty OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """[INTERNAL] Refresh PagerDuty schedule mappings."""
  integrationPagerDutyRefreshScheduleMappings: IntegrationPayload!

  """Requests a currently unavailable integration."""
  integrationRequest(
    """Integration request details."""
    input: IntegrationRequestInput!
  ): IntegrationRequestPayload!

  """Integrates the organization with Salesforce."""
  integrationSalesforce(
    """The Salesforce OAuth code."""
    code: String!

    """The Salesforce OAuth redirect URI."""
    redirectUri: String!

    """The Salesforce installation subdomain."""
    subdomain: String!
  ): IntegrationPayload!

  """[INTERNAL] Refreshes the Salesforce integration metadata."""
  integrationSalesforceMetadataRefresh(
    """The ID of the integration to refresh metadata for."""
    id: String!
  ): IntegrationPayload!

  """Integrates the organization with Sentry."""
  integrationSentryConnect(
    """The Sentry grant code that's exchanged for OAuth tokens."""
    code: String!

    """The Sentry installationId to connect with."""
    installationId: String!

    """The slug of the Sentry organization being connected."""
    organizationSlug: String!
  ): IntegrationPayload!

  """[INTERNAL] Updates the integration settings."""
  integrationSettingsUpdate(
    """The identifier of the integration to update."""
    id: String!

    """An integration settings object."""
    input: IntegrationSettingsInput!
  ): IntegrationPayload! @deprecated(reason: "Use integrationUpdate instead.")

  """Integrates the organization with Slack."""
  integrationSlack(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """
    [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
    """
    shouldUseV2Auth: Boolean
  ): IntegrationPayload!

  """Integrates the organization with the Slack Asks app."""
  integrationSlackAsks(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """Slack integration for custom view notifications."""
  integrationSlackCustomViewNotifications(
    """The Slack OAuth code."""
    code: String!

    """Integration's associated custom view."""
    customViewId: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): SlackChannelConnectPayload!

  """Integrates a Slack Asks channel with a Customer."""
  integrationSlackCustomerChannelLink(
    """The Slack OAuth code."""
    code: String!

    """The customer to link the Slack channel with"""
    customerId: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): SuccessPayload!

  """Imports custom emojis from your Slack workspace."""
  integrationSlackImportEmojis(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """[Internal] Slack integration for initiative notifications."""
  integrationSlackInitiativePost(
    """The Slack OAuth code."""
    code: String!

    """Integration's associated initiative."""
    initiativeId: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): SlackChannelConnectPayload!

  """
  [Internal] Slack integration for organization level initiative update notifications.
  """
  integrationSlackOrgInitiativeUpdatesPost(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): SlackChannelConnectPayload!

  """Slack integration for organization level project update notifications."""
  integrationSlackOrgProjectUpdatesPost(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): SlackChannelConnectPayload!

  """Integrates your personal notifications with Slack."""
  integrationSlackPersonal(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """Slack integration for team notifications."""
  integrationSlackPost(
    """The Slack OAuth code."""
    code: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """
    [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
    """
    shouldUseV2Auth: Boolean

    """Integration's associated team."""
    teamId: String!
  ): SlackChannelConnectPayload!

  """Slack integration for project notifications."""
  integrationSlackProjectPost(
    """The Slack OAuth code."""
    code: String!

    """Integration's associated project."""
    projectId: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!

    """
    The service to enable once connected, either 'notifications' or 'updates'.
    """
    service: String!
  ): SlackChannelConnectPayload!

  """Creates a new integrationTemplate join."""
  integrationTemplateCreate(
    """The properties of the integrationTemplate to create."""
    input: IntegrationTemplateCreateInput!
  ): IntegrationTemplatePayload!

  """Deletes a integrationTemplate."""
  integrationTemplateDelete(
    """The identifier of the integrationTemplate to delete."""
    id: String!
  ): DeletePayload!

  """[INTERNAL] Updates the integration."""
  integrationUpdate(
    """The identifier of the integration to update."""
    id: String!

    """A partial integration object to update the integration with."""
    input: IntegrationUpdateInput!
  ): IntegrationPayload!

  """Integrates the organization with Zendesk."""
  integrationZendesk(
    """The Zendesk OAuth code."""
    code: String!

    """The Zendesk OAuth redirect URI."""
    redirectUri: String!

    """The Zendesk OAuth scopes."""
    scope: String!

    """The Zendesk installation subdomain."""
    subdomain: String!
  ): IntegrationPayload!

  """Creates new settings for one or more integrations."""
  integrationsSettingsCreate(
    """The settings to create."""
    input: IntegrationsSettingsCreateInput!
  ): IntegrationsSettingsPayload!

  """Updates settings related to integrations for a project or a team."""
  integrationsSettingsUpdate(
    """The identifier of the settings to update."""
    id: String!

    """A settings object to update the settings with."""
    input: IntegrationsSettingsUpdateInput!
  ): IntegrationsSettingsPayload!

  """Adds a label to an issue."""
  issueAddLabel(
    """The identifier of the issue to add the label to."""
    id: String!

    """The identifier of the label to add."""
    labelId: String!
  ): IssuePayload!

  """Archives an issue."""
  issueArchive(
    """The identifier of the issue to archive."""
    id: String!

    """Whether to trash the issue."""
    trash: Boolean
  ): IssueArchivePayload!

  """Creates a list of issues in one transaction."""
  issueBatchCreate(
    """A list of issue objects to create."""
    input: IssueBatchCreateInput!
  ): IssueBatchPayload!

  """Updates multiple issues at once."""
  issueBatchUpdate(
    """The id's of the issues to update. Can't be more than 50 at a time."""
    ids: [UUID!]!

    """A partial issue object to update the issues with."""
    input: IssueUpdateInput!
  ): IssueBatchPayload!

  """Creates a new issue."""
  issueCreate(
    """The issue object to create."""
    input: IssueCreateInput!
  ): IssuePayload!

  """Deletes (trashes) an issue."""
  issueDelete(
    """The identifier of the issue to delete."""
    id: String!

    """
    Whether to permanently delete the issue and skip the grace period of 30 days. Available only to admins!
    """
    permanentlyDelete: Boolean
  ): IssueArchivePayload!

  """
  [INTERNAL] Updates an issue description from the Front app to handle Front attachments correctly.
  """
  issueDescriptionUpdateFromFront(
    """Description to update the issue with. """
    description: String!

    """The identifier of the issue to update."""
    id: String!
  ): IssuePayload!

  """Kicks off an Asana import job."""
  issueImportCreateAsana(
    """Asana team name to choose which issues we should import."""
    asanaTeamName: String!

    """Asana token to fetch information from the Asana API."""
    asanaToken: String!

    """ID of issue import. If not provided it will be generated."""
    id: String

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """ID of the organization into which to import data."""
    organizationId: String @deprecated(reason: "Argument will be ignored. Use teamId to import in a specific team, or teamName to import into a new team.")

    """ID of the team into which to import data."""
    teamId: String

    """Name of new team. When teamId is not set."""
    teamName: String
  ): IssueImportPayload!

  """Kicks off a Jira import job from a CSV."""
  issueImportCreateCSVJira(
    """URL for the CSV."""
    csvUrl: String!

    """Jira user account email."""
    jiraEmail: String

    """Jira installation or cloud hostname."""
    jiraHostname: String

    """Jira personal access token to access Jira REST API."""
    jiraToken: String

    """ID of the organization into which to import data."""
    organizationId: String @deprecated(reason: "Argument will be ignored. Use teamId to import in a specific team, or teamName to import into a new team.")

    """ID of the team into which to import data. Empty to create new team."""
    teamId: String

    """Name of new team. When teamId is not set."""
    teamName: String
  ): IssueImportPayload!

  """Kicks off a Shortcut (formerly Clubhouse) import job."""
  issueImportCreateClubhouse(
    """
    Shortcut (formerly Clubhouse) group name to choose which issues we should import.
    """
    clubhouseGroupName: String!

    """
    Shortcut (formerly Clubhouse) token to fetch information from the Clubhouse API.
    """
    clubhouseToken: String!

    """ID of issue import. If not provided it will be generated."""
    id: String

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """ID of the organization into which to import data."""
    organizationId: String @deprecated(reason: "Argument will be ignored. Use teamId to import in a specific team, or teamName to import into a new team.")

    """ID of the team into which to import data."""
    teamId: String

    """Name of new team. When teamId is not set."""
    teamName: String
  ): IssueImportPayload!

  """Kicks off a GitHub import job."""
  issueImportCreateGithub(
    """
    Labels to use to filter the import data. Only issues matching any of these filters will be imported.
    """
    githubLabels: [String!]

    """IDs of the Github repositories from which we will import data."""
    githubRepoIds: [Int!]

    """Whether or not we should import GitHub organization level projects."""
    githubShouldImportOrgProjects: Boolean @deprecated(reason: "Argument will be ignored. The project information of an issue is always imported regardless of whether the project is linked to the repository of the issue or not")

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """
    [DEPRECATED] ID of the Github import integration to use to access issues.
    """
    integrationId: String @deprecated(reason: "An import can span multiple integrations. Value will be ignored.")

    """ID of the organization into which to import data."""
    organizationId: String @deprecated(reason: "Argument will be ignored. Use teamId to import in a specific team, or teamName to import into a new team.")

    """ID of the team into which to import data."""
    teamId: String

    """Name of new team. When teamId is not set."""
    teamName: String
  ): IssueImportPayload!

  """Kicks off a Jira import job."""
  issueImportCreateJira(
    """ID of issue import. If not provided it will be generated."""
    id: String

    """Whether or not we should collect the data for closed issues."""
    includeClosedIssues: Boolean

    """
    Whether to instantly process the import with the default configuration mapping.
    """
    instantProcess: Boolean

    """Jira user account email."""
    jiraEmail: String!

    """Jira installation or cloud hostname."""
    jiraHostname: String!

    """Jira project key from which we will import data."""
    jiraProject: String!

    """Jira personal access token to access Jira REST API."""
    jiraToken: String!

    """A custom JQL query to filter issues being imported"""
    jql: String

    """ID of the organization into which to import data."""
    organizationId: String @deprecated(reason: "Argument will be ignored. Use teamId to import in a specific team, or teamName to import into a new team.")

    """ID of the team into which to import data. Empty to create new team."""
    teamId: String

    """Name of new team. When teamId is not set."""
    teamName: String
  ): IssueImportPayload!

  """[INTERNAL] Kicks off a Linear to Linear import job."""
  issueImportCreateLinearV2(
    """ID of issue import. If not provided it will be generated."""
    id: String

    """The source organization to import from."""
    linearSourceOrganizationId: String!
  ): IssueImportPayload!

  """Deletes an import job."""
  issueImportDelete(
    """ID of the issue import to delete."""
    issueImportId: String!
  ): IssueImportDeletePayload!

  """Kicks off import processing."""
  issueImportProcess(
    """ID of the issue import which we're going to process."""
    issueImportId: String!

    """The mapping configuration to use for processing the import."""
    mapping: JSONObject!
  ): IssueImportPayload!

  """Updates the mapping for the issue import."""
  issueImportUpdate(
    """The identifier of the issue import."""
    id: String!

    """The properties of the issue import to update."""
    input: IssueImportUpdateInput!
  ): IssueImportPayload!

  """Creates a new label."""
  issueLabelCreate(
    """The issue label to create."""
    input: IssueLabelCreateInput!

    """
    Whether to replace all team-specific labels with the same name with this newly created workspace label (default: false).
    """
    replaceTeamLabels: Boolean
  ): IssueLabelPayload!

  """Deletes an issue label."""
  issueLabelDelete(
    """The identifier of the label to delete."""
    id: String!
  ): DeletePayload!

  """
  Converts a workspace label to team labels for teams that have issues using the workspace label.
  """
  issueLabelMoveToTeamLabels(
    """The workspace label to move to teams."""
    input: IssueLabelMoveToTeamLabelsInput!
  ): IssueLabelMoveToTeamLabelsPayload!

  """Updates an label."""
  issueLabelUpdate(
    """The identifier of the label to update."""
    id: String!

    """A partial label object to update."""
    input: IssueLabelUpdateInput!

    """
    Whether to replace all team-specific labels with the same name with this updated workspace label (default: false).
    """
    replaceTeamLabels: Boolean
  ): IssueLabelPayload!

  """Merges multiple issue labels into a single label."""
  issueLabelsMerge(
    """The merge input."""
    input: LabelsMergeInput!
  ): IssueLabelPayload!

  """Creates a new issue relation."""
  issueRelationCreate(
    """The issue relation to create."""
    input: IssueRelationCreateInput!

    """Used by client undo operations. Should not be set directly."""
    overrideCreatedAt: DateTime
  ): IssueRelationPayload!

  """Deletes an issue relation."""
  issueRelationDelete(
    """The identifier of the issue relation to delete."""
    id: String!
  ): DeletePayload!

  """Updates an issue relation."""
  issueRelationUpdate(
    """The identifier of the issue relation to update."""
    id: String!

    """The properties of the issue relation to update."""
    input: IssueRelationUpdateInput!
  ): IssueRelationPayload!

  """
  Adds an issue reminder. Will cause a notification to be sent when the issue reminder time is reached.
  """
  issueReminder(
    """The identifier of the issue to add a reminder for."""
    id: String!

    """The time when a reminder notification will be sent."""
    reminderAt: DateTime!
  ): IssuePayload!

  """Removes a label from an issue."""
  issueRemoveLabel(
    """The identifier of the issue to remove the label from."""
    id: String!

    """The identifier of the label to remove."""
    labelId: String!
  ): IssuePayload!

  """Subscribes a user to an issue."""
  issueSubscribe(
    """The identifier of the issue to subscribe to."""
    id: String!

    """The identifier of the user to subscribe, default is the current user."""
    userId: String
  ): IssuePayload!

  """Unarchives an issue."""
  issueUnarchive(
    """The identifier of the issue to archive."""
    id: String!
  ): IssueArchivePayload!

  """Unsubscribes a user from an issue."""
  issueUnsubscribe(
    """The identifier of the issue to unsubscribe from."""
    id: String!

    """
    The identifier of the user to unsubscribe, default is the current user.
    """
    userId: String
  ): IssuePayload!

  """Updates an issue."""
  issueUpdate(
    """The identifier of the issue to update."""
    id: String!

    """A partial issue object to update the issue with."""
    input: IssueUpdateInput!
  ): IssuePayload!

  """
  [INTERNAL] Connects the organization with a Jira Personal Access Token.
  """
  jiraIntegrationConnect(
    """Jira integration settings."""
    input: JiraConfigurationInput!
  ): IntegrationPayload!

  """Join an organization from onboarding."""
  joinOrganizationFromOnboarding(
    """Organization details for the organization to join."""
    input: JoinOrganizationInput!
  ): CreateOrJoinOrganizationResponse!

  """Leave an organization."""
  leaveOrganization(
    """ID of the organization to leave."""
    organizationId: String!
  ): CreateOrJoinOrganizationResponse!

  """Logout the client."""
  logout(
    """The reason for logging out."""
    reason: String
  ): LogoutResponse!

  """Logout all of user's sessions including the active one."""
  logoutAllSessions(
    """The reason for logging out."""
    reason: String
  ): LogoutResponse!

  """Logout all of user's sessions excluding the current one."""
  logoutOtherSessions(
    """The reason for logging out."""
    reason: String
  ): LogoutResponse!

  """Logout an individual session with its ID."""
  logoutSession(
    """ID of the session to logout."""
    sessionId: String!
  ): LogoutResponse!

  """Archives a notification."""
  notificationArchive(
    """The id of the notification to archive."""
    id: String!
  ): NotificationArchivePayload!

  """Archives a notification and all related notifications."""
  notificationArchiveAll(
    """The type and id of the entity to archive notifications for."""
    input: NotificationEntityInput!
  ): NotificationBatchActionPayload!

  """
  Subscribes to or unsubscribes from a notification category for a given notification channel for the user
  """
  notificationCategoryChannelSubscriptionUpdate(
    """The notification category to subscribe to or unsubscribe from"""
    category: NotificationCategory!

    """
    The notification channel in which to subscribe to or unsubscribe from the category
    """
    channel: NotificationChannel!

    """
    True if the user wants to subscribe, false if the user wants to unsubscribe
    """
    subscribe: Boolean!
  ): UserSettingsPayload!

  """Marks notification and all related notifications as read."""
  notificationMarkReadAll(
    """The type and id of the entity to archive notifications for."""
    input: NotificationEntityInput!

    """The time when notification was marked as read."""
    readAt: DateTime!
  ): NotificationBatchActionPayload!

  """Marks notification and all related notifications as unread."""
  notificationMarkUnreadAll(
    """The type and id of the entity to archive notifications for."""
    input: NotificationEntityInput!
  ): NotificationBatchActionPayload!

  """Snoozes a notification and all related notifications."""
  notificationSnoozeAll(
    """The type and id of the entity to archive notifications for."""
    input: NotificationEntityInput!

    """
    The time until a notification will be snoozed. After that it will appear in the inbox again.
    """
    snoozedUntilAt: DateTime!
  ): NotificationBatchActionPayload!

  """
  Creates a new notification subscription for a cycle, custom view, label, project or team.
  """
  notificationSubscriptionCreate(
    """The subscription object to create."""
    input: NotificationSubscriptionCreateInput!
  ): NotificationSubscriptionPayload!

  """Deletes a notification subscription reference."""
  notificationSubscriptionDelete(
    """The identifier of the notification subscription reference to delete."""
    id: String!
  ): DeletePayload! @deprecated(reason: "Update `notificationSubscription.active` to `false` instead.")

  """Updates a notification subscription."""
  notificationSubscriptionUpdate(
    """The identifier of the notification subscription to update."""
    id: String!

    """
    A partial notification subscription object to update the notification subscription with.
    """
    input: NotificationSubscriptionUpdateInput!
  ): NotificationSubscriptionPayload!

  """Unarchives a notification."""
  notificationUnarchive(
    """The id of the notification to archive."""
    id: String!
  ): NotificationArchivePayload!

  """Unsnoozes a notification and all related notifications."""
  notificationUnsnoozeAll(
    """The type and id of the entity to archive notifications for."""
    input: NotificationEntityInput!

    """The time when the notification was unsnoozed."""
    unsnoozedAt: DateTime!
  ): NotificationBatchActionPayload!

  """Updates a notification."""
  notificationUpdate(
    """The identifier of the notification to update."""
    id: String!

    """A partial notification object to update the notification with."""
    input: NotificationUpdateInput!
  ): NotificationPayload!

  """
  Cancels the deletion of an organization. Administrator privileges required.
  """
  organizationCancelDelete: OrganizationCancelDeletePayload!

  """Delete's an organization. Administrator privileges required."""
  organizationDelete(
    """Information required to delete an organization."""
    input: DeleteOrganizationInput!
  ): OrganizationDeletePayload!

  """
  Get an organization's delete confirmation token. Administrator privileges required.
  """
  organizationDeleteChallenge: OrganizationDeletePayload!

  """[INTERNAL] Verifies a domain claim."""
  organizationDomainClaim(
    """The ID of the organization domain to claim."""
    id: String!
  ): OrganizationDomainSimplePayload!

  """[INTERNAL] Adds a domain to be allowed for an organization."""
  organizationDomainCreate(
    """The organization domain entry to create."""
    input: OrganizationDomainCreateInput!

    """Whether to trigger an email verification flow during domain creation."""
    triggerEmailVerification: Boolean
  ): OrganizationDomainPayload!

  """Deletes a domain."""
  organizationDomainDelete(
    """The identifier of the domain to delete."""
    id: String!
  ): DeletePayload!

  """[INTERNAL] Updates an organization domain settings."""
  organizationDomainUpdate(
    """The identifier of the domain to update."""
    id: String!

    """The organization domain entry to update."""
    input: OrganizationDomainUpdateInput!
  ): OrganizationDomainPayload!

  """[INTERNAL] Verifies a domain to be added to an organization."""
  organizationDomainVerify(
    """The organization domain to verify."""
    input: OrganizationDomainVerificationInput!
  ): OrganizationDomainPayload!

  """Creates a new organization invite."""
  organizationInviteCreate(
    """The organization invite object to create."""
    input: OrganizationInviteCreateInput!
  ): OrganizationInvitePayload!

  """Deletes an organization invite."""
  organizationInviteDelete(
    """The identifier of the organization invite to delete."""
    id: String!
  ): DeletePayload!

  """Updates an organization invite."""
  organizationInviteUpdate(
    """The identifier of the organization invite to update."""
    id: String!

    """The updates to make to the organization invite object."""
    input: OrganizationInviteUpdateInput!
  ): OrganizationInvitePayload!

  """
  [DEPRECATED] Starts a trial for the organization. Administrator privileges required.
  """
  organizationStartTrial: OrganizationStartTrialPayload! @deprecated(reason: "Use organizationStartTrialForPlan")

  """
  Starts a trial for the organization on the specified plan type. Administrator privileges required.
  """
  organizationStartTrialForPlan(
    """Plan details for trial"""
    input: OrganizationStartTrialInput!
  ): OrganizationStartTrialPayload!

  """Updates the user's organization."""
  organizationUpdate(
    """A partial organization object to update the organization with."""
    input: OrganizationUpdateInput!
  ): OrganizationPayload!

  """[INTERNAL] Finish passkey login process."""
  passkeyLoginFinish(
    """Random ID to start passkey login with."""
    authId: String!
    response: JSONObject!
  ): AuthResolverResponse!

  """[INTERNAL] Starts passkey login process."""
  passkeyLoginStart(
    """Random ID to start passkey login with."""
    authId: String!
  ): PasskeyLoginStartResponse!

  """Adds a label to a project."""
  projectAddLabel(
    """The identifier of the project to add the label to."""
    id: String!

    """The identifier of the label to add."""
    labelId: String!
  ): ProjectPayload!

  """Archives a project."""
  projectArchive(
    """
    The identifier of the project to archive. Also the identifier from the URL is accepted.
    """
    id: String!

    """Whether to trash the project."""
    trash: Boolean
  ): ProjectArchivePayload! @deprecated(reason: "Deprecated in favor of projectDelete.")

  """Creates a new project."""
  projectCreate(
    """Whether to connect a Slack channel to the project."""
    connectSlackChannel: Boolean

    """The issue object to create."""
    input: ProjectCreateInput!
  ): ProjectPayload!

  """Deletes (trashes) a project."""
  projectDelete(
    """The identifier of the project to delete."""
    id: String!
  ): ProjectArchivePayload!

  """Creates a new project label."""
  projectLabelCreate(
    """The project label to create."""
    input: ProjectLabelCreateInput!
  ): ProjectLabelPayload!

  """Deletes a project label."""
  projectLabelDelete(
    """The identifier of the label to delete."""
    id: String!
  ): DeletePayload!

  """Updates a project label."""
  projectLabelUpdate(
    """The identifier of the label to update."""
    id: String!

    """A partial label object to update."""
    input: ProjectLabelUpdateInput!
  ): ProjectLabelPayload!

  """Merges multiple project labels into a single label."""
  projectLabelsMerge(
    """The merge input."""
    input: LabelsMergeInput!
  ): ProjectLabelPayload!

  """Creates a new project milestone."""
  projectMilestoneCreate(
    """The project milestone to create."""
    input: ProjectMilestoneCreateInput!
  ): ProjectMilestonePayload!

  """Deletes a project milestone."""
  projectMilestoneDelete(
    """The identifier of the project milestone to delete."""
    id: String!
  ): DeletePayload!

  """
  [Internal] Moves a project milestone to another project, can be called to undo a prior move.
  """
  projectMilestoneMove(
    """The identifier of the project milestone to move."""
    id: String!

    """
    The project to move the milestone to, as well as any additional options need to make a successful move, or undo a previous move.
    """
    input: ProjectMilestoneMoveInput!
  ): ProjectMilestoneMovePayload!

  """Updates a project milestone."""
  projectMilestoneUpdate(
    """
    The identifier of the project milestone to update. Also the identifier from the URL is accepted.
    """
    id: String!

    """A partial object to update the project milestone with."""
    input: ProjectMilestoneUpdateInput!
  ): ProjectMilestonePayload!

  """
  [INTERNAL] Updates all projects currently assigned to to a project status to a new project status.
  """
  projectReassignStatus(
    """The identifier of the new project status to update the projects to."""
    newProjectStatusId: String!

    """
    The identifier of the project status with which projects will be updated.
    """
    originalProjectStatusId: String!
  ): SuccessPayload!

  """Creates a new project relation."""
  projectRelationCreate(
    """The project relation to create."""
    input: ProjectRelationCreateInput!
  ): ProjectRelationPayload!

  """Deletes a project relation."""
  projectRelationDelete(
    """The identifier of the project relation to delete."""
    id: String!
  ): DeletePayload!

  """Updates a project relation."""
  projectRelationUpdate(
    """The identifier of the project relation to update."""
    id: String!

    """The properties of the project relation to update."""
    input: ProjectRelationUpdateInput!
  ): ProjectRelationPayload!

  """Removes a label from a project."""
  projectRemoveLabel(
    """The identifier of the project to remove the label from."""
    id: String!

    """The identifier of the label to remove."""
    labelId: String!
  ): ProjectPayload!

  """Archives a project status."""
  projectStatusArchive(
    """The identifier of the project status to archive."""
    id: String!
  ): ProjectStatusArchivePayload!

  """Creates a new project status."""
  projectStatusCreate(
    """The ProjectStatus object to create."""
    input: ProjectStatusCreateInput!
  ): ProjectStatusPayload!

  """Unarchives a project status."""
  projectStatusUnarchive(
    """The identifier of the project status to unarchive."""
    id: String!
  ): ProjectStatusArchivePayload!

  """Updates a project status."""
  projectStatusUpdate(
    """The identifier of the project status to update."""
    id: String!

    """A partial ProjectStatus object to update the ProjectStatus with."""
    input: ProjectStatusUpdateInput!
  ): ProjectStatusPayload!

  """Unarchives a project."""
  projectUnarchive(
    """
    The identifier of the project to restore. Also the identifier from the URL is accepted.
    """
    id: String!
  ): ProjectArchivePayload!

  """Updates a project."""
  projectUpdate(
    """
    The identifier of the project to update. Also the identifier from the URL is accepted.
    """
    id: String!

    """A partial project object to update the project with."""
    input: ProjectUpdateInput!
  ): ProjectPayload!

  """Archives a project update."""
  projectUpdateArchive(
    """The identifier of the project update to archive."""
    id: String!
  ): ProjectUpdateArchivePayload!

  """Creates a new project update."""
  projectUpdateCreate(
    """Data for the project update to create."""
    input: ProjectUpdateCreateInput!
  ): ProjectUpdatePayload!

  """Deletes a project update."""
  projectUpdateDelete(
    """The identifier of the project update to delete."""
    id: String!
  ): DeletePayload! @deprecated(reason: "Use `projectUpdateArchive` instead.")

  """Unarchives a project update."""
  projectUpdateUnarchive(
    """The identifier of the project update to unarchive."""
    id: String!
  ): ProjectUpdateArchivePayload!

  """Updates a project update."""
  projectUpdateUpdate(
    """The identifier of the project update to update."""
    id: String!

    """A data to update the project update with."""
    input: ProjectUpdateUpdateInput!
  ): ProjectUpdatePayload!

  """Creates a push subscription."""
  pushSubscriptionCreate(
    """The push subscription to create."""
    input: PushSubscriptionCreateInput!
  ): PushSubscriptionPayload!

  """Deletes a push subscription."""
  pushSubscriptionDelete(
    """The identifier of the push subscription to delete."""
    id: String!
  ): PushSubscriptionPayload!

  """Creates a new reaction."""
  reactionCreate(
    """The reaction object to create."""
    input: ReactionCreateInput!
  ): ReactionPayload!

  """Deletes a reaction."""
  reactionDelete(
    """The identifier of the reaction to delete."""
    id: String!
  ): DeletePayload!

  """Manually update Google Sheets data."""
  refreshGoogleSheetsData(
    """The identifier of the Google Sheets integration to update."""
    id: String!

    """The type of export."""
    type: String
  ): IntegrationPayload!

  """Re-send an organization invite."""
  resendOrganizationInvite(
    """The identifier of the organization invite to re-send."""
    id: String!
  ): DeletePayload!

  """Re-send an organization invite tied to an email address."""
  resendOrganizationInviteByEmail(
    """The email address tied to the organization invite to re-send."""
    email: String!
  ): DeletePayload!

  """Archives a roadmap."""
  roadmapArchive(
    """The identifier of the roadmap to archive."""
    id: String!
  ): RoadmapArchivePayload! @deprecated(reason: "Roadmaps are deprecated, use initiatives instead.")

  """Creates a new roadmap."""
  roadmapCreate(
    """The properties of the roadmap to create."""
    input: RoadmapCreateInput!
  ): RoadmapPayload! @deprecated(reason: "Roadmaps are deprecated, use initiatives instead.")

  """Deletes a roadmap."""
  roadmapDelete(
    """The identifier of the roadmap to delete."""
    id: String!
  ): DeletePayload! @deprecated(reason: "Roadmaps are deprecated, use initiatives instead.")

  """Creates a new roadmapToProject join."""
  roadmapToProjectCreate(
    """The properties of the roadmapToProject to create."""
    input: RoadmapToProjectCreateInput!
  ): RoadmapToProjectPayload!

  """Deletes a roadmapToProject."""
  roadmapToProjectDelete(
    """The identifier of the roadmapToProject to delete."""
    id: String!
  ): DeletePayload!

  """Updates a roadmapToProject."""
  roadmapToProjectUpdate(
    """The identifier of the roadmapToProject to update."""
    id: String!

    """The properties of the roadmapToProject to update."""
    input: RoadmapToProjectUpdateInput!
  ): RoadmapToProjectPayload!

  """Unarchives a roadmap."""
  roadmapUnarchive(
    """The identifier of the roadmap to unarchive."""
    id: String!
  ): RoadmapArchivePayload! @deprecated(reason: "Roadmaps are deprecated, use initiatives instead.")

  """Updates a roadmap."""
  roadmapUpdate(
    """The identifier of the roadmap to update."""
    id: String!

    """The properties of the roadmap to update."""
    input: RoadmapUpdateInput!
  ): RoadmapPayload! @deprecated(reason: "Roadmaps are deprecated, use initiatives instead.")

  """
  Authenticates a user account via email and authentication token for SAML.
  """
  samlTokenUserAccountAuth(
    """The data used for token authentication."""
    input: TokenUserAccountAuthInput!
  ): AuthResolverResponse!

  """
  Creates a new team. The user who creates the team will automatically be added as a member to the newly created team.
  """
  teamCreate(
    """The team id to copy settings from, if any."""
    copySettingsFromTeamId: String

    """The team object to create."""
    input: TeamCreateInput!
  ): TeamPayload!

  """Deletes team's cycles data"""
  teamCyclesDelete(
    """The identifier of the team, which cycles will be deleted."""
    id: String!
  ): TeamPayload!

  """Deletes a team."""
  teamDelete(
    """The identifier of the team to delete."""
    id: String!
  ): DeletePayload!

  """Deletes a previously used team key."""
  teamKeyDelete(
    """The identifier of the team key to delete."""
    id: String!
  ): DeletePayload!

  """Creates a new team membership."""
  teamMembershipCreate(
    """The team membership object to create."""
    input: TeamMembershipCreateInput!
  ): TeamMembershipPayload!

  """Deletes a team membership."""
  teamMembershipDelete(
    """Whether to leave the parent teams."""
    alsoLeaveParentTeams: Boolean

    """The identifier of the team membership to delete."""
    id: String!
  ): DeletePayload!

  """Updates a team membership."""
  teamMembershipUpdate(
    """The identifier of the team membership to update."""
    id: String!

    """A partial team membership object to update the team membership with."""
    input: TeamMembershipUpdateInput!
  ): TeamMembershipPayload!

  """Unarchives a team and cancels deletion."""
  teamUnarchive(
    """The identifier of the team to delete."""
    id: String!
  ): TeamArchivePayload!

  """Updates a team."""
  teamUpdate(
    """The identifier of the team to update."""
    id: String!

    """A partial team object to update the team with."""
    input: TeamUpdateInput!

    """
    [INTERNAL] Mapping of existing team entities to those inherited from the parent team
    """
    mapping: InheritanceEntityMapping
  ): TeamPayload!

  """Creates a new template."""
  templateCreate(
    """The template object to create."""
    input: TemplateCreateInput!
  ): TemplatePayload!

  """Deletes a template."""
  templateDelete(
    """The identifier of the template to delete."""
    id: String!
  ): DeletePayload!

  """Updates an existing template."""
  templateUpdate(
    """The identifier of the template."""
    id: String!

    """The properties of the template to update."""
    input: TemplateUpdateInput!
  ): TemplatePayload!

  """Creates a new time schedule."""
  timeScheduleCreate(
    """The properties of the time schedule to create."""
    input: TimeScheduleCreateInput!
  ): TimeSchedulePayload!

  """Deletes a time schedule."""
  timeScheduleDelete(
    """The identifier of the time schedule to delete."""
    id: String!
  ): DeletePayload!

  """Refresh the integration schedule information."""
  timeScheduleRefreshIntegrationSchedule(
    """The identifier of the time schedule to refresh."""
    id: String!
  ): TimeSchedulePayload!

  """Updates a time schedule."""
  timeScheduleUpdate(
    """The identifier of the time schedule to update."""
    id: String!

    """The properties of the time schedule to update."""
    input: TimeScheduleUpdateInput!
  ): TimeSchedulePayload!

  """Upsert an external time schedule."""
  timeScheduleUpsertExternal(
    """The unique identifier of the external schedule."""
    externalId: String!

    """The properties of the time schedule to insert or update."""
    input: TimeScheduleUpdateInput!
  ): TimeSchedulePayload!

  """Creates a new triage responsibility."""
  triageResponsibilityCreate(
    """The properties of the triage responsibility to create."""
    input: TriageResponsibilityCreateInput!
  ): TriageResponsibilityPayload!

  """Deletes a triage responsibility."""
  triageResponsibilityDelete(
    """The identifier of the triage responsibility to delete."""
    id: String!
  ): DeletePayload!

  """Updates an existing triage responsibility."""
  triageResponsibilityUpdate(
    """The identifier of the triage responsibility to update."""
    id: String!

    """The properties of the triage responsibility to update."""
    input: TriageResponsibilityUpdateInput!
  ): TriageResponsibilityPayload!

  """[Internal] Updates existing Slack integration scopes."""
  updateIntegrationSlackScopes(
    """The Slack OAuth code."""
    code: String!

    """The ID of the existing Slack integration"""
    integrationId: String!

    """The Slack OAuth redirect URI."""
    redirectUri: String!
  ): IntegrationPayload!

  """[INTERNAL] Updates the summary of an issue."""
  updateIssueSummary(
    """The identifier of the issue to update."""
    id: String!
  ): IssuePayload!

  """Makes user a regular user. Can only be called by an admin."""
  userDemoteAdmin(
    """The identifier of the user to make a regular user."""
    id: String!
  ): UserAdminPayload!

  """Makes user a guest. Can only be called by an admin."""
  userDemoteMember(
    """The identifier of the user to make a guest."""
    id: String!
  ): UserAdminPayload!

  """Connects the Discord user to this Linear account via OAuth2."""
  userDiscordConnect(
    """The Discord OAuth code."""
    code: String!

    """The Discord OAuth redirect URI."""
    redirectUri: String!
  ): UserPayload!

  """Disconnects the external user from this Linear account."""
  userExternalUserDisconnect(
    """The external service to disconnect."""
    service: String!
  ): UserPayload!

  """Updates a user's settings flag."""
  userFlagUpdate(
    """Settings flag to increment."""
    flag: UserFlagType!

    """Flag operation to perform."""
    operation: UserFlagUpdateOperation!
  ): UserSettingsFlagPayload!

  """Makes user an admin. Can only be called by an admin."""
  userPromoteAdmin(
    """The identifier of the user to make an admin."""
    id: String!
  ): UserAdminPayload!

  """Makes user a regular user. Can only be called by an admin."""
  userPromoteMember(
    """The identifier of the user to make a regular user."""
    id: String!
  ): UserAdminPayload!

  """Resets user's setting flags."""
  userSettingsFlagsReset(
    """The flags to reset. If not provided all flags will be reset."""
    flags: [UserFlagType!]
  ): UserSettingsFlagsResetPayload!

  """Updates the user's settings."""
  userSettingsUpdate(
    """The identifier of the userSettings to update."""
    id: String!

    """A partial notification object to update the settings with."""
    input: UserSettingsUpdateInput!
  ): UserSettingsPayload!

  """Suspends a user. Can only be called by an admin."""
  userSuspend(
    """The identifier of the user to suspend."""
    id: String!
  ): UserAdminPayload!

  """Un-suspends a user. Can only be called by an admin."""
  userUnsuspend(
    """The identifier of the user to unsuspend."""
    id: String!
  ): UserAdminPayload!

  """
  Updates a user. Only available to organization admins and the user themselves.
  """
  userUpdate(
    """
    The identifier of the user to update. Use `me` to reference currently authenticated user.
    """
    id: String!

    """A partial user object to update the user with."""
    input: UserUpdateInput!
  ): UserPayload!

  """Creates a new ViewPreferences object."""
  viewPreferencesCreate(
    """The ViewPreferences object to create."""
    input: ViewPreferencesCreateInput!
  ): ViewPreferencesPayload!

  """Deletes a ViewPreferences."""
  viewPreferencesDelete(
    """The identifier of the ViewPreferences to delete."""
    id: String!
  ): DeletePayload!

  """Updates an existing ViewPreferences object."""
  viewPreferencesUpdate(
    """The identifier of the ViewPreferences object."""
    id: String!

    """The properties of the view preferences."""
    input: ViewPreferencesUpdateInput!
  ): ViewPreferencesPayload!

  """Creates a new webhook."""
  webhookCreate(
    """The webhook object to create."""
    input: WebhookCreateInput!
  ): WebhookPayload!

  """Deletes a Webhook."""
  webhookDelete(
    """The identifier of the Webhook to delete."""
    id: String!
  ): DeletePayload!

  """Updates an existing Webhook."""
  webhookUpdate(
    """The identifier of the Webhook."""
    id: String!

    """The properties of the Webhook."""
    input: WebhookUpdateInput!
  ): WebhookPayload!

  """
  Archives a state. Only states with issues that have all been archived can be archived.
  """
  workflowStateArchive(
    """The identifier of the state to archive."""
    id: String!
  ): WorkflowStateArchivePayload!

  """Creates a new state, adding it to the workflow of a team."""
  workflowStateCreate(
    """The state to create."""
    input: WorkflowStateCreateInput!
  ): WorkflowStatePayload!

  """Updates a state."""
  workflowStateUpdate(
    """The identifier of the state to update."""
    id: String!

    """A partial state object to update."""
    input: WorkflowStateUpdateInput!
  ): WorkflowStatePayload!
}

"""Customer name sorting options."""
input NameSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

interface Node {
  """The unique identifier of the entity."""
  id: ID!
}

"""A notification sent to a user."""
interface Notification implements Entity & Node {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

"""A generic payload return from entity archive mutations."""
type NotificationArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Notification

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type NotificationBatchActionPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The notifications that were updated."""
  notifications: [Notification!]!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The categories of notifications a user can subscribe to."""
enum NotificationCategory {
  appsAndIntegrations
  assignments
  commentsAndReplies
  customers
  documentChanges
  feed
  mentions
  postsAndUpdates
  reactions
  reminders
  reviews
  statusChanges
  subscriptions
  system
  triage
}

"""A user's notification category preferences."""
type NotificationCategoryPreferences {
  """The preferences for notifications about apps and integrations."""
  appsAndIntegrations: NotificationChannelPreferences!

  """The preferences for notifications about assignments."""
  assignments: NotificationChannelPreferences!

  """The preferences for notifications about comments and replies."""
  commentsAndReplies: NotificationChannelPreferences!

  """The preferences for customer notifications."""
  customers: NotificationChannelPreferences!

  """The preferences for notifications about document changes."""
  documentChanges: NotificationChannelPreferences!

  """The preferences for feed summary notifications."""
  feed: NotificationChannelPreferences!

  """The preferences for notifications about mentions."""
  mentions: NotificationChannelPreferences!

  """The preferences for notifications about posts and updates."""
  postsAndUpdates: NotificationChannelPreferences!

  """The preferences for notifications about reactions."""
  reactions: NotificationChannelPreferences!

  """The preferences for notifications about reminders."""
  reminders: NotificationChannelPreferences!

  """The preferences for notifications about reviews."""
  reviews: NotificationChannelPreferences!

  """The preferences for notifications about status changes."""
  statusChanges: NotificationChannelPreferences!

  """The preferences for notifications about subscriptions."""
  subscriptions: NotificationChannelPreferences!

  """The preferences for system notifications."""
  system: NotificationChannelPreferences!

  """The preferences for triage notifications."""
  triage: NotificationChannelPreferences!
}

input NotificationCategoryPreferencesInput {
  """The preferences for notifications about apps and integrations."""
  appsAndIntegrations: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about assignments."""
  assignments: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about comments and replies."""
  commentsAndReplies: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about customers."""
  customers: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about document changes."""
  documentChanges: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about feed summaries."""
  feed: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about mentions."""
  mentions: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about posts and updates."""
  postsAndUpdates: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about reactions."""
  reactions: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about reminders."""
  reminders: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about reviews."""
  reviews: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about status changes."""
  statusChanges: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about subscriptions."""
  subscriptions: PartialNotificationChannelPreferencesInput

  """The preferences for notifications about triage."""
  triage: PartialNotificationChannelPreferencesInput
}

"""The delivery channels a user can receive notifications in."""
enum NotificationChannel {
  desktop
  email
  mobile
  slack
}

"""
A user's notification channel preferences, indicating if a channel is enabled or not
"""
type NotificationChannelPreferences {
  """Whether notifications are currently enabled for desktop."""
  desktop: Boolean!

  """Whether notifications are currently enabled for email."""
  email: Boolean!

  """Whether notifications are currently enabled for mobile."""
  mobile: Boolean!

  """Whether notifications are currently enabled for Slack."""
  slack: Boolean!
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  nodes: [Notification!]!
  pageInfo: PageInfo!
}

"""A user's notification delivery preferences."""
type NotificationDeliveryPreferences {
  """The delivery preferences for the mobile channel."""
  mobile: NotificationDeliveryPreferencesChannel
}

"""A user's notification delivery preferences."""
type NotificationDeliveryPreferencesChannel {
  """
  [DEPRECATED] Whether notifications are enabled for this channel. Use notificationChannelPreferences instead.
  """
  notificationsDisabled: Boolean @deprecated(reason: "This field has been replaced by notificationChannelPreferences")

  """The schedule for notifications on this channel."""
  schedule: NotificationDeliveryPreferencesSchedule
}

input NotificationDeliveryPreferencesChannelInput {
  """
  [DEPRECATED] Whether notifications are enabled for this channel. Use notificationChannelPreferences instead.
  """
  notificationsDisabled: Boolean @deprecated(reason: "This field has been replaced by notificationChannelPreferences")

  """The schedule for notifications on this channel."""
  schedule: NotificationDeliveryPreferencesScheduleInput
}

"""A user's notification delivery schedule for a particular day."""
type NotificationDeliveryPreferencesDay {
  """The time notifications end."""
  end: String

  """The time notifications start."""
  start: String
}

input NotificationDeliveryPreferencesDayInput {
  """The time notifications end."""
  end: String

  """The time notifications start."""
  start: String
}

input NotificationDeliveryPreferencesInput {
  """The delivery preferences for the mobile channel."""
  mobile: NotificationDeliveryPreferencesChannelInput
}

"""A user's notification delivery schedule for a particular day."""
type NotificationDeliveryPreferencesSchedule {
  """Whether the schedule is disabled."""
  disabled: Boolean

  """Delivery preferences for Friday."""
  friday: NotificationDeliveryPreferencesDay!

  """Delivery preferences for Monday."""
  monday: NotificationDeliveryPreferencesDay!

  """Delivery preferences for Saturday."""
  saturday: NotificationDeliveryPreferencesDay!

  """Delivery preferences for Sunday."""
  sunday: NotificationDeliveryPreferencesDay!

  """Delivery preferences for Thursday."""
  thursday: NotificationDeliveryPreferencesDay!

  """Delivery preferences for Tuesday."""
  tuesday: NotificationDeliveryPreferencesDay!

  """Delivery preferences for Wednesday."""
  wednesday: NotificationDeliveryPreferencesDay!
}

input NotificationDeliveryPreferencesScheduleInput {
  """Whether the schedule is disabled."""
  disabled: Boolean

  """Delivery preferences for Friday."""
  friday: NotificationDeliveryPreferencesDayInput!

  """Delivery preferences for Monday."""
  monday: NotificationDeliveryPreferencesDayInput!

  """Delivery preferences for Saturday."""
  saturday: NotificationDeliveryPreferencesDayInput!

  """Delivery preferences for Sunday."""
  sunday: NotificationDeliveryPreferencesDayInput!

  """Delivery preferences for Thursday."""
  thursday: NotificationDeliveryPreferencesDayInput!

  """Delivery preferences for Tuesday."""
  tuesday: NotificationDeliveryPreferencesDayInput!

  """Delivery preferences for Wednesday."""
  wednesday: NotificationDeliveryPreferencesDayInput!
}

type NotificationEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Notification!
}

"""Describes the type and id of the entity to target for notifications."""
input NotificationEntityInput {
  """The id of the notification."""
  id: String

  """The id of the initiative related to the notification."""
  initiativeId: String

  """The id of the initiative update related to the notification."""
  initiativeUpdateId: String

  """The id of the issue related to the notification."""
  issueId: String

  """The id of the OAuth client approval related to the notification."""
  oauthClientApprovalId: String

  """[DEPRECATED] The id of the project related to the notification."""
  projectId: String

  """The id of the project update related to the notification."""
  projectUpdateId: String
}

"""Notification filtering options."""
input NotificationFilter {
  """Compound filters, all of which need to be matched by the notification."""
  and: [NotificationFilter!]

  """Comparator for the archived at date."""
  archivedAt: DateComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Compound filters, one of which need to be matched by the notification."""
  or: [NotificationFilter!]

  """Comparator for the notification type."""
  type: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type NotificationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The notification that was created or updated."""
  notification: Notification!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Notification subscriptions for models."""
interface NotificationSubscription implements Entity & Node {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer associated with the notification subscription."""
  customer: Customer

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

type NotificationSubscriptionConnection {
  edges: [NotificationSubscriptionEdge!]!
  nodes: [NotificationSubscription!]!
  pageInfo: PageInfo!
}

input NotificationSubscriptionCreateInput {
  """Whether the subscription is active."""
  active: Boolean

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The identifier of the custom view to subscribe to."""
  customViewId: String

  """The identifier of the customer to subscribe to."""
  customerId: String

  """The identifier of the cycle to subscribe to."""
  cycleId: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the initiative to subscribe to."""
  initiativeId: String

  """The identifier of the label to subscribe to."""
  labelId: String

  """The types of notifications of the subscription."""
  notificationSubscriptionTypes: [String!]

  """The identifier of the project to subscribe to."""
  projectId: String

  """The identifier of the team to subscribe to."""
  teamId: String

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType

  """The identifier of the user to subscribe to."""
  userId: String
}

type NotificationSubscriptionEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: NotificationSubscription!
}

type NotificationSubscriptionPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The notification subscription that was created or updated."""
  notificationSubscription: NotificationSubscription!

  """Whether the operation was successful."""
  success: Boolean!
}

input NotificationSubscriptionUpdateInput {
  """Whether the subscription is active."""
  active: Boolean

  """The types of notifications of the subscription."""
  notificationSubscriptionTypes: [String!]
}

input NotificationUpdateInput {
  """The id of the project update related to the notification."""
  initiativeUpdateId: String

  """The id of the project update related to the notification."""
  projectUpdateId: String

  """The time when notification was marked as read."""
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime
}

input NotionSettingsInput {
  """The ID of the Notion workspace being connected."""
  workspaceId: String!

  """The name of the Notion workspace being connected."""
  workspaceName: String!
}

"""Comment filtering options."""
input NullableCommentFilter {
  """Compound filters, all of which need to be matched by the comment."""
  and: [NullableCommentFilter!]

  """Comparator for the comment's body."""
  body: StringComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the comment's document content must satisfy."""
  documentContent: NullableDocumentContentFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the comment's issue must satisfy."""
  issue: NullableIssueFilter

  """Filters that the comment's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the comment."""
  or: [NullableCommentFilter!]

  """Filters that the comment parent must satisfy."""
  parent: NullableCommentFilter

  """Filters that the comment's project update must satisfy."""
  projectUpdate: NullableProjectUpdateFilter

  """Filters that the comment's reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Filters that the comment's creator must satisfy."""
  user: UserFilter
}

"""Customer filtering options."""
input NullableCustomerFilter {
  """Compound filters, all of which need to be matched by the customer."""
  and: [NullableCustomerFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the customer's domains."""
  domains: StringArrayComparator

  """Comparator for the customer's external IDs."""
  externalIds: StringArrayComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the customer name."""
  name: StringComparator

  """Filters that the customer's needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the customer."""
  or: [NullableCustomerFilter!]

  """Filters that the customer owner must satisfy."""
  owner: NullableUserFilter

  """Comparator for the customer generated revenue."""
  revenue: NumberComparator

  """Comparator for the customer size."""
  size: NumberComparator

  """Comparator for the customer slack channel ID."""
  slackChannelId: StringComparator

  """Filters that the customer's status must satisfy."""
  status: CustomerStatusFilter

  """Filters that the customer's tier must satisfy."""
  tier: CustomerTierFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Cycle filtering options."""
input NullableCycleFilter {
  """Compound filters, all of which need to be matched by the cycle."""
  and: [NullableCycleFilter!]

  """Comparator for the cycle completed at date."""
  completedAt: DateComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the cycle ends at date."""
  endsAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the filtering active cycle."""
  isActive: BooleanComparator

  """Comparator for the filtering future cycles."""
  isFuture: BooleanComparator

  """
  Comparator for filtering for whether the cycle is currently in cooldown.
  """
  isInCooldown: BooleanComparator

  """Comparator for the filtering next cycle."""
  isNext: BooleanComparator

  """Comparator for the filtering past cycles."""
  isPast: BooleanComparator

  """Comparator for the filtering previous cycle."""
  isPrevious: BooleanComparator

  """Filters that the cycles issues must satisfy."""
  issues: IssueCollectionFilter

  """Comparator for the cycle name."""
  name: StringComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """Comparator for the cycle number."""
  number: NumberComparator

  """Compound filters, one of which need to be matched by the cycle."""
  or: [NullableCycleFilter!]

  """Comparator for the cycle start date."""
  startsAt: DateComparator

  """Filters that the cycles team must satisfy."""
  team: TeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Comparator for optional dates."""
input NullableDateComparator {
  """Equals constraint."""
  eq: DateTimeOrDuration

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: DateTimeOrDuration

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: DateTimeOrDuration

  """In-array constraint."""
  in: [DateTimeOrDuration!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: DateTimeOrDuration

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: DateTimeOrDuration

  """Not-equals constraint."""
  neq: DateTimeOrDuration

  """Not-in-array constraint."""
  nin: [DateTimeOrDuration!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean
}

"""Document content filtering options."""
input NullableDocumentContentFilter {
  """Compound filters, all of which need to be matched by the user."""
  and: [NullableDocumentContentFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the document content document must satisfy."""
  document: DocumentFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the user."""
  or: [NullableDocumentContentFilter!]

  """Filters that the document content project must satisfy."""
  project: ProjectFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Nullable comparator for optional durations."""
input NullableDurationComparator {
  """Equals constraint."""
  eq: Duration

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: Duration

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: Duration

  """In-array constraint."""
  in: [Duration!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: Duration

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: Duration

  """Not-equals constraint."""
  neq: Duration

  """Not-in-array constraint."""
  nin: [Duration!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean
}

"""Issue filtering options."""
input NullableIssueFilter {
  """Comparator for the issues added to cycle at date."""
  addedToCycleAt: NullableDateComparator

  """Comparator for the period when issue was added to a cycle."""
  addedToCyclePeriod: CyclePeriodComparator

  """
  [Internal] Age (created -> now) comparator, defined if the issue is still open.
  """
  ageTime: NullableDurationComparator

  """Compound filters, all of which need to be matched by the issue."""
  and: [NullableIssueFilter!]

  """Comparator for the issues archived at date."""
  archivedAt: NullableDateComparator

  """Filters that the issues assignee must satisfy."""
  assignee: NullableUserFilter

  """Filters that the issues attachments must satisfy."""
  attachments: AttachmentCollectionFilter

  """Comparator for the issues auto archived at date."""
  autoArchivedAt: NullableDateComparator

  """Comparator for the issues auto closed at date."""
  autoClosedAt: NullableDateComparator

  """Comparator for the issues canceled at date."""
  canceledAt: NullableDateComparator

  """Filters that the child issues must satisfy."""
  children: IssueCollectionFilter

  """Filters that the issues comments must satisfy."""
  comments: CommentCollectionFilter

  """Comparator for the issues completed at date."""
  completedAt: NullableDateComparator

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the issues creator must satisfy."""
  creator: NullableUserFilter

  """Count of customers"""
  customerCount: NumberComparator

  """Count of important customers"""
  customerImportantCount: NumberComparator

  """Filters that the issues cycle must satisfy."""
  cycle: NullableCycleFilter

  """[Internal] Cycle time (started -> completed) comparator."""
  cycleTime: NullableDurationComparator

  """Filters that the issue's delegated agent must satisfy."""
  delegate: NullableUserFilter

  """Comparator for the issues description."""
  description: NullableStringComparator

  """Comparator for the issues due date."""
  dueDate: NullableTimelessDateComparator

  """Comparator for the issues estimate."""
  estimate: EstimateComparator

  """Comparator for filtering issues which are blocked."""
  hasBlockedByRelations: RelationExistsComparator

  """Comparator for filtering issues which are blocking."""
  hasBlockingRelations: RelationExistsComparator

  """Comparator for filtering issues which are duplicates."""
  hasDuplicateRelations: RelationExistsComparator

  """Comparator for filtering issues with relations."""
  hasRelatedRelations: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested assignees.
  """
  hasSuggestedAssignees: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested labels.
  """
  hasSuggestedLabels: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested projects.
  """
  hasSuggestedProjects: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested related issues.
  """
  hasSuggestedRelatedIssues: RelationExistsComparator

  """
  [Internal] Comparator for filtering issues which have suggested similar issues.
  """
  hasSuggestedSimilarIssues: RelationExistsComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that issue labels must satisfy."""
  labels: IssueLabelCollectionFilter

  """Filters that the last applied template must satisfy."""
  lastAppliedTemplate: NullableTemplateFilter

  """[Internal] Lead time (created -> completed) comparator."""
  leadTime: NullableDurationComparator

  """Filters that the issue's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Filter based on the existence of the relation."""
  null: Boolean

  """Comparator for the issues number."""
  number: NumberComparator

  """Compound filters, one of which need to be matched by the issue."""
  or: [NullableIssueFilter!]

  """Filters that the issue parent must satisfy."""
  parent: NullableIssueFilter

  """Comparator for the issues priority."""
  priority: NullableNumberComparator

  """Filters that the issues project must satisfy."""
  project: NullableProjectFilter

  """Filters that the issues project milestone must satisfy."""
  projectMilestone: NullableProjectMilestoneFilter

  """Filters that the issues reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """[ALPHA] Filters that the recurring issue template must satisfy."""
  recurringIssueTemplate: NullableTemplateFilter

  """[Internal] Comparator for the issues content."""
  searchableContent: ContentComparator

  """Comparator for the issues sla status."""
  slaStatus: SlaStatusComparator

  """Filters that the issues snoozer must satisfy."""
  snoozedBy: NullableUserFilter

  """Comparator for the issues snoozed until date."""
  snoozedUntilAt: NullableDateComparator

  """Filters that the source must satisfy."""
  sourceMetadata: SourceMetadataComparator

  """Comparator for the issues started at date."""
  startedAt: NullableDateComparator

  """Filters that the issues state must satisfy."""
  state: WorkflowStateFilter

  """Filters that issue subscribers must satisfy."""
  subscribers: UserCollectionFilter

  """Filters that the issues team must satisfy."""
  team: TeamFilter

  """Comparator for the issues title."""
  title: StringComparator

  """[Internal] Triage time (entered triaged -> triaged) comparator."""
  triageTime: NullableDurationComparator

  """Comparator for the issues triaged at date."""
  triagedAt: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Comparator for optional numbers."""
input NullableNumberComparator {
  """Equals constraint."""
  eq: Float

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: Float

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: Float

  """In-array constraint."""
  in: [Float!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: Float

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: Float

  """Not-equals constraint."""
  neq: Float

  """Not-in-array constraint."""
  nin: [Float!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean
}

"""Project filtering options."""
input NullableProjectFilter {
  """Filters that the project's team must satisfy."""
  accessibleTeams: TeamCollectionFilter

  """
  [ALPHA] Comparator for the project activity type: buzzin, active, some, none
  """
  activityType: StringComparator

  """Compound filters, all of which need to be matched by the project."""
  and: [NullableProjectFilter!]

  """Comparator for the project cancelation date."""
  canceledAt: NullableDateComparator

  """Comparator for the project completion date."""
  completedAt: NullableDateComparator

  """Filters that the project's completed milestones must satisfy."""
  completedProjectMilestones: ProjectMilestoneCollectionFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the projects creator must satisfy."""
  creator: UserFilter

  """Count of customers"""
  customerCount: NumberComparator

  """Count of important customers"""
  customerImportantCount: NumberComparator

  """Comparator for filtering projects which are blocked."""
  hasBlockedByRelations: RelationExistsComparator

  """Comparator for filtering projects which are blocking."""
  hasBlockingRelations: RelationExistsComparator

  """
  [Deprecated] Comparator for filtering projects which this is depended on by.
  """
  hasDependedOnByRelations: RelationExistsComparator

  """[Deprecated]Comparator for filtering projects which this depends on."""
  hasDependsOnRelations: RelationExistsComparator

  """Comparator for filtering projects with relations."""
  hasRelatedRelations: RelationExistsComparator

  """Comparator for filtering projects with violated dependencies."""
  hasViolatedRelations: RelationExistsComparator

  """Comparator for the project health: onTrack, atRisk, offTrack"""
  health: StringComparator

  """
  Comparator for the project health (with age): onTrack, atRisk, offTrack, outdated, noUpdate
  """
  healthWithAge: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the projects initiatives must satisfy."""
  initiatives: InitiativeCollectionFilter

  """Filters that the projects issues must satisfy."""
  issues: IssueCollectionFilter

  """Filters that project labels must satisfy."""
  labels: ProjectLabelCollectionFilter

  """Filters that the last applied template must satisfy."""
  lastAppliedTemplate: NullableTemplateFilter

  """Filters that the projects lead must satisfy."""
  lead: NullableUserFilter

  """Filters that the projects members must satisfy."""
  members: UserCollectionFilter

  """Comparator for the project name."""
  name: StringComparator

  """Filters that the project's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Filters that the project's next milestone must satisfy."""
  nextProjectMilestone: ProjectMilestoneFilter

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the project."""
  or: [NullableProjectFilter!]

  """Comparator for the projects priority."""
  priority: NullableNumberComparator

  """Filters that the project's milestones must satisfy."""
  projectMilestones: ProjectMilestoneCollectionFilter

  """Comparator for the project updates."""
  projectUpdates: ProjectUpdatesCollectionFilter

  """Filters that the projects roadmaps must satisfy."""
  roadmaps: RoadmapCollectionFilter

  """[Internal] Comparator for the project's content."""
  searchableContent: ContentComparator

  """Comparator for the project slug ID."""
  slugId: StringComparator

  """Comparator for the project start date."""
  startDate: NullableDateComparator

  """[DEPRECATED] Comparator for the project state."""
  state: StringComparator

  """Filters that the project's status must satisfy."""
  status: ProjectStatusFilter

  """Comparator for the project target date."""
  targetDate: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Project milestone filtering options."""
input NullableProjectMilestoneFilter {
  """
  Compound filters, all of which need to be matched by the project milestone.
  """
  and: [NullableProjectMilestoneFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the project milestone name."""
  name: NullableStringComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """
  Compound filters, one of which need to be matched by the project milestone.
  """
  or: [NullableProjectMilestoneFilter!]

  """Comparator for the project milestone target date."""
  targetDate: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Nullable project update filtering options."""
input NullableProjectUpdateFilter {
  """
  Compound filters, all of which need to be matched by the project update.
  """
  and: [NullableProjectUpdateFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """
  Compound filters, one of which need to be matched by the project update.
  """
  or: [NullableProjectUpdateFilter!]

  """Filters that the project update project must satisfy."""
  project: ProjectFilter

  """Filters that the project updates reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Filters that the project update creator must satisfy."""
  user: UserFilter
}

"""Comparator for optional strings."""
input NullableStringComparator {
  """Contains constraint. Matches any values that contain the given string."""
  contains: String

  """
  Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
  """
  containsIgnoreCase: String

  """
  Contains case and accent insensitive constraint. Matches any values that contain the given string case and accent insensitive.
  """
  containsIgnoreCaseAndAccent: String

  """
  Ends with constraint. Matches any values that end with the given string.
  """
  endsWith: String

  """Equals constraint."""
  eq: String

  """
  Equals case insensitive. Matches any values that matches the given string case insensitive.
  """
  eqIgnoreCase: String

  """In-array constraint."""
  in: [String!]

  """Not-equals constraint."""
  neq: String

  """
  Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
  """
  neqIgnoreCase: String

  """Not-in-array constraint."""
  nin: [String!]

  """
  Doesn't contain constraint. Matches any values that don't contain the given string.
  """
  notContains: String

  """
  Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
  """
  notContainsIgnoreCase: String

  """
  Doesn't end with constraint. Matches any values that don't end with the given string.
  """
  notEndsWith: String

  """
  Doesn't start with constraint. Matches any values that don't start with the given string.
  """
  notStartsWith: String

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean

  """
  Starts with constraint. Matches any values that start with the given string.
  """
  startsWith: String

  """
  Starts with case insensitive constraint. Matches any values that start with the given string.
  """
  startsWithIgnoreCase: String
}

"""Team filtering options."""
input NullableTeamFilter {
  """Compound filters, all of which need to be matched by the team."""
  and: [NullableTeamFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the team description."""
  description: NullableStringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the teams issues must satisfy."""
  issues: IssueCollectionFilter

  """Comparator for the team key."""
  key: StringComparator

  """Comparator for the team name."""
  name: StringComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the team."""
  or: [NullableTeamFilter!]

  """Filters that the teams parent must satisfy."""
  parent: NullableTeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Template filtering options."""
input NullableTemplateFilter {
  """Compound filters, all of which need to be matched by the template."""
  and: [NullableTemplateFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the template's name."""
  name: StringComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the template."""
  or: [NullableTemplateFilter!]

  """Comparator for the template's type."""
  type: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Comparator for optional timeless dates."""
input NullableTimelessDateComparator {
  """Equals constraint."""
  eq: TimelessDateOrDuration

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: TimelessDateOrDuration

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: TimelessDateOrDuration

  """In-array constraint."""
  in: [TimelessDateOrDuration!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: TimelessDateOrDuration

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: TimelessDateOrDuration

  """Not-equals constraint."""
  neq: TimelessDateOrDuration

  """Not-in-array constraint."""
  nin: [TimelessDateOrDuration!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean
}

"""User filtering options."""
input NullableUserFilter {
  """Comparator for the user's activity status."""
  active: BooleanComparator

  """Comparator for the user's admin status."""
  admin: BooleanComparator

  """Compound filters, all of which need to be matched by the user."""
  and: [NullableUserFilter!]

  """Comparator for the user's app status."""
  app: BooleanComparator

  """Filters that the users assigned issues must satisfy."""
  assignedIssues: IssueCollectionFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the user's display name."""
  displayName: StringComparator

  """Comparator for the user's email."""
  email: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the user's invited status."""
  invited: BooleanComparator

  """
  Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
  """
  isMe: BooleanComparator

  """Comparator for the user's name."""
  name: StringComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the user."""
  or: [NullableUserFilter!]

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Comparator for numbers."""
input NumberComparator {
  """Equals constraint."""
  eq: Float

  """
  Greater-than constraint. Matches any values that are greater than the given value.
  """
  gt: Float

  """
  Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value.
  """
  gte: Float

  """In-array constraint."""
  in: [Float!]

  """
  Less-than constraint. Matches any values that are less than the given value.
  """
  lt: Float

  """
  Less-than-or-equal constraint. Matches any values that are less than or equal to the given value.
  """
  lte: Float

  """Not-equals constraint."""
  neq: Float

  """Not-in-array constraint."""
  nin: [Float!]
}

"""
The different requests statuses possible for an OAuth client approval request.
"""
enum OAuthClientApprovalStatus {
  approved
  denied
  requested
}

"""
Request to install OAuth clients on organizations and the response to the request.
"""
type OauthClientApproval implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The reason the request for the OAuth client approval was denied."""
  denyReason: String

  """The unique identifier of the entity."""
  id: ID!

  """The uuid of the OAuth client being requested for installation."""
  oauthClientId: String!

  """The reason the person wants to install this OAuth client."""
  requestReason: String

  """The person who requested installing the OAuth client."""
  requesterId: String!

  """The person who responded to the request to install the OAuth client."""
  responderId: String

  """The scopes the app has requested."""
  scopes: [String!]!

  """The status for the OAuth client approval request."""
  status: OAuthClientApprovalStatus!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""An oauth client approval related notification."""
type OauthClientApprovalNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """The OAuth client approval request related to the notification."""
  oauthClientApproval: OauthClientApproval!

  """Related OAuth client approval request ID."""
  oauthClientApprovalId: String!

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

input OnboardingCustomerSurvey {
  companyRole: String
  companySize: String
}

input OpsgenieInput {
  """The date when the Opsgenie API failed with an unauthorized error."""
  apiFailedWithUnauthorizedErrorAt: DateTime
}

"""
An organization. Organizations are root-level objects that contain user accounts and teams.
"""
type Organization implements Node {
  """[INTERNAL] Whether the organization has enabled the AI add-on."""
  aiAddonEnabled: Boolean!

  """Whether member users are allowed to send invites."""
  allowMembersToInvite: Boolean

  """Allowed authentication providers, empty array means all are allowed."""
  allowedAuthServices: [String!]!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Number of issues in the organization."""
  createdIssueCount: Int!

  """Number of customers in the organization."""
  customerCount: Int!

  """Configuration settings for the Customers feature."""
  customersConfiguration: JSONObject!

  """Whether the organization is using Customers."""
  customersEnabled: Boolean!

  """Default schedule for how often feed summaries are generated."""
  defaultFeedSummarySchedule: FeedSummarySchedule

  """The time at which deletion of the organization was requested."""
  deletionRequestedAt: DateTime

  """[Internal] Facets associated with the organization."""
  facets: [Facet!]!

  """Whether the organization has enabled the feed feature."""
  feedEnabled: Boolean!

  """The month at which the fiscal year starts. Defaults to January (0)."""
  fiscalYearStartMonth: Float!

  """
  How git branches are formatted. If null, default formatting will be used.
  """
  gitBranchFormat: String

  """
  Whether the Git integration linkback messages should be sent to private repositories.
  """
  gitLinkbackMessagesEnabled: Boolean!

  """
  Whether the Git integration linkback messages should be sent to public repositories.
  """
  gitPublicLinkbackMessagesEnabled: Boolean!

  """The unique identifier of the entity."""
  id: ID!

  """
  The n-weekly frequency at which to prompt for initiative updates. When not set, reminders are off.
  """
  initiativeUpdateReminderFrequencyInWeeks: Float

  """The day at which to prompt for initiative updates."""
  initiativeUpdateRemindersDay: Day!

  """The hour at which to prompt for initiative updates."""
  initiativeUpdateRemindersHour: Float!

  """Integrations associated with the organization."""
  integrations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IntegrationConnection!

  """IP restriction configurations."""
  ipRestrictions: [OrganizationIpRestriction!]

  """Labels associated with the organization."""
  labels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issue labels."""
    filter: IssueLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """The organization's logo URL."""
  logoUrl: String

  """The organization's name."""
  name: String!

  """Rolling 30-day total upload volume for the organization, in megabytes."""
  periodUploadVolume: Float!

  """
  Previously used URL keys for the organization (last 3 are kept and redirected).
  """
  previousUrlKeys: [String!]!

  """Project labels associated with the organization."""
  projectLabels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned project labels."""
    filter: ProjectLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectLabelConnection!

  """The organization's project statuses."""
  projectStatuses: [ProjectStatus!]!

  """
  The n-weekly frequency at which to prompt for project updates. When not set, reminders are off.
  """
  projectUpdateReminderFrequencyInWeeks: Float

  """The day at which to prompt for project updates."""
  projectUpdateRemindersDay: Day!

  """The hour at which to prompt for project updates."""
  projectUpdateRemindersHour: Float!

  """[DEPRECATED] The frequency at which to prompt for project updates."""
  projectUpdatesReminderFrequency: ProjectUpdateReminderFrequency! @deprecated(reason: "Use organization.projectUpdatesReminderFrequencyInWeeks instead")

  """The feature release channel the organization belongs to."""
  releaseChannel: ReleaseChannel!

  """
  Whether workspace label creation, update, and deletion is restricted to admins.
  """
  restrictLabelManagementToAdmins: Boolean

  """Whether team creation is restricted to admins."""
  restrictTeamCreationToAdmins: Boolean

  """Whether the organization is using a roadmap."""
  roadmapEnabled: Boolean!

  """Whether SAML authentication is enabled for organization."""
  samlEnabled: Boolean!

  """[INTERNAL] SAML settings."""
  samlSettings: JSONObject

  """Whether SCIM provisioning is enabled for organization."""
  scimEnabled: Boolean!

  """[INTERNAL] SCIM settings."""
  scimSettings: JSONObject

  """[DEPRECATED] Which day count to use for SLA calculations."""
  slaDayCount: SLADayCountType! @deprecated(reason: "No longer in use")

  """The organization's subscription to a paid plan."""
  subscription: PaidSubscription

  """Teams associated with the organization."""
  teams(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned teams."""
    filter: TeamFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """Templates associated with the organization."""
  templates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned templates."""
    filter: NullableTemplateFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TemplateConnection!

  """[ALPHA] Theme settings for the organization."""
  themeSettings: JSONObject

  """The time at which the trial will end."""
  trialEndsAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The organization's unique URL key."""
  urlKey: String!

  """Number of active users in the organization."""
  userCount: Int!

  """Users associated with the organization."""
  users(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """[Internal] The list of working days. Sunday is 0, Monday is 1, etc."""
  workingDays: [Float!]!
}

type OrganizationAcceptedOrExpiredInviteDetailsPayload {
  """The status of the invite."""
  status: OrganizationInviteStatus!
}

type OrganizationCancelDeletePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

type OrganizationDeletePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""Defines the use of a domain by an organization."""
type OrganizationDomain implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """What type of auth is the domain used for."""
  authType: OrganizationDomainAuthType!

  """
  Whether the domains was claimed by the organization through DNS verification.
  """
  claimed: Boolean

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who added the domain."""
  creator: User

  """Prevent users with this domain to create new workspaces."""
  disableOrganizationCreation: Boolean

  """The unique identifier of the entity."""
  id: ID!

  """The identity provider the domain belongs to."""
  identityProvider: IdentityProvider

  """Domain name."""
  name: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """E-mail used to verify this domain."""
  verificationEmail: String

  """Is this domain verified."""
  verified: Boolean!
}

"""What type of auth is the domain used for."""
enum OrganizationDomainAuthType {
  general
  saml
}

"""[INTERNAL] Domain claim request response."""
type OrganizationDomainClaimPayload {
  """String to put into DNS for verification."""
  verificationString: String!
}

input OrganizationDomainCreateInput {
  """The authentication type this domain is for."""
  authType: String = "general"

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identity provider to which to add the domain."""
  identityProviderId: String

  """The domain name to add."""
  name: String!

  """The email address to which to send the verification code."""
  verificationEmail: String
}

"""[INTERNAL] Organization domain operation response."""
type OrganizationDomainPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The organization domain that was created or updated."""
  organizationDomain: OrganizationDomain!

  """Whether the operation was successful."""
  success: Boolean!
}

"""[INTERNAL] Organization domain operation response."""
type OrganizationDomainSimplePayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input OrganizationDomainUpdateInput {
  """
  Prevent users with this domain to create new workspaces. Only allowed to set on claimed domains!
  """
  disableOrganizationCreation: Boolean
}

input OrganizationDomainVerificationInput {
  """The identifier in UUID v4 format of the domain being verified."""
  organizationDomainId: String!

  """The verification code sent via email."""
  verificationCode: String!
}

type OrganizationExistsPayload {
  """Whether the organization exists."""
  exists: Boolean!

  """Whether the operation was successful."""
  success: Boolean!
}

"""An invitation to the organization that has been sent via email."""
type OrganizationInvite implements Node {
  """
  The time at which the invite was accepted. Null, if the invite hasn't been accepted.
  """
  acceptedAt: DateTime

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The invitees email address."""
  email: String!

  """
  The time at which the invite will be expiring. Null, if the invite shouldn't expire.
  """
  expiresAt: DateTime

  """The invite was sent to external address."""
  external: Boolean!

  """The unique identifier of the entity."""
  id: ID!

  """
  The user who has accepted the invite. Null, if the invite hasn't been accepted.
  """
  invitee: User

  """The user who created the invitation."""
  inviter: User!

  """Extra metadata associated with the organization invite."""
  metadata: JSONObject

  """The organization that the invite is associated with."""
  organization: Organization!

  """The user role that the invitee will receive upon accepting the invite."""
  role: UserRoleType!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type OrganizationInviteConnection {
  edges: [OrganizationInviteEdge!]!
  nodes: [OrganizationInvite!]!
  pageInfo: PageInfo!
}

input OrganizationInviteCreateInput {
  """The email of the invitee."""
  email: String!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """[INTERNAL] Optional metadata about the invite."""
  metadata: JSONObject

  """What user role the invite should grant."""
  role: UserRoleType = user

  """The teams that the user has been invited to."""
  teamIds: [String!]
}

union OrganizationInviteDetailsPayload = OrganizationAcceptedOrExpiredInviteDetailsPayload | OrganizationInviteFullDetailsPayload

type OrganizationInviteEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: OrganizationInvite!
}

type OrganizationInviteFullDetailsPayload {
  """Whether the invite has already been accepted."""
  accepted: Boolean!

  """Allowed authentication providers, empty array means all are allowed."""
  allowedAuthServices: [String!]!

  """When the invite was created."""
  createdAt: DateTime!

  """The email of the invitee."""
  email: String!

  """Whether the invite has expired."""
  expired: Boolean!

  """The name of the inviter."""
  inviter: String!

  """ID of the workspace the invite is for."""
  organizationId: String!

  """URL of the workspace logo the invite is for."""
  organizationLogoUrl: String

  """Name of the workspace the invite is for."""
  organizationName: String!

  """What user role the invite should grant."""
  role: UserRoleType!

  """The status of the invite."""
  status: OrganizationInviteStatus!
}

type OrganizationInvitePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The organization invite that was created or updated."""
  organizationInvite: OrganizationInvite!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The different statuses possible for an organization invite."""
enum OrganizationInviteStatus {
  accepted
  expired
  pending
}

input OrganizationInviteUpdateInput {
  """The teams that the user has been invited to."""
  teamIds: [String!]!
}

type OrganizationIpRestriction {
  """Optional restriction description."""
  description: String

  """Whether the restriction is enabled."""
  enabled: Boolean!

  """IP range in CIDR format."""
  range: String!

  """Restriction type."""
  type: String!
}

"""[INTERNAL] Organization IP restriction configuration."""
input OrganizationIpRestrictionInput {
  """Optional restriction description."""
  description: String

  """Whether the restriction is enabled."""
  enabled: Boolean!

  """IP range in CIDR format."""
  range: String!

  """Restriction type."""
  type: String!
}

type OrganizationMeta {
  """Allowed authentication providers, empty array means all are allowed."""
  allowedAuthServices: [String!]!

  """The region the organization is hosted in."""
  region: String!
}

type OrganizationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The organization that was created or updated."""
  organization: Organization

  """Whether the operation was successful."""
  success: Boolean!
}

input OrganizationStartTrialInput {
  """The plan type to trial."""
  planType: String!
}

type OrganizationStartTrialPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

input OrganizationUpdateInput {
  """[INTERNAL] Whether the organization has enabled the AI add-on."""
  aiAddonEnabled: Boolean

  """[INTERNAL] Whether the organization has opted in to AI telemetry."""
  aiTelemetryEnabled: Boolean

  """Whether member users are allowed to send invites."""
  allowMembersToInvite: Boolean

  """List of services that are allowed to be used for login."""
  allowedAuthServices: [String!]

  """[INTERNAL] Configuration settings for the Customers feature."""
  customersConfiguration: JSONObject

  """[INTERNAL] Whether the organization is using customers."""
  customersEnabled: Boolean

  """Default schedule for how often feed summaries are generated."""
  defaultFeedSummarySchedule: FeedSummarySchedule

  """Whether the organization has enabled the feed feature."""
  feedEnabled: Boolean

  """The month at which the fiscal year starts."""
  fiscalYearStartMonth: Float

  """
  How git branches are formatted. If null, default formatting will be used.
  """
  gitBranchFormat: String

  """
  Whether the Git integration linkback messages should be sent for private repositories.
  """
  gitLinkbackMessagesEnabled: Boolean

  """
  Whether the Git integration linkback messages should be sent for public repositories.
  """
  gitPublicLinkbackMessagesEnabled: Boolean

  """
  [ALPHA] The n-weekly frequency at which to prompt for initiative updates.
  """
  initiativeUpdateReminderFrequencyInWeeks: Float

  """[ALPHA] The day at which initiative updates are sent."""
  initiativeUpdateRemindersDay: Day

  """[ALPHA] The hour at which initiative updates are sent."""
  initiativeUpdateRemindersHour: Float

  """
  IP restriction configurations controlling allowed access the workspace.
  """
  ipRestrictions: [OrganizationIpRestrictionInput!]

  """The logo of the organization."""
  logoUrl: String

  """The name of the organization."""
  name: String

  """
  Whether the organization has opted for having to approve all OAuth applications for install.
  """
  oauthAppReview: Boolean

  """[INTERNAL] Whether the organization has enabled the member API keys."""
  personalApiKeysEnabled: Boolean

  """The n-weekly frequency at which to prompt for project updates."""
  projectUpdateReminderFrequencyInWeeks: Float

  """The day at which project updates are sent."""
  projectUpdateRemindersDay: Day

  """The hour at which project updates are sent."""
  projectUpdateRemindersHour: Float

  """
  Whether the organization has opted for reduced customer support attachment information.
  """
  reducedPersonalInformation: Boolean

  """Whether agent invocation is restricted to full workspace members."""
  restrictAgentInvocationToMembers: Boolean

  """Whether label creation is restricted to admins."""
  restrictLabelManagementToAdmins: Boolean

  """Whether team creation is restricted to admins."""
  restrictTeamCreationToAdmins: Boolean

  """Whether the organization is using roadmap."""
  roadmapEnabled: Boolean

  """Internal. Whether SLAs have been enabled for the organization."""
  slaEnabled: Boolean

  """[ALPHA] Theme settings for the organization."""
  themeSettings: JSONObject

  """The URL key of the organization."""
  urlKey: String

  """[Internal] The list of working days. Sunday is 0, Monday is 1, etc."""
  workingDays: [Float!]
}

"""Customer owner sorting options."""
input OwnerSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

type PageInfo {
  """Cursor representing the last result in the paginated results."""
  endCursor: String

  """Indicates if there are more results when paginating forward."""
  hasNextPage: Boolean!

  """Indicates if there are more results when paginating backward."""
  hasPreviousPage: Boolean!

  """Cursor representing the first result in the paginated results."""
  startCursor: String
}

input PagerDutyInput {
  """The date when the PagerDuty API failed with an unauthorized error."""
  apiFailedWithUnauthorizedErrorAt: DateTime
}

"""How to treat NULL values, whether they should appear first or last"""
enum PaginationNulls {
  first
  last
}

"""By which field should the pagination order by"""
enum PaginationOrderBy {
  createdAt
  updatedAt
}

"""Whether to sort in ascending or descending order"""
enum PaginationSortOrder {
  Ascending
  Descending
}

"""The paid subscription of an organization."""
type PaidSubscription implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The date the subscription is scheduled to be canceled, if any."""
  cancelAt: DateTime

  """The date the subscription was canceled, if any."""
  canceledAt: DateTime

  """
  The collection method for this subscription, either automatically charged or invoiced.
  """
  collectionMethod: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The creator of the subscription."""
  creator: User

  """The unique identifier of the entity."""
  id: ID!

  """The date the subscription will be billed next."""
  nextBillingAt: DateTime

  """The organization that the subscription is associated with."""
  organization: Organization!

  """The subscription type of a pending change. Null if no change pending."""
  pendingChangeType: String

  """The number of seats in the subscription."""
  seats: Float!

  """The maximum number of seats that will be billed in the subscription."""
  seatsMaximum: Float

  """The minimum number of seats that will be billed in the subscription."""
  seatsMinimum: Float

  """The subscription type."""
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

input PartialNotificationChannelPreferencesInput {
  """Whether notifications are currently enabled for desktop."""
  desktop: Boolean

  """Whether notifications are currently enabled for email."""
  email: Boolean

  """Whether notifications are currently enabled for mobile."""
  mobile: Boolean

  """Whether notifications are currently enabled for Slack."""
  slack: Boolean
}

type PasskeyLoginStartResponse {
  options: JSONObject!
  success: Boolean!
}

"""[Internal] A generic post."""
type Post implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The update content summarized for audio consumption."""
  audioSummary: String

  """The update content in markdown format."""
  body: String!

  """[Internal] The content of the post as a Prosemirror document."""
  bodyData: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who wrote the post."""
  creator: User

  """The time the post was edited."""
  editedAt: DateTime

  """The log id of the ai response."""
  evalLogId: String

  """Schedule used to create a post summary."""
  feedSummaryScheduleAtCreate: FeedSummarySchedule

  """The unique identifier of the entity."""
  id: ID!

  """Emoji reaction summary, grouped by emoji type."""
  reactionData: JSONObject!

  """The post's unique URL slug."""
  slugId: String!

  """The team that the post is associated with."""
  team: Team

  """The post's title."""
  title: String

  """A URL of the TTL (text-to-language) for the body."""
  ttlUrl: String

  """The type of the post."""
  type: PostType

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user that the post is associated with."""
  user: User

  """[Internal] The written update data used to compose the written post."""
  writtenSummaryData: JSONObject
}

"""A post related notification."""
type PostNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """
  Related comment ID. Null if the notification is not related to a comment.
  """
  commentId: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """
  Related parent comment ID. Null if the notification is not related to a comment.
  """
  parentCommentId: String

  """Related post ID."""
  postId: String!

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """Name of the reaction emoji related to the notification."""
  reactionEmoji: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

"""Type of Post"""
enum PostType {
  summary
  update
}

"""Issue priority sorting options."""
input PrioritySort {
  """Whether to consider no priority as the highest or lowest priority"""
  noPriorityFirst: Boolean = false

  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""
[Internal] The scope of product intelligence suggestion data for a team.
"""
enum ProductIntelligenceScope {
  none
  team
  teamHierarchy
  workspace
}

"""A project."""
type Project implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The time at which the project was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """The time at which the project was moved into canceled state."""
  canceledAt: DateTime

  """The project's color."""
  color: String!

  """Comments associated with the project overview."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The time at which the project was moved into completed state."""
  completedAt: DateTime

  """The number of completed issues in the project after each week."""
  completedIssueCountHistory: [Float!]!

  """The number of completed estimation points after each week."""
  completedScopeHistory: [Float!]!

  """The project's content in markdown format."""
  content: String

  """[Internal] The project's content as YJS state."""
  contentState: String

  """The project was created based on this issue."""
  convertedFromIssue: Issue

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the project."""
  creator: User

  """[INTERNAL] The current progress of the project."""
  currentProgress: JSONObject!

  """The project's description."""
  description: String!

  """The content of the project description."""
  documentContent: DocumentContent

  """Documents associated with the project."""
  documents(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned documents."""
    filter: DocumentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): DocumentConnection!

  """External links associated with the project."""
  externalLinks(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): EntityExternalLinkConnection!

  """[Internal] Facets associated with the project."""
  facets: [Facet!]!

  """The user's favorite associated with this project."""
  favorite: Favorite

  """The resolution of the reminder frequency."""
  frequencyResolution: FrequencyResolutionType!

  """The health of the project."""
  health: ProjectUpdateHealthType

  """The time at which the project health was updated."""
  healthUpdatedAt: DateTime

  """History entries associated with the project."""
  history(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectHistoryConnection!

  """The icon of the project."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """The number of in progress estimation points after each week."""
  inProgressScopeHistory: [Float!]!

  """Initiatives that this project belongs to."""
  initiatives(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): InitiativeConnection!

  """Settings for all integrations associated with that project."""
  integrationsSettings: IntegrationsSettings

  """Inverse relations associated with this project."""
  inverseRelations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectRelationConnection!

  """The total number of issues in the project after each week."""
  issueCountHistory: [Float!]!

  """Issues associated with the project."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Id of the labels associated with this project."""
  labelIds: [String!]!

  """Labels associated with this project."""
  labels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned project labels."""
    filter: ProjectLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectLabelConnection!

  """The last template that was applied to this project."""
  lastAppliedTemplate: Template

  """The last project update posted for this project."""
  lastUpdate: ProjectUpdate

  """The project lead."""
  lead: User

  """Users that are members of the project."""
  members(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned users."""
    filter: UserFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """The project's name."""
  name: String!

  """Customer needs associated with the project."""
  needs(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned needs."""
    filter: CustomerNeedFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerNeedConnection!

  """
  The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Int!

  """The priority of the project as a label."""
  priorityLabel: String!

  """
  The sort order for the project within the organization, when ordered by priority.
  """
  prioritySortOrder: Float!

  """
  The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  """
  progress: Float!

  """[INTERNAL] The progress history of the project."""
  progressHistory: JSONObject!

  """Milestones associated with the project."""
  projectMilestones(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned milestones."""
    filter: ProjectMilestoneFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectMilestoneConnection!

  """The time until which project update reminders are paused."""
  projectUpdateRemindersPausedUntilAt: DateTime

  """Project updates associated with the project."""
  projectUpdates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectUpdateConnection!

  """Relations associated with this project."""
  relations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectRelationConnection!

  """The overall scope (total estimate points) of the project."""
  scope: Float!

  """The total number of estimation points after each week."""
  scopeHistory: [Float!]!

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean! @deprecated(reason: "No longer in use")

  """Whether to send new issue status updates to Slack."""
  slackIssueStatuses: Boolean! @deprecated(reason: "No longer is use")

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean! @deprecated(reason: "No longer in use")

  """The project's unique URL slug."""
  slugId: String!

  """The sort order for the project within the organization."""
  sortOrder: Float!

  """The estimated start date of the project."""
  startDate: TimelessDate

  """The resolution of the project's start date."""
  startDateResolution: DateResolutionType

  """The time at which the project was moved into started state."""
  startedAt: DateTime

  """[DEPRECATED] The type of the state."""
  state: String! @deprecated(reason: "Use project.status instead")

  """The status that the project is associated with."""
  status: ProjectStatus!

  """The estimated completion date of the project."""
  targetDate: TimelessDate

  """The resolution of the project's estimated completion date."""
  targetDateResolution: DateResolutionType

  """Teams associated with this project."""
  teams(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned teams."""
    filter: TeamFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """A flag that indicates whether the project is in the trash bin."""
  trashed: Boolean

  """
  The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequency: Float

  """
  The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequencyInWeeks: Float

  """The day at which to prompt for updates."""
  updateRemindersDay: Day

  """The hour at which to prompt for updates."""
  updateRemindersHour: Float

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Project URL."""
  url: String!
}

"""A generic payload return from entity archive mutations."""
type ProjectArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Project

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""[INTERNAL] Project attachment"""
type ProjectAttachment implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The creator of the attachment."""
  creator: User

  """The unique identifier of the entity."""
  id: ID!

  """Custom metadata related to the attachment."""
  metadata: JSONObject!

  """Information about the external source which created the attachment."""
  source: JSONObject

  """
  An accessor helper to source.type, defines the source type of the attachment.
  """
  sourceType: String

  """Optional subtitle of the attachment"""
  subtitle: String

  """Title of the attachment."""
  title: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """URL of the attachment."""
  url: String!
}

"""Project filtering options."""
input ProjectCollectionFilter {
  """Filters that the project's team must satisfy."""
  accessibleTeams: TeamCollectionFilter

  """
  [ALPHA] Comparator for the project activity type: buzzin, active, some, none
  """
  activityType: StringComparator

  """Compound filters, all of which need to be matched by the project."""
  and: [ProjectCollectionFilter!]

  """Comparator for the project cancelation date."""
  canceledAt: NullableDateComparator

  """Comparator for the project completion date."""
  completedAt: NullableDateComparator

  """Filters that the project's completed milestones must satisfy."""
  completedProjectMilestones: ProjectMilestoneCollectionFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the projects creator must satisfy."""
  creator: UserFilter

  """Count of customers"""
  customerCount: NumberComparator

  """Count of important customers"""
  customerImportantCount: NumberComparator

  """Filters that needs to be matched by all projects."""
  every: ProjectFilter

  """Comparator for filtering projects which are blocked."""
  hasBlockedByRelations: RelationExistsComparator

  """Comparator for filtering projects which are blocking."""
  hasBlockingRelations: RelationExistsComparator

  """
  [Deprecated] Comparator for filtering projects which this is depended on by.
  """
  hasDependedOnByRelations: RelationExistsComparator

  """[Deprecated]Comparator for filtering projects which this depends on."""
  hasDependsOnRelations: RelationExistsComparator

  """Comparator for filtering projects with relations."""
  hasRelatedRelations: RelationExistsComparator

  """Comparator for filtering projects with violated dependencies."""
  hasViolatedRelations: RelationExistsComparator

  """Comparator for the project health: onTrack, atRisk, offTrack"""
  health: StringComparator

  """
  Comparator for the project health (with age): onTrack, atRisk, offTrack, outdated, noUpdate
  """
  healthWithAge: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the projects initiatives must satisfy."""
  initiatives: InitiativeCollectionFilter

  """Filters that the projects issues must satisfy."""
  issues: IssueCollectionFilter

  """Filters that project labels must satisfy."""
  labels: ProjectLabelCollectionFilter

  """Filters that the last applied template must satisfy."""
  lastAppliedTemplate: NullableTemplateFilter

  """Filters that the projects lead must satisfy."""
  lead: NullableUserFilter

  """Comparator for the collection length."""
  length: NumberComparator

  """Filters that the projects members must satisfy."""
  members: UserCollectionFilter

  """Comparator for the project name."""
  name: StringComparator

  """Filters that the project's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Filters that the project's next milestone must satisfy."""
  nextProjectMilestone: ProjectMilestoneFilter

  """Compound filters, one of which need to be matched by the project."""
  or: [ProjectCollectionFilter!]

  """Comparator for the projects priority."""
  priority: NullableNumberComparator

  """Filters that the project's milestones must satisfy."""
  projectMilestones: ProjectMilestoneCollectionFilter

  """Comparator for the project updates."""
  projectUpdates: ProjectUpdatesCollectionFilter

  """Filters that the projects roadmaps must satisfy."""
  roadmaps: RoadmapCollectionFilter

  """[Internal] Comparator for the project's content."""
  searchableContent: ContentComparator

  """Comparator for the project slug ID."""
  slugId: StringComparator

  """Filters that needs to be matched by some projects."""
  some: ProjectFilter

  """Comparator for the project start date."""
  startDate: NullableDateComparator

  """[DEPRECATED] Comparator for the project state."""
  state: StringComparator

  """Filters that the project's status must satisfy."""
  status: ProjectStatusFilter

  """Comparator for the project target date."""
  targetDate: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type ProjectConnection {
  edges: [ProjectEdge!]!
  nodes: [Project!]!
  pageInfo: PageInfo!
}

input ProjectCreateInput {
  """The color of the project."""
  color: String

  """The project content as markdown."""
  content: String

  """The ID of the issue from which that project is created."""
  convertedFromIssueId: String

  """The description for the project."""
  description: String

  """The icon of the project."""
  icon: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """
  [Internal]The identifiers of the project labels associated with this project.
  """
  labelIds: [String!]

  """The ID of the last template applied to the project."""
  lastAppliedTemplateId: String

  """The identifier of the project lead."""
  leadId: String

  """The identifiers of the members of this project."""
  memberIds: [String!]

  """The name of the project."""
  name: String!

  """
  The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Int

  """
  The sort order for the project within shared views, when ordered by priority.
  """
  prioritySortOrder: Float

  """The sort order for the project within shared views."""
  sortOrder: Float

  """The planned start date of the project."""
  startDate: TimelessDate

  """The resolution of the project's start date."""
  startDateResolution: DateResolutionType

  """[DEPRECATED] The state of the project."""
  state: String @deprecated(reason: "Use statusId instead")

  """The ID of the project status."""
  statusId: String

  """The planned target date of the project."""
  targetDate: TimelessDate

  """The resolution of the project's estimated completion date."""
  targetDateResolution: DateResolutionType

  """The identifiers of the teams this project is associated with."""
  teamIds: [String!]!
}

"""Project creation date sorting options."""
input ProjectCreatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

type ProjectEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Project!
}

"""Project filtering options."""
input ProjectFilter {
  """Filters that the project's team must satisfy."""
  accessibleTeams: TeamCollectionFilter

  """
  [ALPHA] Comparator for the project activity type: buzzin, active, some, none
  """
  activityType: StringComparator

  """Compound filters, all of which need to be matched by the project."""
  and: [ProjectFilter!]

  """Comparator for the project cancelation date."""
  canceledAt: NullableDateComparator

  """Comparator for the project completion date."""
  completedAt: NullableDateComparator

  """Filters that the project's completed milestones must satisfy."""
  completedProjectMilestones: ProjectMilestoneCollectionFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the projects creator must satisfy."""
  creator: UserFilter

  """Count of customers"""
  customerCount: NumberComparator

  """Count of important customers"""
  customerImportantCount: NumberComparator

  """Comparator for filtering projects which are blocked."""
  hasBlockedByRelations: RelationExistsComparator

  """Comparator for filtering projects which are blocking."""
  hasBlockingRelations: RelationExistsComparator

  """
  [Deprecated] Comparator for filtering projects which this is depended on by.
  """
  hasDependedOnByRelations: RelationExistsComparator

  """[Deprecated]Comparator for filtering projects which this depends on."""
  hasDependsOnRelations: RelationExistsComparator

  """Comparator for filtering projects with relations."""
  hasRelatedRelations: RelationExistsComparator

  """Comparator for filtering projects with violated dependencies."""
  hasViolatedRelations: RelationExistsComparator

  """Comparator for the project health: onTrack, atRisk, offTrack"""
  health: StringComparator

  """
  Comparator for the project health (with age): onTrack, atRisk, offTrack, outdated, noUpdate
  """
  healthWithAge: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the projects initiatives must satisfy."""
  initiatives: InitiativeCollectionFilter

  """Filters that the projects issues must satisfy."""
  issues: IssueCollectionFilter

  """Filters that project labels must satisfy."""
  labels: ProjectLabelCollectionFilter

  """Filters that the last applied template must satisfy."""
  lastAppliedTemplate: NullableTemplateFilter

  """Filters that the projects lead must satisfy."""
  lead: NullableUserFilter

  """Filters that the projects members must satisfy."""
  members: UserCollectionFilter

  """Comparator for the project name."""
  name: StringComparator

  """Filters that the project's customer needs must satisfy."""
  needs: CustomerNeedCollectionFilter

  """Filters that the project's next milestone must satisfy."""
  nextProjectMilestone: ProjectMilestoneFilter

  """Compound filters, one of which need to be matched by the project."""
  or: [ProjectFilter!]

  """Comparator for the projects priority."""
  priority: NullableNumberComparator

  """Filters that the project's milestones must satisfy."""
  projectMilestones: ProjectMilestoneCollectionFilter

  """Comparator for the project updates."""
  projectUpdates: ProjectUpdatesCollectionFilter

  """Filters that the projects roadmaps must satisfy."""
  roadmaps: RoadmapCollectionFilter

  """[Internal] Comparator for the project's content."""
  searchableContent: ContentComparator

  """Comparator for the project slug ID."""
  slugId: StringComparator

  """Comparator for the project start date."""
  startDate: NullableDateComparator

  """[DEPRECATED] Comparator for the project state."""
  state: StringComparator

  """Filters that the project's status must satisfy."""
  status: ProjectStatusFilter

  """Comparator for the project target date."""
  targetDate: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type ProjectFilterSuggestionPayload {
  """The json filter that is suggested."""
  filter: JSONObject

  """The log id of the prompt, that created this filter."""
  logId: String
}

"""Project health sorting options."""
input ProjectHealthSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""An history associated with a project."""
type ProjectHistory implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The events that happened while recording that history."""
  entries: JSONObject!

  """The unique identifier of the entity."""
  id: ID!

  """The project that the history is associated with."""
  project: Project!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type ProjectHistoryConnection {
  edges: [ProjectHistoryEdge!]!
  nodes: [ProjectHistory!]!
  pageInfo: PageInfo!
}

type ProjectHistoryEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ProjectHistory!
}

"""Labels that can be associated with projects."""
type ProjectLabel implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Children of the label."""
  children(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned project labels."""
    filter: ProjectLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectLabelConnection!

  """The label's color as a HEX string."""
  color: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the label."""
  creator: User

  """The label's description."""
  description: String

  """The unique identifier of the entity."""
  id: ID!

  """Whether the label is a group."""
  isGroup: Boolean!

  """The date when the label was last applied to an issue or project."""
  lastAppliedAt: DateTime

  """The label's name."""
  name: String!
  organization: Organization!

  """The parent label."""
  parent: ProjectLabel

  """Projects associated with the label."""
  projects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned projects."""
    filter: ProjectFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned projects."""
    sort: [ProjectSortInput!]
  ): ProjectConnection!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""Project label filtering options."""
input ProjectLabelCollectionFilter {
  """Compound filters, all of which need to be matched by the label."""
  and: [ProjectLabelCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the project labels creator must satisfy."""
  creator: NullableUserFilter

  """Filters that needs to be matched by all project labels."""
  every: ProjectLabelFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for whether the label is a group label."""
  isGroup: BooleanComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Comparator for the name."""
  name: StringComparator

  """Filter based on the existence of the relation."""
  null: Boolean

  """Compound filters, one of which need to be matched by the label."""
  or: [ProjectLabelCollectionFilter!]

  """Filters that the project label's parent label must satisfy."""
  parent: ProjectLabelFilter

  """Filters that needs to be matched by some project labels."""
  some: ProjectLabelCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type ProjectLabelConnection {
  edges: [ProjectLabelEdge!]!
  nodes: [ProjectLabel!]!
  pageInfo: PageInfo!
}

input ProjectLabelCreateInput {
  """The color of the label."""
  color: String

  """The description of the label."""
  description: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """Whether the label is a group."""
  isGroup: Boolean

  """The name of the label."""
  name: String!

  """The identifier of the parent label."""
  parentId: String
}

type ProjectLabelEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ProjectLabel!
}

"""Project label filtering options."""
input ProjectLabelFilter {
  """Compound filters, all of which need to be matched by the label."""
  and: [ProjectLabelFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the project labels creator must satisfy."""
  creator: NullableUserFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for whether the label is a group label."""
  isGroup: BooleanComparator

  """Comparator for the name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the label."""
  or: [ProjectLabelFilter!]

  """Filters that the project label's parent label must satisfy."""
  parent: ProjectLabelFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type ProjectLabelPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The label that was created or updated."""
  projectLabel: ProjectLabel!

  """Whether the operation was successful."""
  success: Boolean!
}

input ProjectLabelUpdateInput {
  """The color of the label."""
  color: String

  """The description of the label."""
  description: String

  """Whether the label is a group."""
  isGroup: Boolean

  """The name of the label."""
  name: String

  """The identifier of the parent label."""
  parentId: String
}

"""Project lead sorting options."""
input ProjectLeadSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Project manual order sorting options."""
input ProjectManualSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A milestone for a project."""
type ProjectMilestone implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """[Internal] The current progress of the project milestone."""
  currentProgress: JSONObject!

  """The project milestone's description in markdown format."""
  description: String

  """[Internal] The project milestone's description as YJS state."""
  descriptionState: String

  """The content of the project milestone description."""
  documentContent: DocumentContent

  """The unique identifier of the entity."""
  id: ID!

  """Issues associated with the project milestone."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """The name of the project milestone."""
  name: String!

  """The progress % of the project milestone."""
  progress: Float!

  """[Internal] The progress history of the project milestone."""
  progressHistory: JSONObject!

  """The project of the milestone."""
  project: Project!

  """
  The order of the milestone in relation to other milestones within a project.
  """
  sortOrder: Float!

  """The status of the project milestone."""
  status: ProjectMilestoneStatus!

  """The planned completion date of the milestone."""
  targetDate: TimelessDate

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""Milestone collection filtering options."""
input ProjectMilestoneCollectionFilter {
  """Compound filters, all of which need to be matched by the milestone."""
  and: [ProjectMilestoneCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that needs to be matched by all milestones."""
  every: ProjectMilestoneFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Comparator for the project milestone name."""
  name: NullableStringComparator

  """Compound filters, one of which need to be matched by the milestone."""
  or: [ProjectMilestoneCollectionFilter!]

  """Filters that needs to be matched by some milestones."""
  some: ProjectMilestoneFilter

  """Comparator for the project milestone target date."""
  targetDate: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type ProjectMilestoneConnection {
  edges: [ProjectMilestoneEdge!]!
  nodes: [ProjectMilestone!]!
  pageInfo: PageInfo!
}

input ProjectMilestoneCreateInput {
  """The description of the project milestone in markdown format."""
  description: String

  """
  [Internal] The description of the project milestone as a Prosemirror document.
  """
  descriptionData: JSONObject

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the project milestone."""
  name: String!

  """Related project for the project milestone."""
  projectId: String!

  """The sort order for the project milestone within a project."""
  sortOrder: Float

  """The planned target date of the project milestone."""
  targetDate: TimelessDate
}

type ProjectMilestoneEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ProjectMilestone!
}

"""Project milestone filtering options."""
input ProjectMilestoneFilter {
  """
  Compound filters, all of which need to be matched by the project milestone.
  """
  and: [ProjectMilestoneFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the project milestone name."""
  name: NullableStringComparator

  """
  Compound filters, one of which need to be matched by the project milestone.
  """
  or: [ProjectMilestoneFilter!]

  """Comparator for the project milestone target date."""
  targetDate: NullableDateComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

input ProjectMilestoneMoveInput {
  """
  Whether to add each milestone issue's team to the project. This is needed when there is a mismatch between a project's teams and the milestone's issues' teams. Either this or newIssueTeamId is required in that situation to resolve constraints.
  """
  addIssueTeamToProject: Boolean

  """
  The team id to move the attached issues to. This is needed when there is a mismatch between a project's teams and the milestone's issues' teams. Either this or addIssueTeamToProject is required in that situation to resolve constraints.
  """
  newIssueTeamId: String

  """The identifier of the project to move the milestone to."""
  projectId: String!

  """
  A list of issue id to team ids, used for undoing a previous milestone move where the specified issues were moved from the specified teams.
  """
  undoIssueTeamIds: [ProjectMilestoneMoveIssueToTeamInput!]

  """
  A mapping of project id to a previous set of team ids, used for undoing a previous milestone move where the specified teams were added to the project.
  """
  undoProjectTeamIds: ProjectMilestoneMoveProjectTeamsInput
}

type ProjectMilestoneMoveIssueToTeam {
  """
  The issue id in this relationship, you can use * as wildcard if all issues are being moved to the same team
  """
  issueId: String!

  """The team id in this relationship"""
  teamId: String!
}

"""
[Internal] Used for ProjectMilestoneMoveInput to describe a mapping between an issue and its team.
"""
input ProjectMilestoneMoveIssueToTeamInput {
  """
  The issue id in this relationship, you can use * as wildcard if all issues are being moved to the same team
  """
  issueId: String!

  """The team id in this relationship"""
  teamId: String!
}

type ProjectMilestoneMovePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """
  A snapshot of the issues that were moved to new teams, if the user selected to do it, containing an array of mappings between an issue and its previous team. Store on the client to use for undoing a previous milestone move.
  """
  previousIssueTeamIds: [ProjectMilestoneMoveIssueToTeam!]

  """
  A snapshot of the project that had new teams added to it, if the user selected to do it, containing an array of mappings between a project and its previous teams. Store on the client to use for undoing a previous milestone move.
  """
  previousProjectTeamIds: ProjectMilestoneMoveProjectTeams

  """The project milestone that was created or updated."""
  projectMilestone: ProjectMilestone!

  """Whether the operation was successful."""
  success: Boolean!
}

type ProjectMilestoneMoveProjectTeams {
  """The project id"""
  projectId: String!

  """The team ids for the project"""
  teamIds: [String!]!
}

"""
[Internal] Used for ProjectMilestoneMoveInput to describe a snapshot of a project and its team ids
"""
input ProjectMilestoneMoveProjectTeamsInput {
  """The project id"""
  projectId: String!

  """The team ids for the project"""
  teamIds: [String!]!
}

type ProjectMilestonePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The project milestone that was created or updated."""
  projectMilestone: ProjectMilestone!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The status of a project milestone."""
enum ProjectMilestoneStatus {
  done
  next
  overdue
  unstarted
}

input ProjectMilestoneUpdateInput {
  """The description of the project milestone in markdown format."""
  description: String

  """
  [Internal] The description of the project milestone as a Prosemirror document.
  """
  descriptionData: JSONObject

  """The name of the project milestone."""
  name: String

  """Related project for the project milestone."""
  projectId: String

  """The sort order for the project milestone within a project."""
  sortOrder: Float

  """The planned target date of the project milestone."""
  targetDate: TimelessDate
}

"""Project name sorting options."""
input ProjectNameSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A project related notification."""
type ProjectNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """The comment related to the notification."""
  comment: Comment

  """
  Related comment ID. Null if the notification is not related to a comment.
  """
  commentId: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The document related to the notification."""
  document: Document

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """
  The parent comment related to the notification, if a notification is a reply comment notification.
  """
  parentComment: Comment

  """
  Related parent comment ID. Null if the notification is not related to a comment.
  """
  parentCommentId: String

  """The project related to the notification."""
  project: Project!

  """Related project ID."""
  projectId: String!

  """Related project milestone ID."""
  projectMilestoneId: String

  """The project update related to the notification."""
  projectUpdate: ProjectUpdate

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """Related project update ID."""
  projectUpdateId: String

  """Name of the reaction emoji related to the notification."""
  reactionEmoji: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

"""A project notification subscription."""
type ProjectNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer associated with the notification subscription."""
  customer: Customer

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """The project subscribed to."""
  project: Project!

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

type ProjectPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The project that was created or updated."""
  project: Project

  """Whether the operation was successful."""
  success: Boolean!
}

"""Project priority sorting options."""
input ProjectPrioritySort {
  """Whether to consider no priority as the highest or lowest priority"""
  noPriorityFirst: Boolean = false

  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A relation between two projects."""
type ProjectRelation implements Node {
  """The type of anchor on the project end of the relation."""
  anchorType: String!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The project whose relationship is being described."""
  project: Project!

  """
  The milestone within the project whose relationship is being described.
  """
  projectMilestone: ProjectMilestone

  """The type of anchor on the relatedProject end of the relation."""
  relatedAnchorType: String!

  """The related project."""
  relatedProject: Project!

  """
  The milestone within the related project whose relationship is being described.
  """
  relatedProjectMilestone: ProjectMilestone

  """The relationship of the project with the related project."""
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The last user who created or modified the relation."""
  user: User
}

type ProjectRelationConnection {
  edges: [ProjectRelationEdge!]!
  nodes: [ProjectRelation!]!
  pageInfo: PageInfo!
}

input ProjectRelationCreateInput {
  """The type of the anchor for the project."""
  anchorType: String!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the project that is related to another project."""
  projectId: String!

  """The identifier of the project milestone."""
  projectMilestoneId: String

  """The type of the anchor for the related project."""
  relatedAnchorType: String!

  """The identifier of the related project."""
  relatedProjectId: String!

  """The identifier of the related project milestone."""
  relatedProjectMilestoneId: String

  """The type of relation of the project to the related project."""
  type: String!
}

type ProjectRelationEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ProjectRelation!
}

type ProjectRelationPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The project relation that was created or updated."""
  projectRelation: ProjectRelation!

  """Whether the operation was successful."""
  success: Boolean!
}

input ProjectRelationUpdateInput {
  """The type of the anchor for the project."""
  anchorType: String

  """The identifier of the project that is related to another project."""
  projectId: String

  """The identifier of the project milestone."""
  projectMilestoneId: String

  """The type of the anchor for the related project."""
  relatedAnchorType: String

  """The identifier of the related project."""
  relatedProjectId: String

  """The identifier of the related project milestone."""
  relatedProjectMilestoneId: String

  """The type of relation of the project to the related project."""
  type: String
}

type ProjectSearchPayload {
  """
  Archived entities matching the search term along with all their dependencies.
  """
  archivePayload: ArchiveResponse!
  edges: [ProjectSearchResultEdge!]!
  nodes: [ProjectSearchResult!]!
  pageInfo: PageInfo!

  """Total number of results for query without filters applied."""
  totalCount: Float!
}

type ProjectSearchResult implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The time at which the project was automatically archived by the auto pruning process.
  """
  autoArchivedAt: DateTime

  """The time at which the project was moved into canceled state."""
  canceledAt: DateTime

  """The project's color."""
  color: String!

  """Comments associated with the project overview."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The time at which the project was moved into completed state."""
  completedAt: DateTime

  """The number of completed issues in the project after each week."""
  completedIssueCountHistory: [Float!]!

  """The number of completed estimation points after each week."""
  completedScopeHistory: [Float!]!

  """The project's content in markdown format."""
  content: String

  """[Internal] The project's content as YJS state."""
  contentState: String

  """The project was created based on this issue."""
  convertedFromIssue: Issue

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the project."""
  creator: User

  """[INTERNAL] The current progress of the project."""
  currentProgress: JSONObject!

  """The project's description."""
  description: String!

  """The content of the project description."""
  documentContent: DocumentContent

  """Documents associated with the project."""
  documents(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned documents."""
    filter: DocumentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): DocumentConnection!

  """External links associated with the project."""
  externalLinks(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): EntityExternalLinkConnection!

  """[Internal] Facets associated with the project."""
  facets: [Facet!]!

  """The user's favorite associated with this project."""
  favorite: Favorite

  """The resolution of the reminder frequency."""
  frequencyResolution: FrequencyResolutionType!

  """The health of the project."""
  health: ProjectUpdateHealthType

  """The time at which the project health was updated."""
  healthUpdatedAt: DateTime

  """History entries associated with the project."""
  history(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectHistoryConnection!

  """The icon of the project."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """The number of in progress estimation points after each week."""
  inProgressScopeHistory: [Float!]!

  """Initiatives that this project belongs to."""
  initiatives(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): InitiativeConnection!

  """Settings for all integrations associated with that project."""
  integrationsSettings: IntegrationsSettings

  """Inverse relations associated with this project."""
  inverseRelations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectRelationConnection!

  """The total number of issues in the project after each week."""
  issueCountHistory: [Float!]!

  """Issues associated with the project."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Id of the labels associated with this project."""
  labelIds: [String!]!

  """Labels associated with this project."""
  labels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned project labels."""
    filter: ProjectLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectLabelConnection!

  """The last template that was applied to this project."""
  lastAppliedTemplate: Template

  """The last project update posted for this project."""
  lastUpdate: ProjectUpdate

  """The project lead."""
  lead: User

  """Users that are members of the project."""
  members(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned users."""
    filter: UserFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """Metadata related to search result."""
  metadata: JSONObject!

  """The project's name."""
  name: String!

  """Customer needs associated with the project."""
  needs(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned needs."""
    filter: CustomerNeedFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerNeedConnection!

  """
  The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Int!

  """The priority of the project as a label."""
  priorityLabel: String!

  """
  The sort order for the project within the organization, when ordered by priority.
  """
  prioritySortOrder: Float!

  """
  The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  """
  progress: Float!

  """[INTERNAL] The progress history of the project."""
  progressHistory: JSONObject!

  """Milestones associated with the project."""
  projectMilestones(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned milestones."""
    filter: ProjectMilestoneFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectMilestoneConnection!

  """The time until which project update reminders are paused."""
  projectUpdateRemindersPausedUntilAt: DateTime

  """Project updates associated with the project."""
  projectUpdates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectUpdateConnection!

  """Relations associated with this project."""
  relations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectRelationConnection!

  """The overall scope (total estimate points) of the project."""
  scope: Float!

  """The total number of estimation points after each week."""
  scopeHistory: [Float!]!

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean! @deprecated(reason: "No longer in use")

  """Whether to send new issue status updates to Slack."""
  slackIssueStatuses: Boolean! @deprecated(reason: "No longer is use")

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean! @deprecated(reason: "No longer in use")

  """The project's unique URL slug."""
  slugId: String!

  """The sort order for the project within the organization."""
  sortOrder: Float!

  """The estimated start date of the project."""
  startDate: TimelessDate

  """The resolution of the project's start date."""
  startDateResolution: DateResolutionType

  """The time at which the project was moved into started state."""
  startedAt: DateTime

  """[DEPRECATED] The type of the state."""
  state: String! @deprecated(reason: "Use project.status instead")

  """The status that the project is associated with."""
  status: ProjectStatus!

  """The estimated completion date of the project."""
  targetDate: TimelessDate

  """The resolution of the project's estimated completion date."""
  targetDateResolution: DateResolutionType

  """Teams associated with this project."""
  teams(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned teams."""
    filter: TeamFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """A flag that indicates whether the project is in the trash bin."""
  trashed: Boolean

  """
  The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequency: Float

  """
  The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequencyInWeeks: Float

  """The day at which to prompt for updates."""
  updateRemindersDay: Day

  """The hour at which to prompt for updates."""
  updateRemindersHour: Float

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Project URL."""
  url: String!
}

type ProjectSearchResultEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ProjectSearchResult!
}

"""Issue project sorting options."""
input ProjectSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Project sorting options."""
input ProjectSortInput {
  """Sort by project creation date"""
  createdAt: ProjectCreatedAtSort

  """Sort by project health status."""
  health: ProjectHealthSort

  """Sort by project lead name."""
  lead: ProjectLeadSort

  """Sort by manual order"""
  manual: ProjectManualSort

  """Sort by project name"""
  name: ProjectNameSort

  """Sort by project priority"""
  priority: ProjectPrioritySort

  """Sort by project start date"""
  startDate: StartDateSort

  """Sort by project status"""
  status: ProjectStatusSort

  """Sort by project target date"""
  targetDate: TargetDateSort

  """Sort by project update date"""
  updatedAt: ProjectUpdatedAtSort
}

"""A project status."""
type ProjectStatus implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The UI color of the status as a HEX string."""
  color: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Description of the status."""
  description: String

  """The unique identifier of the entity."""
  id: ID!

  """Whether or not a project can be in this status indefinitely."""
  indefinite: Boolean!

  """The name of the status."""
  name: String!

  """The position of the status in the workspace's project flow."""
  position: Float!

  """The type of the project status."""
  type: ProjectStatusType!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""A generic payload return from entity archive mutations."""
type ProjectStatusArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: ProjectStatus

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type ProjectStatusConnection {
  edges: [ProjectStatusEdge!]!
  nodes: [ProjectStatus!]!
  pageInfo: PageInfo!
}

type ProjectStatusCountPayload {
  """
  Total number of projects using this project status that are not visible to the user because they are in an archived team.
  """
  archivedTeamCount: Float!

  """Total number of projects using this project status."""
  count: Float!

  """
  Total number of projects using this project status that are not visible to the user because they are in a private team.
  """
  privateCount: Float!
}

input ProjectStatusCreateInput {
  """The UI color of the status as a HEX string."""
  color: String!

  """Description of the status."""
  description: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """Whether or not a project can be in this status indefinitely."""
  indefinite: Boolean = false

  """The name of the status."""
  name: String!

  """The position of the status in the workspace's project flow."""
  position: Float!

  """The type of the project status."""
  type: ProjectStatusType!
}

type ProjectStatusEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ProjectStatus!
}

"""Project status filtering options."""
input ProjectStatusFilter {
  """
  Compound filters, all of which need to be matched by the project status.
  """
  and: [ProjectStatusFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the project status description."""
  description: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the project status name."""
  name: StringComparator

  """
  Compound filters, one of which needs to be matched by the project status.
  """
  or: [ProjectStatusFilter!]

  """Comparator for the project status position."""
  position: NumberComparator

  """Filters that the project status projects must satisfy."""
  projects: ProjectCollectionFilter

  """Comparator for the project status type."""
  type: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type ProjectStatusPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The project status that was created or updated."""
  status: ProjectStatus!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Project status sorting options."""
input ProjectStatusSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A type of project status."""
enum ProjectStatusType {
  backlog
  canceled
  completed
  paused
  planned
  started
}

input ProjectStatusUpdateInput {
  """The UI color of the status as a HEX string."""
  color: String

  """Description of the status."""
  description: String

  """Whether or not a project can be in this status indefinitely."""
  indefinite: Boolean

  """The name of the status."""
  name: String

  """The position of the status in the workspace's project flow."""
  position: Float

  """The type of the project status."""
  type: ProjectStatusType
}

"""Different tabs available inside a project."""
enum ProjectTab {
  customers
  documents
  issues
}

"""An update associated with a project."""
type ProjectUpdate implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The update content in markdown format."""
  body: String!

  """[Internal] The content of the update as a Prosemirror document."""
  bodyData: String!

  """Comments associated with the project update."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The diff between the current update and the previous one."""
  diff: JSONObject

  """
  The diff between the current update and the previous one, formatted as markdown.
  """
  diffMarkdown: String

  """The time the update was edited."""
  editedAt: DateTime

  """The health of the project at the time of the update."""
  health: ProjectUpdateHealthType!

  """The unique identifier of the entity."""
  id: ID!

  """
  [Internal] Serialized JSON representing current state of the project properties when posting the project update.
  """
  infoSnapshot: JSONObject

  """Whether project update diff should be hidden."""
  isDiffHidden: Boolean!

  """Whether the project update is stale."""
  isStale: Boolean!

  """The project that the update is associated with."""
  project: Project!

  """Emoji reaction summary, grouped by emoji type."""
  reactionData: JSONObject!

  """Reactions associated with the project update."""
  reactions: [Reaction!]!

  """The update's unique URL slug."""
  slugId: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The URL to the project update."""
  url: String!

  """The user who wrote the update."""
  user: User!
}

"""A generic payload return from entity archive mutations."""
type ProjectUpdateArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: ProjectUpdate

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type ProjectUpdateConnection {
  edges: [ProjectUpdateEdge!]!
  nodes: [ProjectUpdate!]!
  pageInfo: PageInfo!
}

input ProjectUpdateCreateInput {
  """The content of the project update in markdown format."""
  body: String

  """
  [Internal] The content of the project update as a Prosemirror document.
  """
  bodyData: JSON

  """The health of the project at the time of the update."""
  health: ProjectUpdateHealthType

  """The identifier. If none is provided, the backend will generate one."""
  id: String

  """
  Whether the diff between the current update and the previous one should be hidden.
  """
  isDiffHidden: Boolean

  """The project to associate the project update with."""
  projectId: String!
}

type ProjectUpdateEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: ProjectUpdate!
}

"""Options for filtering project updates."""
input ProjectUpdateFilter {
  """
  Compound filters, all of which need to be matched by the ProjectUpdate.
  """
  and: [ProjectUpdateFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the identifier."""
  id: IDComparator

  """
  Compound filters, one of which need to be matched by the ProjectUpdate.
  """
  or: [ProjectUpdateFilter!]

  """Filters that the project update project must satisfy."""
  project: ProjectFilter

  """Filters that the project updates reactions must satisfy."""
  reactions: ReactionCollectionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator

  """Filters that the project update creator must satisfy."""
  user: UserFilter
}

"""The health type when the project update is created."""
enum ProjectUpdateHealthType {
  atRisk
  offTrack
  onTrack
}

input ProjectUpdateInput {
  """The date when the project was canceled."""
  canceledAt: DateTime

  """The color of the project."""
  color: String

  """The date when the project was completed."""
  completedAt: DateTime

  """The project content as markdown."""
  content: String

  """The ID of the issue from which that project is created."""
  convertedFromIssueId: String

  """The description for the project."""
  description: String

  """The frequency resolution."""
  frequencyResolution: FrequencyResolutionType

  """The icon of the project."""
  icon: String

  """The identifiers of the project labels associated with this project."""
  labelIds: [String!]

  """The ID of the last template applied to the project."""
  lastAppliedTemplateId: String

  """The identifier of the project lead."""
  leadId: String

  """The identifiers of the members of this project."""
  memberIds: [String!]

  """The name of the project."""
  name: String

  """
  The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  """
  priority: Int

  """
  The sort order for the project within shared views, when ordered by priority.
  """
  prioritySortOrder: Float

  """The time until which project update reminders are paused."""
  projectUpdateRemindersPausedUntilAt: DateTime

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean

  """Whether to send issue status update notifications to Slack."""
  slackIssueStatuses: Boolean

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean

  """The sort order for the project in shared views."""
  sortOrder: Float

  """The planned start date of the project."""
  startDate: TimelessDate

  """The resolution of the project's start date."""
  startDateResolution: DateResolutionType

  """[DEPRECATED] The state of the project."""
  state: String @deprecated(reason: "Use statusId instead")

  """The ID of the project status."""
  statusId: String

  """The planned target date of the project."""
  targetDate: TimelessDate

  """The resolution of the project's estimated completion date."""
  targetDateResolution: DateResolutionType

  """The identifiers of the teams this project is associated with."""
  teamIds: [String!]

  """Whether the project has been trashed."""
  trashed: Boolean

  """
  The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequency: Float

  """
  The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  """
  updateReminderFrequencyInWeeks: Float

  """The day at which to prompt for updates."""
  updateRemindersDay: Day

  """The hour at which to prompt for updates."""
  updateRemindersHour: Int
}

type ProjectUpdatePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The project update that was created or updated."""
  projectUpdate: ProjectUpdate!

  """Whether the operation was successful."""
  success: Boolean!
}

"""The frequency at which to send project update reminders."""
enum ProjectUpdateReminderFrequency {
  month
  never
  twoWeeks
  week
}

type ProjectUpdateReminderPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

input ProjectUpdateUpdateInput {
  """The content of the project update in markdown format."""
  body: String

  """The content of the project update as a Prosemirror document."""
  bodyData: JSON

  """The health of the project at the time of the update."""
  health: ProjectUpdateHealthType

  """
  Whether the diff between the current update and the previous one should be hidden.
  """
  isDiffHidden: Boolean
}

"""Project update date sorting options."""
input ProjectUpdatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""
Collection filtering options for filtering projects by project updates.
"""
input ProjectUpdatesCollectionFilter {
  """
  Compound filters, all of which need to be matched by the project update.
  """
  and: [ProjectUpdatesCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that needs to be matched by all updates."""
  every: ProjectUpdatesFilter

  """Comparator for the project update health."""
  health: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Compound filters, one of which need to be matched by the update."""
  or: [ProjectUpdatesCollectionFilter!]

  """Filters that needs to be matched by some updates."""
  some: ProjectUpdatesFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Options for filtering projects by project updates."""
input ProjectUpdatesFilter {
  """
  Compound filters, all of which need to be matched by the project updates.
  """
  and: [ProjectUpdatesFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the project update health."""
  health: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """
  Compound filters, one of which need to be matched by the project updates.
  """
  or: [ProjectUpdatesFilter!]

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""[Internal] A pull request in a version control system."""
type PullRequest implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The number of the pull request in the version control system."""
  number: Float!

  """The source branch of the pull request."""
  sourceBranch: String!

  """The status of the pull request."""
  status: PullRequestStatus!

  """The target branch of the pull request."""
  targetBranch: String!

  """The title of the pull request."""
  title: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The URL of the pull request in the version control system."""
  url: String!
}

"""A pull request related notification."""
type PullRequestNotification implements Entity & Node & Notification {
  """The user that caused the notification."""
  actor: User

  """[Internal] Notification actor initials if avatar is not available."""
  actorAvatarColor: String!

  """[Internal] Notification avatar URL."""
  actorAvatarUrl: String

  """[Internal] Notification actor initials if avatar is not available."""
  actorInitials: String

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The bot that caused the notification."""
  botActor: ActorBot

  """The category of the notification."""
  category: NotificationCategory!

  """
  Related comment ID. Null if the notification is not related to a comment.
  """
  commentId: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The time at when an email reminder for this notification was sent to the user. Null, if no email
      reminder has been sent.
  """
  emailedAt: DateTime

  """The external user that caused the notification."""
  externalUserActor: ExternalUser

  """
  [Internal] Notifications with the same grouping key will be grouped together in the UI.
  """
  groupingKey: String!

  """
  [Internal] Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
  """
  groupingPriority: Float!

  """The unique identifier of the entity."""
  id: ID!

  """[Internal] Inbox URL for the notification."""
  inboxUrl: String!

  """[Internal] If notification actor was Linear."""
  isLinearActor: Boolean!

  """[Internal] Issue's status type for issue notifications."""
  issueStatusType: String

  """
  Related parent comment ID. Null if the notification is not related to a comment.
  """
  parentCommentId: String

  """[Internal] Project update health for new updates."""
  projectUpdateHealth: String

  """The pull request related to the notification."""
  pullRequest: PullRequest!

  """Related pull request."""
  pullRequestId: String!

  """Name of the reaction emoji related to the notification."""
  reactionEmoji: String

  """
  The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  """
  readAt: DateTime

  """
  The time until a notification will be snoozed. After that it will appear in the inbox again.
  """
  snoozedUntilAt: DateTime

  """[Internal] Notification subtitle."""
  subtitle: String!

  """[Internal] Notification title."""
  title: String!

  """Notification type."""
  type: String!

  """The time at which a notification was unsnoozed.."""
  unsnoozedAt: DateTime

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """[Internal] URL to the target of the notification."""
  url: String!

  """The user that received the notification."""
  user: User!
}

enum PullRequestReviewTool {
  graphite
  source
}

"""The status of a pull request."""
enum PullRequestStatus {
  approved
  closed
  draft
  inReview
  merged
  open
}

"""A user's web or mobile push notification subscription."""
type PushSubscription implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

input PushSubscriptionCreateInput {
  """The data of the subscription in stringified JSON format."""
  data: String!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """
  Whether this is a subscription payload for Google Cloud Messaging or Apple Push Notification service.
  """
  type: PushSubscriptionType = web

  """The user identifier of the subscription."""
  userId: String @deprecated(reason: "Not needed anymore.")
}

type PushSubscriptionPayload {
  """The push subscription that was created or updated."""
  entity: PushSubscription!

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type PushSubscriptionTestPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""The different push subscription types."""
enum PushSubscriptionType {
  apple
  appleDevelopment
  firebase
  web
}

type Query {
  """
  All teams you the user can administrate. Administrable teams are teams whose settings the user can change, but to whose issues the user doesn't necessarily have access to.
  """
  administrableTeams(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned teams."""
    filter: TeamFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """All agent activities."""
  agentActivities(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned agent activities."""
    filter: AgentActivityFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AgentActivityConnection!

  """A specific agent activity."""
  agentActivity(
    """The identifier of the agent activity to retrieve."""
    id: String!
  ): AgentActivity!

  """A specific agent session."""
  agentSession(
    """The identifier of the agent session to retrieve."""
    id: String!
  ): AgentSession!

  """All agent sessions."""
  agentSessions(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AgentSessionConnection!

  """All API keys for the user."""
  apiKeys(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ApiKeyConnection!

  """Get basic information for an application."""
  applicationInfo(
    """The client ID of the application."""
    clientId: String!
  ): Application!

  """[INTERNAL] Get basic information for a list of applications."""
  applicationInfoByIds(
    """The IDs of the applications."""
    ids: [String!]!
  ): [Application!]!

  """
  [DEPRECATED] [INTERNAL] Get information for a list of applications with memberships
  """
  applicationInfoWithMembershipsByIds(
    """The client IDs to look up."""
    clientIds: [String!]!
  ): [WorkspaceAuthorizedApplication!]! @deprecated(reason: "Use more efficient `workspaceAuthorizedApplicationsWithAppUser` and `workspaceAuthorizedApplication` instead.")

  """
  Get information for an application and whether a user has approved it for the given scopes.
  """
  applicationWithAuthorization(
    """Actor mode used for the authorization."""
    actor: String = "user"

    """The client ID of the application."""
    clientId: String!

    """Redirect URI for the application."""
    redirectUri: String

    """Scopes being requested by the application."""
    scope: [String!]!
  ): UserAuthorizedApplication!

  """[Internal] All archived teams of the organization."""
  archivedTeams: [Team!]!

  "\nOne specific issue attachment.\n[Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead"
  attachment(id: String!): Attachment!

  "\nQuery an issue by its associated attachment, and its id.\n"
  attachmentIssue(
    """
    `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
    """
    id: String!
  ): Issue! @deprecated(reason: "Will be removed in near future, please use `attachmentsForURL` to get attachments and their issues instead.")

  """
  [Internal] Get a list of all unique attachment sources in the workspace.
  """
  attachmentSources(
    """
    (optional) if provided will only return attachment sources for the given team.
    """
    teamId: String
  ): AttachmentSourcesPayload!

  """
  All issue attachments.
  
  To get attachments for a given URL, use `attachmentsForURL` query.
  """
  attachments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned attachments."""
    filter: AttachmentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AttachmentConnection!

  """Returns issue attachments for a given `url`."""
  attachmentsForURL(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """The attachment URL."""
    url: String!
  ): AttachmentConnection!

  """All audit log entries."""
  auditEntries(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned audit entries."""
    filter: AuditEntryFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): AuditEntryConnection!

  """List of audit entry types."""
  auditEntryTypes: [AuditEntryType!]!

  """User's active sessions."""
  authenticationSessions: [AuthenticationSessionResponse!]!

  """[INTERNAL] Get all authorized applications for a user."""
  authorizedApplications: [AuthorizedApplication!]!

  """Fetch users belonging to this user account."""
  availableUsers: AuthResolverResponse!

  """A specific comment."""
  comment(
    """The hash of the comment to retrieve."""
    hash: String

    """The identifier of the comment to retrieve."""
    id: String

    """[Deprecated] The issue for which to find the comment."""
    issueId: String @deprecated(reason: "Not in use anymore, please use `id` or `hash` directly.")
  ): Comment!

  """All comments."""
  comments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned comments."""
    filter: CommentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CommentConnection!

  """One specific custom view."""
  customView(id: String!): CustomView!

  """[INTERNAL] Suggests metadata for a view based on it's filters."""
  customViewDetailsSuggestion(filter: JSONObject!, modelName: String): CustomViewSuggestionPayload!

  """
  Whether a custom view has other subscribers than the current user in the organization.
  """
  customViewHasSubscribers(
    """The identifier of the custom view."""
    id: String!
  ): CustomViewHasSubscribersPayload!

  """Custom views for the user."""
  customViews(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned custom views."""
    filter: CustomViewFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned custom views."""
    sort: [CustomViewSortInput!]
  ): CustomViewConnection!

  """One specific customer."""
  customer(id: String!): Customer!

  """One specific customer need"""
  customerNeed(
    """The hash of the need to retrieve."""
    hash: String

    """The identifier of the need to retrieve."""
    id: String
  ): CustomerNeed!

  """All customer needs."""
  customerNeeds(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned customers needs."""
    filter: CustomerNeedFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerNeedConnection!

  """One specific customer status."""
  customerStatus(id: String!): CustomerStatus!

  """All customer statuses."""
  customerStatuses(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerStatusConnection!

  """One specific customer tier."""
  customerTier(id: String!): CustomerTier!

  """All customer tiers."""
  customerTiers(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CustomerTierConnection!

  """All customers."""
  customers(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned customers."""
    filter: CustomerFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """Sort returned customers."""
    sorts: [CustomerSortInput!]
  ): CustomerConnection!

  """One specific cycle."""
  cycle(id: String!): Cycle!

  """All cycles."""
  cycles(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned users."""
    filter: CycleFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CycleConnection!

  """One specific document."""
  document(id: String!): Document!

  """A collection of document content history entries."""
  documentContentHistory(id: String!): DocumentContentHistoryPayload!

  """All documents in the workspace."""
  documents(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned documents."""
    filter: DocumentFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): DocumentConnection!

  """One specific email intake address."""
  emailIntakeAddress(id: String!): EmailIntakeAddress!

  """A specific emoji."""
  emoji(
    """The identifier or the name of the emoji to retrieve."""
    id: String!
  ): Emoji!

  """All custom emojis."""
  emojis(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): EmojiConnection!

  """One specific entity link."""
  entityExternalLink(id: String!): EntityExternalLink!

  """One specific external user."""
  externalUser(
    """The identifier of the external user to retrieve."""
    id: String!
  ): ExternalUser!

  """All external users for the organization."""
  externalUsers(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ExternalUserConnection!

  """
  [INTERNAL] Webhook failure events for webhooks that belong to an OAuth application. (last 50)
  """
  failuresForOauthWebhooks(
    """The identifier of the OAuth client to retrieve failures for."""
    oauthClientId: String!
  ): [WebhookFailureEvent!]!

  """One specific favorite."""
  favorite(id: String!): Favorite!

  """The user's favorites."""
  favorites(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): FavoriteConnection!

  """
  [Internal] Fetch an arbitrary set of data using natural language query. Be specific about what you want including properties for each entity, sort order, filters, limit and properties.
  """
  fetchData(
    """
    Natural language query describing what data to fetch.
        
        Examples:
        - "All issues for the project with id 12345678-1234-1234-1234-123456789abc including comments"
        - "The latest project update for each project that's a part of the initiative with id 12345678-1234-1234-1234-123456789abc, including it's sub-initiatives"
    """
    query: String!
  ): FetchDataPayload!

  """One specific initiative."""
  initiative(id: String!): Initiative!

  """One specific initiative relation."""
  initiativeRelation(id: String!): ProjectRelation!

  """All initiative relationships."""
  initiativeRelations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): InitiativeRelationConnection!

  """One specific initiativeToProject."""
  initiativeToProject(id: String!): InitiativeToProject!

  """returns a list of initiative to project entities."""
  initiativeToProjects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): InitiativeToProjectConnection!

  """A specific  initiative update."""
  initiativeUpdate(
    """The identifier of the  initiative update to retrieve."""
    id: String!
  ): InitiativeUpdate!

  """All  InitiativeUpdates."""
  initiativeUpdates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned initiative updates."""
    filter: InitiativeUpdateFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): InitiativeUpdateConnection!

  """All initiatives in the workspace."""
  initiatives(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned initiatives."""
    filter: InitiativeFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned initiatives."""
    sort: [InitiativeSortInput!]
  ): InitiativeConnection!

  """One specific integration."""
  integration(id: String!): Integration!

  """Checks if the integration has all required scopes."""
  integrationHasScopes(
    """The integration ID."""
    integrationId: String!

    """Required scopes."""
    scopes: [String!]!
  ): IntegrationHasScopesPayload!

  """One specific integrationTemplate."""
  integrationTemplate(id: String!): IntegrationTemplate!

  """Template and integration connections."""
  integrationTemplates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IntegrationTemplateConnection!

  """All integrations."""
  integrations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IntegrationConnection!

  """One specific set of settings."""
  integrationsSettings(id: String!): IntegrationsSettings!

  """One specific issue."""
  issue(id: String!): Issue!

  """Find issues that are related to a given Figma file key."""
  issueFigmaFileKeySearch(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """The Figma file key."""
    fileKey: String!

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Suggests filters for an issue view based on a text prompt."""
  issueFilterSuggestion(
    """The ID of the project if filtering a project view"""
    projectId: String
    prompt: String!
  ): IssueFilterSuggestionPayload!

  """Checks a CSV file validity against a specific import service."""
  issueImportCheckCSV(
    """CSV storage url."""
    csvUrl: String!

    """The service the CSV containing data from."""
    service: String!
  ): IssueImportCheckPayload!

  """
  Checks whether it will be possible to setup sync for this project or repository at the end of import
  """
  issueImportCheckSync(
    """The ID of the issue import for which to check sync eligibility"""
    issueImportId: String!
  ): IssueImportSyncCheckPayload!

  """
  Checks whether a custom JQL query is valid and can be used to filter issues of a Jira import
  """
  issueImportJqlCheck(
    """Jira user account email."""
    jiraEmail: String!

    """Jira installation or cloud hostname."""
    jiraHostname: String!

    """Jira project key to use as the base filter of the query."""
    jiraProject: String!

    """Jira personal access token to access Jira REST API."""
    jiraToken: String!

    """The JQL query to validate."""
    jql: String!
  ): IssueImportJqlCheckPayload!

  """One specific label."""
  issueLabel(id: String!): IssueLabel!

  """All issue labels."""
  issueLabels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issue labels."""
    filter: IssueLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """Issue priority values and corresponding labels."""
  issuePriorityValues: [IssuePriorityValue!]!

  """One specific issue relation."""
  issueRelation(id: String!): IssueRelation!

  """All issue relationships."""
  issueRelations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueRelationConnection!

  """
  [DEPRECATED] Search issues. This endpoint is deprecated and will be removed in the future  use `searchIssues` instead.
  """
  issueSearch(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[Deprecated] Search string to look for."""
    query: String
  ): IssueConnection!

  """Suggests issue title based on a customer request."""
  issueTitleSuggestionFromCustomerRequest(request: String!): IssueTitleSuggestionFromCustomerRequestPayload!

  """Find issue based on the VCS branch name."""
  issueVcsBranchSearch(
    """The VCS branch name to search for."""
    branchName: String!
  ): Issue

  """All issues."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned issues."""
    sort: [IssueSortInput!]
  ): IssueConnection!

  """One specific notification."""
  notification(id: String!): Notification!

  """One specific notification subscription."""
  notificationSubscription(id: String!): NotificationSubscription!

  """The user's notification subscriptions."""
  notificationSubscriptions(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): NotificationSubscriptionConnection!

  """All notifications."""
  notifications(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filters returned notifications."""
    filter: NotificationFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): NotificationConnection!

  """[Internal] A number of unread notifications."""
  notificationsUnreadCount: Int!

  """The user's organization."""
  organization: Organization!

  """[INTERNAL] Checks whether the domain can be claimed."""
  organizationDomainClaimRequest(
    """The ID of the organization domain to claim."""
    id: String!
  ): OrganizationDomainClaimPayload!

  """Does the organization exist."""
  organizationExists(urlKey: String!): OrganizationExistsPayload!

  """One specific organization invite."""
  organizationInvite(id: String!): OrganizationInvite!

  """One specific organization invite."""
  organizationInviteDetails(id: String!): OrganizationInviteDetailsPayload!

  """All invites for the organization."""
  organizationInvites(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): OrganizationInviteConnection!

  """[INTERNAL] Get organization metadata by urlKey or organization id."""
  organizationMeta(urlKey: String!): OrganizationMeta

  """One specific project."""
  project(id: String!): Project!

  """Suggests filters for a project view based on a text prompt."""
  projectFilterSuggestion(prompt: String!): ProjectFilterSuggestionPayload!

  """One specific label."""
  projectLabel(id: String!): ProjectLabel!

  """All project labels."""
  projectLabels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned project labels."""
    filter: ProjectLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectLabelConnection!

  """One specific project milestone."""
  projectMilestone(id: String!): ProjectMilestone!

  """All milestones for the project."""
  projectMilestones(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned project milestones."""
    filter: ProjectMilestoneFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectMilestoneConnection!

  """One specific project relation."""
  projectRelation(id: String!): ProjectRelation!

  """All project relationships."""
  projectRelations(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectRelationConnection!

  """One specific project status."""
  projectStatus(id: String!): ProjectStatus!

  """
  [INTERNAL] Count of projects using this project status across the organization.
  """
  projectStatusProjectCount(
    """The identifier of the project status to find the project count for."""
    id: String!
  ): ProjectStatusCountPayload!

  """All project statuses."""
  projectStatuses(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectStatusConnection!

  """A specific project update."""
  projectUpdate(
    """The identifier of the project update to retrieve."""
    id: String!
  ): ProjectUpdate!

  """All project updates."""
  projectUpdates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned project updates."""
    filter: ProjectUpdateFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectUpdateConnection!

  """All projects."""
  projects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned projects."""
    filter: ProjectFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned projects."""
    sort: [ProjectSortInput!]
  ): ProjectConnection!

  """Sends a test push message."""
  pushSubscriptionTest(
    """The send strategy to use."""
    sendStrategy: SendStrategy = push

    """Whether to send to mobile devices."""
    targetMobile: Boolean = false
  ): PushSubscriptionTestPayload!

  """The status of the rate limiter."""
  rateLimitStatus: RateLimitPayload!

  """One specific roadmap."""
  roadmap(id: String!): Roadmap! @deprecated(reason: "Roadmaps are deprecated, use initiatives instead.")

  """One specific roadmapToProject."""
  roadmapToProject(id: String!): RoadmapToProject! @deprecated(reason: "RoadmapToProject is deprecated, use InitiativeToProject instead.")
  roadmapToProjects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): RoadmapToProjectConnection! @deprecated(reason: "RoadmapToProject is deprecated, use InitiativeToProject instead.")

  """All roadmaps in the workspace."""
  roadmaps(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): RoadmapConnection! @deprecated(reason: "Roadmaps are deprecated, use initiatives instead.")

  """Search documents."""
  searchDocuments(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should associated comments be searched (default: false)."""
    includeComments: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """Size of search snippet to return (default: 100)"""
    snippetSize: Float @deprecated(reason: "No longer supported.")

    """UUID of a team to use as a boost."""
    teamId: String

    """Search string to look for."""
    term: String!
  ): DocumentSearchPayload!

  """Search issues."""
  searchIssues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should associated comments be searched (default: false)."""
    includeComments: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """Size of search snippet to return (default: 100)"""
    snippetSize: Float @deprecated(reason: "No longer supported.")

    """UUID of a team to use as a boost."""
    teamId: String

    """Search string to look for."""
    term: String!
  ): IssueSearchPayload!

  """Search projects."""
  searchProjects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should associated comments be searched (default: false)."""
    includeComments: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """Size of search snippet to return (default: 100)"""
    snippetSize: Float @deprecated(reason: "No longer supported.")

    """UUID of a team to use as a boost."""
    teamId: String

    """Search string to look for."""
    term: String!
  ): ProjectSearchPayload!

  """[INTERNAL] Search for various resources using natural language."""
  semanticSearch(
    """Whether to include archived results in the search (default: false)."""
    includeArchived: Boolean

    """The maximum number of results to return (default: 10)."""
    maxResults: Int

    """Search query to look for."""
    query: String!

    """The types of results to return (default: all)."""
    types: [SemanticSearchResultType!]
  ): SemanticSearchPayload! @deprecated(reason: "Use specific search endpoints like searchIssues, searchProjects, searchDocuments instead.")

  """Fetch SSO login URL for the email provided."""
  ssoUrlFromEmail(
    """Email to query the SSO login URL by."""
    email: String!

    """Whether the client is the desktop app."""
    isDesktop: Boolean
  ): SsoUrlFromEmailResponse!

  """
  [Internal] AI summary of the latest project updates for the given projects
  """
  summarizeProjectUpdates(
    """The identifiers of the projects to summarize."""
    ids: [String!]!
  ): SummaryPayload!

  """One specific team."""
  team(id: String!): Team!

  """One specific team membership."""
  teamMembership(id: String!): TeamMembership!

  """All team memberships."""
  teamMemberships(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamMembershipConnection!

  """
  All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
  """
  teams(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned teams."""
    filter: TeamFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """A specific template."""
  template(
    """The identifier of the template to retrieve."""
    id: String!
  ): Template!

  """All templates from all users."""
  templates: [Template!]!

  """Returns all templates that are associated with the integration type."""
  templatesForIntegration(
    """The type of integration for which to return associated templates."""
    integrationType: String!
  ): [Template!]!

  """A specific time schedule."""
  timeSchedule(
    """The identifier of the time schedule to retrieve."""
    id: String!
  ): TimeSchedule!

  """All time schedules."""
  timeSchedules(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TimeScheduleConnection!

  """All triage responsibilities."""
  triageResponsibilities(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TriageResponsibilityConnection!

  """A specific triage responsibility."""
  triageResponsibility(
    """The identifier of the triage responsibility to retrieve."""
    id: String!
  ): TriageResponsibility!

  """One specific user."""
  user(
    """
    The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
    """
    id: String!
  ): User!

  """The user's settings."""
  userSettings: UserSettings!

  """All users for the organization."""
  users(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned users."""
    filter: UserFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """
  Verify that we received the correct response from the GitHub Enterprise Server.
  """
  verifyGitHubEnterpriseServerInstallation(
    """The integration ID."""
    integrationId: String!
  ): GitHubEnterpriseServerInstallVerificationPayload!

  """The currently authenticated user."""
  viewer: User!

  """A specific webhook."""
  webhook(
    """The identifier of the webhook to retrieve."""
    id: String!
  ): Webhook!

  """All webhooks."""
  webhooks(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WebhookConnection!

  """One specific state."""
  workflowState(id: String!): WorkflowState!

  """All issue workflow states."""
  workflowStates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned workflow states."""
    filter: WorkflowStateFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WorkflowStateConnection!

  """
  [INTERNAL] Get a specific non-internal authorized application (with limited fields) for a workspace
  """
  workspaceAuthorizedApplication(
    """The client ID of the application."""
    clientId: String!
  ): WorkspaceAuthorizedApplicationWithMemberships!

  """
  [DEPRECATED] [INTERNAL] Get non-internal authorized applications (with limited fields) for a workspace
  """
  workspaceAuthorizedApplications: [WorkspaceAuthorizedApplication!]! @deprecated(reason: "Use more efficient `workspaceAuthorizedApplicationsWithAppUser` and `workspaceAuthorizedApplication` instead.")

  """
  [INTERNAL] Get non-internal authorized applications for a workspace, including each application's app user.
  """
  workspaceAuthorizedApplicationsWithAppUser(
    """
    Client IDs of specific applications to return. If not provided, all workspace-authorized applications will be returned.
    """
    clientIds: [String!]
  ): [WorkspaceAuthorizedApplicationWithAppUser!]!
}

type RateLimitPayload {
  """The identifier we rate limit on."""
  identifier: String

  """The kind of rate limit selected for this request."""
  kind: String!

  """The state of the rate limit."""
  limits: [RateLimitResultPayload!]!
}

type RateLimitResultPayload {
  """The total allowed quantity for this type of limit."""
  allowedAmount: Float!

  """The period in which the rate limit is fully replenished in ms."""
  period: Float!

  """The remaining quantity for this type of limit after this request."""
  remainingAmount: Float!

  """The requested quantity for this type of limit."""
  requestedAmount: Float!

  """
  The timestamp after the rate limit is fully replenished as a UNIX timestamp.
  """
  reset: Float!

  """What is being rate limited."""
  type: String!
}

"""A reaction associated with a comment or a project update."""
type Reaction implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The comment that the reaction is associated with."""
  comment: Comment

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Name of the reaction's emoji."""
  emoji: String!

  """The external user that created the reaction."""
  externalUser: ExternalUser

  """The unique identifier of the entity."""
  id: ID!

  """The initiative update that the reaction is associated with."""
  initiativeUpdate: InitiativeUpdate

  """The issue that the reaction is associated with."""
  issue: Issue

  """The post that the reaction is associated with."""
  post: Post

  """The project update that the reaction is associated with."""
  projectUpdate: ProjectUpdate

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user that created the reaction."""
  user: User
}

"""Reaction filtering options."""
input ReactionCollectionFilter {
  """Compound filters, all of which need to be matched by the reaction."""
  and: [ReactionCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the reactions custom emoji."""
  customEmojiId: IDComparator

  """Comparator for the reactions emoji."""
  emoji: StringComparator

  """Filters that needs to be matched by all reactions."""
  every: ReactionFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Compound filters, one of which need to be matched by the reaction."""
  or: [ReactionCollectionFilter!]

  """Filters that needs to be matched by some reactions."""
  some: ReactionFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

input ReactionCreateInput {
  """The comment to associate the reaction with."""
  commentId: String

  """The emoji the user reacted with."""
  emoji: String!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The update to associate the reaction with."""
  initiativeUpdateId: String

  """The issue to associate the reaction with."""
  issueId: String

  """[Internal] The post to associate the reaction with."""
  postId: String

  """The project update to associate the reaction with."""
  projectUpdateId: String

  """[Internal] The pull request comment to associate the reaction with."""
  pullRequestCommentId: String

  """[Internal] The pull request to associate the reaction with."""
  pullRequestId: String
}

"""Reaction filtering options."""
input ReactionFilter {
  """Compound filters, all of which need to be matched by the reaction."""
  and: [ReactionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the reactions custom emoji."""
  customEmojiId: IDComparator

  """Comparator for the reactions emoji."""
  emoji: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Compound filters, one of which need to be matched by the reaction."""
  or: [ReactionFilter!]

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type ReactionPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!
  reaction: Reaction!
  success: Boolean!
}

"""Comparator for relation existence."""
input RelationExistsComparator {
  """Equals constraint."""
  eq: Boolean

  """Not equals constraint."""
  neq: Boolean
}

"""Features release channel."""
enum ReleaseChannel {
  beta
  development
  internal
  preRelease
  public
}

"""Customer revenue sorting options."""
input RevenueSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""[Deprecated] A roadmap for projects."""
type Roadmap implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The roadmap's color."""
  color: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the roadmap."""
  creator: User!

  """The description of the roadmap."""
  description: String

  """The unique identifier of the entity."""
  id: ID!

  """The name of the roadmap."""
  name: String!

  """The organization of the roadmap."""
  organization: Organization!

  """The user who owns the roadmap."""
  owner: User

  """Projects associated with the roadmap."""
  projects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned projects."""
    filter: ProjectFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): ProjectConnection!

  """The roadmap's unique URL slug."""
  slugId: String!

  """The sort order of the roadmap within the organization."""
  sortOrder: Float!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The canonical url for the roadmap."""
  url: String!
}

"""A generic payload return from entity archive mutations."""
type RoadmapArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Roadmap

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Roadmap collection filtering options."""
input RoadmapCollectionFilter {
  """Compound filters, all of which need to be matched by the roadmap."""
  and: [RoadmapCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the roadmap creator must satisfy."""
  creator: UserFilter

  """Filters that needs to be matched by all roadmaps."""
  every: RoadmapFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Comparator for the roadmap name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the roadmap."""
  or: [RoadmapCollectionFilter!]

  """Comparator for the roadmap slug ID."""
  slugId: StringComparator

  """Filters that needs to be matched by some roadmaps."""
  some: RoadmapFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type RoadmapConnection {
  edges: [RoadmapEdge!]!
  nodes: [Roadmap!]!
  pageInfo: PageInfo!
}

input RoadmapCreateInput {
  """The roadmap's color."""
  color: String

  """The description of the roadmap."""
  description: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the roadmap."""
  name: String!

  """The owner of the roadmap."""
  ownerId: String

  """The sort order of the roadmap within the organization."""
  sortOrder: Float
}

type RoadmapEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Roadmap!
}

"""Roadmap filtering options."""
input RoadmapFilter {
  """Compound filters, all of which need to be matched by the roadmap."""
  and: [RoadmapFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that the roadmap creator must satisfy."""
  creator: UserFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the roadmap name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the roadmap."""
  or: [RoadmapFilter!]

  """Comparator for the roadmap slug ID."""
  slugId: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type RoadmapPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The roadmap that was created or updated."""
  roadmap: Roadmap!

  """Whether the operation was successful."""
  success: Boolean!
}

"""[Deprecated] Join table between projects and roadmaps."""
type RoadmapToProject implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The project that the roadmap is associated with."""
  project: Project!

  """The roadmap that the project is associated with."""
  roadmap: Roadmap!

  """The sort order of the project within the roadmap."""
  sortOrder: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type RoadmapToProjectConnection {
  edges: [RoadmapToProjectEdge!]!
  nodes: [RoadmapToProject!]!
  pageInfo: PageInfo!
}

input RoadmapToProjectCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The identifier of the project."""
  projectId: String!

  """The identifier of the roadmap."""
  roadmapId: String!

  """The sort order for the project within its organization."""
  sortOrder: Float
}

type RoadmapToProjectEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: RoadmapToProject!
}

type RoadmapToProjectPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """The roadmapToProject that was created or updated."""
  roadmapToProject: RoadmapToProject!

  """Whether the operation was successful."""
  success: Boolean!
}

input RoadmapToProjectUpdateInput {
  """The sort order for the project within its organization."""
  sortOrder: Float
}

input RoadmapUpdateInput {
  """The roadmap's color."""
  color: String

  """The description of the roadmap."""
  description: String

  """The name of the roadmap."""
  name: String

  """The owner of the roadmap."""
  ownerId: String

  """The sort order of the roadmap within the organization."""
  sortOrder: Float
}

"""Issue root-issue sorting options."""
input RootIssueSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder

  """The sort to apply to the root issues"""
  sort: IssueSortInput!
}

enum SLADayCountType {
  all
  onlyBusinessDays
}

input SalesforceSettingsInput {
  """
  Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
  """
  automateTicketReopeningOnCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
  """
  automateTicketReopeningOnComment: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear issue is completed.
  """
  automateTicketReopeningOnCompletion: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is cancelled.
  """
  automateTicketReopeningOnProjectCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is completed.
  """
  automateTicketReopeningOnProjectCompletion: Boolean

  """The Salesforce team to use when a template doesn't specify a team."""
  defaultTeam: String

  """
  [ALPHA] Whether customer and customer requests should not be automatically created when conversations are linked to a Linear issue.
  """
  disableCustomerRequestsAutoCreation: Boolean

  """The Salesforce case status to use to reopen cases."""
  reopenCaseStatus: String

  """
  Whether to restrict visibility of the integration to issues that have been either created from Salesforce or linked to Salesforce.
  """
  restrictVisibility: Boolean

  """
  Whether an internal message should be added when someone comments on an issue.
  """
  sendNoteOnComment: Boolean

  """
  Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
  """
  sendNoteOnStatusChange: Boolean

  """The Salesforce subdomain."""
  subdomain: String

  """The Salesforce instance URL."""
  url: String
}

"""[INTERNAL] Payload returned by semantic search."""
type SemanticSearchPayload {
  enabled: Boolean!
  results: [SemanticSearchResult!]!
}

"""[INTERNAL] A semantic search result reference."""
type SemanticSearchResult implements Node {
  """The document related to the semantic search result."""
  document: Document

  """The unique identifier of the entity."""
  id: ID!

  """The initiative related to the semantic search result."""
  initiative: Initiative

  """The issue related to the semantic search result."""
  issue: Issue

  """The project related to the semantic search result."""
  project: Project

  """The type of the semantic search result."""
  type: SemanticSearchResultType!
}

"""[INTERNAL] The type of the semantic search result."""
enum SemanticSearchResultType {
  document
  initiative
  issue
  project
}

enum SendStrategy {
  desktop
  desktopAndPush
  desktopThenPush
  push
}

input SentrySettingsInput {
  """The ID of the Sentry organization being connected."""
  organizationId: ID!

  """The slug of the Sentry organization being connected."""
  organizationSlug: String!

  """Whether Sentry issues resolving completes Linear issues."""
  resolvingCompletesIssues: Boolean!

  """Whether Sentry issues unresolving reopens Linear issues."""
  unresolvingReopensIssues: Boolean!
}

"""SES domain identity used for sending emails from a custom domain."""
type SesDomainIdentity implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  Whether the domain is fully verified and can be used for sending emails.
  """
  canSendFromCustomDomain: Boolean!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the SES domain identity."""
  creator: User

  """The DNS records for the SES domain identity."""
  dnsRecords: [SesDomainIdentityDnsRecord!]!

  """The domain of the SES domain identity."""
  domain: String!

  """The unique identifier of the entity."""
  id: ID!

  """The organization of the SES domain identity."""
  organization: Organization!

  """The AWS region of the SES domain identity."""
  region: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""A DNS record for a SES domain identity."""
type SesDomainIdentityDnsRecord {
  """The content of the DNS record."""
  content: String!

  """Whether the DNS record is verified in the domain's DNS configuration."""
  isVerified: Boolean!

  """The name of the DNS record."""
  name: String!

  """The type of the DNS record."""
  type: String!
}

"""Customer size sorting options."""
input SizeSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

enum SlaStatus {
  Breached
  Completed
  Failed
  HighRisk
  LowRisk
  MediumRisk
}

"""Comparator for sla status."""
input SlaStatusComparator {
  """Equals constraint."""
  eq: SlaStatus

  """In-array constraint."""
  in: [SlaStatus!]

  """Not-equals constraint."""
  neq: SlaStatus

  """Not-in-array constraint."""
  nin: [SlaStatus!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean
}

"""Issue SLA status sorting options."""
input SlaStatusSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input SlackAsksSettingsInput {
  """The user role type that is allowed to manage Asks settings."""
  canAdministrate: UserRoleType!

  """Enterprise id of the connected Slack enterprise"""
  enterpriseId: String

  """Enterprise name of the connected Slack enterprise"""
  enterpriseName: String

  """Whether to show unfurl previews in Slack"""
  shouldUnfurl: Boolean

  """
  The mapping of Slack channel ID => Slack channel name for connected channels.
  """
  slackChannelMapping: [SlackChannelNameMappingInput!]

  """Slack workspace id"""
  teamId: String

  """Slack workspace name"""
  teamName: String
}

"""Tuple for mapping Slack channel IDs to names."""
type SlackAsksTeamSettings {
  """
  Whether the default Asks template is enabled in the given channel for this team.
  """
  hasDefaultAsk: Boolean!

  """The Linear team ID."""
  id: String!
}

input SlackAsksTeamSettingsInput {
  """
  Whether the default Asks template is enabled in the given channel for this team.
  """
  hasDefaultAsk: Boolean!

  """The Linear team ID."""
  id: String!
}

type SlackChannelConnectPayload {
  """Whether the bot needs to be manually added to the channel."""
  addBot: Boolean!

  """The integration that was created or updated."""
  integration: Integration

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether it's recommended to connect main Slack integration."""
  nudgeToConnectMainSlackIntegration: Boolean

  """Whether it's recommended to update main Slack integration."""
  nudgeToUpdateMainSlackIntegration: Boolean

  """Whether the operation was successful."""
  success: Boolean!
}

"""Object for mapping Slack channel IDs to names and other settings."""
type SlackChannelNameMapping {
  """
  Whether or not to use AI to generate titles for Asks created in this channel.
  """
  aiTitles: Boolean

  """
  Whether or not @-mentioning the bot should automatically create an Ask with the message.
  """
  autoCreateOnBotMention: Boolean

  """
  Whether or not using the :ticket: emoji in this channel should automatically create Asks.
  """
  autoCreateOnEmoji: Boolean

  """
  Whether or not top-level messages in this channel should automatically create Asks.
  """
  autoCreateOnMessage: Boolean

  """
  The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template.
  """
  autoCreateTemplateId: String

  """
  Whether or not the Linear Asks bot has been added to this Slack channel.
  """
  botAdded: Boolean

  """The Slack channel ID."""
  id: String!

  """Whether or not the Slack channel is private."""
  isPrivate: Boolean

  """Whether or not the Slack channel is shared with an external org."""
  isShared: Boolean

  """The Slack channel name."""
  name: String!

  """
  Whether or not synced Slack threads should be updated with a message when their Ask is accepted from triage.
  """
  postAcceptedFromTriageUpdates: Boolean

  """
  Whether or not synced Slack threads should be updated with a message and emoji when their Ask is canceled.
  """
  postCancellationUpdates: Boolean

  """
  Whether or not synced Slack threads should be updated with a message and emoji when their Ask is completed.
  """
  postCompletionUpdates: Boolean

  """Which teams are connected to the channel and settings for those teams."""
  teams: [SlackAsksTeamSettings!]!
}

input SlackChannelNameMappingInput {
  """
  Whether or not to use AI to generate titles for Asks created in this channel.
  """
  aiTitles: Boolean

  """
  Whether or not @-mentioning the bot should automatically create an Ask with the message.
  """
  autoCreateOnBotMention: Boolean

  """
  Whether or not using the :ticket: emoji in this channel should automatically create Asks.
  """
  autoCreateOnEmoji: Boolean

  """
  Whether or not top-level messages in this channel should automatically create Asks.
  """
  autoCreateOnMessage: Boolean

  """
  The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template.
  """
  autoCreateTemplateId: String

  """
  Whether or not the Linear Asks bot has been added to this Slack channel.
  """
  botAdded: Boolean

  """The Slack channel ID."""
  id: String!

  """Whether or not the Slack channel is private."""
  isPrivate: Boolean

  """Whether or not the Slack channel is shared with an external org."""
  isShared: Boolean

  """The Slack channel name."""
  name: String!

  """
  Whether or not synced Slack threads should be updated with a message when their Ask is accepted from triage.
  """
  postAcceptedFromTriageUpdates: Boolean

  """
  Whether or not synced Slack threads should be updated with a message and emoji when their Ask is canceled.
  """
  postCancellationUpdates: Boolean

  """
  Whether or not synced Slack threads should be updated with a message and emoji when their Ask is completed.
  """
  postCompletionUpdates: Boolean

  """Which teams are connected to the channel and settings for those teams."""
  teams: [SlackAsksTeamSettingsInput!]!
}

enum SlackChannelType {
  DirectMessage
  MultiPersonDirectMessage
  Private
  Public
}

input SlackPostSettingsInput {
  channel: String!
  channelId: String!
  channelType: SlackChannelType
  configurationUrl: String!

  """Slack workspace id"""
  teamId: String
}

input SlackSettingsInput {
  """Enterprise id of the connected Slack enterprise"""
  enterpriseId: String

  """Enterprise name of the connected Slack enterprise"""
  enterpriseName: String

  """
  Whether Linear should automatically respond with issue unfurls when an issue identifier is mentioned in a Slack message.
  """
  linkOnIssueIdMention: Boolean!

  """Whether to show unfurl previews in Slack"""
  shouldUnfurl: Boolean

  """Slack workspace id"""
  teamId: String

  """Slack workspace name"""
  teamName: String
}

"""Comparator for issue source type."""
input SourceMetadataComparator {
  """Equals constraint."""
  eq: String

  """In-array constraint."""
  in: [String!]

  """Not-equals constraint."""
  neq: String

  """Not-in-array constraint."""
  nin: [String!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean

  """Compound filters, all of which need to be matched by the sub type."""
  subType: SubTypeComparator
}

"""Comparator for `sourceType` field."""
input SourceTypeComparator {
  """Contains constraint. Matches any values that contain the given string."""
  contains: String

  """
  Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
  """
  containsIgnoreCase: String

  """
  Contains case and accent insensitive constraint. Matches any values that contain the given string case and accent insensitive.
  """
  containsIgnoreCaseAndAccent: String

  """
  Ends with constraint. Matches any values that end with the given string.
  """
  endsWith: String

  """Equals constraint."""
  eq: String

  """
  Equals case insensitive. Matches any values that matches the given string case insensitive.
  """
  eqIgnoreCase: String

  """In-array constraint."""
  in: [String!]

  """Not-equals constraint."""
  neq: String

  """
  Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
  """
  neqIgnoreCase: String

  """Not-in-array constraint."""
  nin: [String!]

  """
  Doesn't contain constraint. Matches any values that don't contain the given string.
  """
  notContains: String

  """
  Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
  """
  notContainsIgnoreCase: String

  """
  Doesn't end with constraint. Matches any values that don't end with the given string.
  """
  notEndsWith: String

  """
  Doesn't start with constraint. Matches any values that don't start with the given string.
  """
  notStartsWith: String

  """
  Starts with constraint. Matches any values that start with the given string.
  """
  startsWith: String

  """
  Starts with case insensitive constraint. Matches any values that start with the given string.
  """
  startsWithIgnoreCase: String
}

type SsoUrlFromEmailResponse {
  """SAML SSO sign-in URL."""
  samlSsoUrl: String!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Project start date sorting options."""
input StartDateSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Comparator for strings."""
input StringArrayComparator {
  """Compound filters, all of which need to be matched."""
  every: StringItemComparator

  """Length of the array. Matches any values that have the given length."""
  length: NumberComparator

  """Compound filters, one of which needs to be matched."""
  some: StringItemComparator
}

"""Comparator for strings."""
input StringComparator {
  """Contains constraint. Matches any values that contain the given string."""
  contains: String

  """
  Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
  """
  containsIgnoreCase: String

  """
  Contains case and accent insensitive constraint. Matches any values that contain the given string case and accent insensitive.
  """
  containsIgnoreCaseAndAccent: String

  """
  Ends with constraint. Matches any values that end with the given string.
  """
  endsWith: String

  """Equals constraint."""
  eq: String

  """
  Equals case insensitive. Matches any values that matches the given string case insensitive.
  """
  eqIgnoreCase: String

  """In-array constraint."""
  in: [String!]

  """Not-equals constraint."""
  neq: String

  """
  Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
  """
  neqIgnoreCase: String

  """Not-in-array constraint."""
  nin: [String!]

  """
  Doesn't contain constraint. Matches any values that don't contain the given string.
  """
  notContains: String

  """
  Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
  """
  notContainsIgnoreCase: String

  """
  Doesn't end with constraint. Matches any values that don't end with the given string.
  """
  notEndsWith: String

  """
  Doesn't start with constraint. Matches any values that don't start with the given string.
  """
  notStartsWith: String

  """
  Starts with constraint. Matches any values that start with the given string.
  """
  startsWith: String

  """
  Starts with case insensitive constraint. Matches any values that start with the given string.
  """
  startsWithIgnoreCase: String
}

"""Comparator for strings in arrays."""
input StringItemComparator {
  """Contains constraint. Matches any values that contain the given string."""
  contains: String

  """
  Contains case insensitive constraint. Matches any values that contain the given string case insensitive.
  """
  containsIgnoreCase: String

  """
  Contains case and accent insensitive constraint. Matches any values that contain the given string case and accent insensitive.
  """
  containsIgnoreCaseAndAccent: String

  """
  Ends with constraint. Matches any values that end with the given string.
  """
  endsWith: String

  """Equals constraint."""
  eq: String

  """
  Equals case insensitive. Matches any values that matches the given string case insensitive.
  """
  eqIgnoreCase: String

  """In-array constraint."""
  in: [String!]

  """Not-equals constraint."""
  neq: String

  """
  Not-equals case insensitive. Matches any values that don't match the given string case insensitive.
  """
  neqIgnoreCase: String

  """Not-in-array constraint."""
  nin: [String!]

  """
  Doesn't contain constraint. Matches any values that don't contain the given string.
  """
  notContains: String

  """
  Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive.
  """
  notContainsIgnoreCase: String

  """
  Doesn't end with constraint. Matches any values that don't end with the given string.
  """
  notEndsWith: String

  """
  Doesn't start with constraint. Matches any values that don't start with the given string.
  """
  notStartsWith: String

  """
  Starts with constraint. Matches any values that start with the given string.
  """
  startsWith: String

  """
  Starts with case insensitive constraint. Matches any values that start with the given string.
  """
  startsWithIgnoreCase: String
}

"""Comparator for source type."""
input SubTypeComparator {
  """Equals constraint."""
  eq: String

  """In-array constraint."""
  in: [String!]

  """Not-equals constraint."""
  neq: String

  """Not-in-array constraint."""
  nin: [String!]

  """
  Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values.
  """
  null: Boolean
}

type SuccessPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type SummaryPayload {
  """Summary for project updates."""
  summary: String!
}

"""A comment thread that is synced with an external source."""
type SyncedExternalThread {
  """The display name of the thread."""
  displayName: String
  id: ID

  """Whether this thread is syncing with the external service."""
  isConnected: Boolean!

  """
  Whether the current user has the corresponding personal integration connected for the external service.
  """
  isPersonalIntegrationConnected: Boolean!

  """
  Whether a connected personal integration is required to comment in this thread.
  """
  isPersonalIntegrationRequired: Boolean!

  """The display name of the source."""
  name: String

  """The sub type of the external source."""
  subType: String

  """The type of the external source."""
  type: String!

  """The external url of the thread."""
  url: String
}

"""Project target date sorting options."""
input TargetDateSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""An organizational unit that contains issues."""
type Team implements Node {
  """Team's currently active cycle."""
  activeCycle: Cycle

  """Whether to enable resolved thread AI summaries."""
  aiThreadSummariesEnabled: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  Period after which automatically closed and completed issues are automatically archived in months.
  """
  autoArchivePeriod: Float!

  """
  Whether child issues should automatically close when their parent issue is closed
  """
  autoCloseChildIssues: Boolean

  """
  Whether parent issues should automatically close when all child issues are closed
  """
  autoCloseParentIssues: Boolean

  """
  Period after which issues are automatically closed in months. Null/undefined means disabled.
  """
  autoClosePeriod: Float

  """
  The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
  """
  autoCloseStateId: String

  """[Internal] The team's sub-teams."""
  children: [Team!]!

  """The team's color."""
  color: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """[Internal] The current progress of the team."""
  currentProgress: JSONObject!

  """Calendar feed URL (iCal) for cycles."""
  cycleCalenderUrl: String!

  """The cooldown time after each cycle in weeks."""
  cycleCooldownTime: Float!

  """The duration of a cycle in weeks."""
  cycleDuration: Float!

  """Auto assign completed issues to current cycle."""
  cycleIssueAutoAssignCompleted: Boolean!

  """Auto assign started issues to current cycle."""
  cycleIssueAutoAssignStarted: Boolean!

  """Auto assign issues to current cycle if in active status."""
  cycleLockToActive: Boolean!

  """The day of the week that a new cycle starts."""
  cycleStartDay: Float!

  """Cycles associated with the team."""
  cycles(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned cycles."""
    filter: CycleFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): CycleConnection!

  """Whether the team uses cycles."""
  cyclesEnabled: Boolean!

  """What to use as a default estimate for unestimated issues."""
  defaultIssueEstimate: Float!

  """
  The default workflow state into which issues are set when they are opened by team members.
  """
  defaultIssueState: WorkflowState

  """The default template to use for new projects created for the team."""
  defaultProjectTemplate: Template

  """
  The default template to use for new issues created by members of the team.
  """
  defaultTemplateForMembers: Template

  """
  The id of the default template to use for new issues created by members of the team.
  """
  defaultTemplateForMembersId: String @deprecated(reason: "Use defaultTemplateForMembers instead")

  """
  The default template to use for new issues created by non-members of the team.
  """
  defaultTemplateForNonMembers: Template

  """
  The id of the default template to use for new issues created by non-members of the team.
  """
  defaultTemplateForNonMembersId: String @deprecated(reason: "Use defaultTemplateForNonMembers instead")

  """The team's description."""
  description: String

  """The name of the team including it's parent team name if it has one."""
  displayName: String!

  """
  The workflow state into which issues are moved when a PR has been opened as draft.
  """
  draftWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")

  """[Internal] Facets associated with the team."""
  facets: [Facet!]!

  """The Git automation states for the team."""
  gitAutomationStates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): GitAutomationStateConnection!

  """Whether to group recent issue history entries."""
  groupIssueHistory: Boolean!

  """The icon of the team."""
  icon: String

  """The unique identifier of the entity."""
  id: ID!

  """
  Whether the team should inherit its estimation settings from its parent. Only applies to sub-teams.
  """
  inheritIssueEstimation: Boolean!

  """
  Whether the team should inherit its workflow statuses from its parent. Only applies to sub-teams.
  """
  inheritWorkflowStatuses: Boolean!

  """Settings for all integrations associated with that team."""
  integrationsSettings: IntegrationsSettings

  """Unique hash for the team to be used in invite URLs."""
  inviteHash: String!

  """Number of issues in the team."""
  issueCount(
    """Include archived issues in the count."""
    includeArchived: Boolean = false
  ): Int!

  """Whether to allow zeros in issues estimates."""
  issueEstimationAllowZero: Boolean!

  """Whether to add additional points to the estimate scale."""
  issueEstimationExtended: Boolean!

  """
  The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
  """
  issueEstimationType: String!

  """[DEPRECATED] Whether issues without priority should be sorted first."""
  issueOrderingNoPriorityFirst: Boolean! @deprecated(reason: "This setting is no longer in use.")

  """
  [DEPRECATED] Whether to move issues to bottom of the column when changing state.
  """
  issueSortOrderDefaultToBottom: Boolean! @deprecated(reason: "Use setIssueSortOrderOnStateChange instead.")

  """Issues associated with the team."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Include issues from sub-teams."""
    includeSubTeams: Boolean = false

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """[Internal] Whether new users should join this team by default."""
  joinByDefault: Boolean

  """The team's unique key. The key is used in URLs."""
  key: String!

  """Labels associated with the team."""
  labels(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issue labels."""
    filter: IssueLabelFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueLabelConnection!

  """
  The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
  """
  markedAsDuplicateWorkflowState: WorkflowState

  """Users who are members of this team."""
  members(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned users."""
    filter: UserFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Should query return disabled/suspended users (default: false)."""
    includeDisabled: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): UserConnection!

  """[ALPHA] The membership of the given user in the team."""
  membership(
    """The user ID."""
    userId: String!
  ): TeamMembership

  """
  Memberships associated with the team. For easier access of the same data, use `members` query.
  """
  memberships(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamMembershipConnection!

  """
  The workflow state into which issues are moved when a PR has been merged.
  """
  mergeWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")

  """
  The workflow state into which issues are moved when a PR is ready to be merged.
  """
  mergeableWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")

  """The team's name."""
  name: String!

  """The organization that the team is associated with."""
  organization: Organization!

  """[Internal] The team's parent team."""
  parent: Team

  """[Internal] Posts associated with the team."""
  posts: [Post!]!

  """Whether the team is private or not."""
  private: Boolean!

  """[Internal] The progress history of the team."""
  progressHistory: JSONObject!

  """Projects associated with the team."""
  projects(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned projects."""
    filter: ProjectFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """Include projects from sub-teams."""
    includeSubTeams: Boolean = false

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy

    """[INTERNAL] Sort returned projects."""
    sort: [ProjectSortInput!]
  ): ProjectConnection!

  """Whether an issue needs to have a priority set before leaving triage."""
  requirePriorityToLeaveTriage: Boolean!

  """
  The workflow state into which issues are moved when a review has been requested for the PR.
  """
  reviewWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")

  """The SCIM group name for the team."""
  scimGroupName: String

  """Whether the team is managed by SCIM integration."""
  scimManaged: Boolean!

  """Where to move issues when changing state."""
  setIssueSortOrderOnStateChange: String!

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean! @deprecated(reason: "No longer in use")

  """Whether to send new issue status updates to Slack."""
  slackIssueStatuses: Boolean! @deprecated(reason: "No longer in use")

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean! @deprecated(reason: "No longer is use")

  """
  The workflow state into which issues are moved when a PR has been opened.
  """
  startWorkflowState: WorkflowState @deprecated(reason: "Use team.gitAutomationStates instead.")

  """The states that define the workflow associated with the team."""
  states(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned workflow states."""
    filter: WorkflowStateFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WorkflowStateConnection!

  """Templates associated with the team."""
  templates(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned templates."""
    filter: NullableTemplateFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TemplateConnection!

  """
  The timezone of the team. Defaults to "America/Los_Angeles"
  """
  timezone: String!

  """Whether triage mode is enabled for the team or not."""
  triageEnabled: Boolean!

  """
  The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled.
  """
  triageIssueState: WorkflowState

  """Team's triage responsibility."""
  triageResponsibility: TriageResponsibility

  """How many upcoming cycles to create."""
  upcomingCycleCount: Float!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Webhooks associated with the team."""
  webhooks(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): WebhookConnection!
}

"""A generic payload return from entity archive mutations."""
type TeamArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: Team

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

"""Team collection filtering options."""
input TeamCollectionFilter {
  """Compound filters, all of which need to be matched by the team."""
  and: [TeamCollectionFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Filters that needs to be matched by all teams."""
  every: TeamFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Compound filters, one of which need to be matched by the team."""
  or: [TeamCollectionFilter!]

  """Filters that needs to be matched by some teams."""
  some: TeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type TeamConnection {
  edges: [TeamEdge!]!
  nodes: [Team!]!
  pageInfo: PageInfo!
}

input TeamCreateInput {
  """
  Period after which closed and completed issues are automatically archived, in months. 0 means disabled.
  """
  autoArchivePeriod: Float

  """Period after which issues are automatically closed, in months."""
  autoClosePeriod: Float

  """The canceled workflow state which auto closed issues will be set to."""
  autoCloseStateId: String

  """The color of the team."""
  color: String

  """The cooldown time after each cycle in weeks."""
  cycleCooldownTime: Int

  """The duration of each cycle in weeks."""
  cycleDuration: Int

  """Auto assign completed issues to current active cycle setting."""
  cycleIssueAutoAssignCompleted: Boolean

  """Auto assign started issues to current active cycle setting."""
  cycleIssueAutoAssignStarted: Boolean

  """Only allow issues issues with cycles in Active Issues."""
  cycleLockToActive: Boolean

  """The day of the week that a new cycle starts."""
  cycleStartDay: Float

  """Whether the team uses cycles."""
  cyclesEnabled: Boolean

  """What to use as an default estimate for unestimated issues."""
  defaultIssueEstimate: Float

  """The identifier of the default project template of this team."""
  defaultProjectTemplateId: String

  """The identifier of the default template for members of this team."""
  defaultTemplateForMembersId: String

  """The identifier of the default template for non-members of this team."""
  defaultTemplateForNonMembersId: String

  """The description of the team."""
  description: String

  """Whether to group recent issue history entries."""
  groupIssueHistory: Boolean

  """The icon of the team."""
  icon: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """
  Whether the team should inherit estimation settings from its parent. Only applies to sub-teams.
  """
  inheritIssueEstimation: Boolean

  """
  [Internal] Whether the team should inherit its product intelligence scope from its parent. Only applies to sub-teams.
  """
  inheritProductIntelligenceScope: Boolean

  """
  [Internal] Whether the team should inherit workflow statuses from its parent.
  """
  inheritWorkflowStatuses: Boolean

  """Whether to allow zeros in issues estimates."""
  issueEstimationAllowZero: Boolean

  """Whether to add additional points to the estimate scale."""
  issueEstimationExtended: Boolean

  """
  The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
  """
  issueEstimationType: String

  """[DEPRECATED] Whether issues without priority should be sorted first."""
  issueOrderingNoPriorityFirst: Boolean @deprecated(reason: "This setting is no longer in use.")

  """
  The key of the team. If not given, the key will be generated based on the name of the team.
  """
  key: String

  """
  The workflow state into which issues are moved when they are marked as a duplicate of another issue.
  """
  markedAsDuplicateWorkflowStateId: String

  """The name of the team."""
  name: String!

  """The organization associated with the team."""
  organizationId: String @deprecated(reason: "The request context is used to determine the organization.")

  """The parent team ID."""
  parentId: String

  """Internal. Whether the team is private or not."""
  private: Boolean

  """
  [Internal] The scope of product intelligence suggestion data for the team.
  """
  productIntelligenceScope: ProductIntelligenceScope

  """Whether an issue needs to have a priority set before leaving triage."""
  requirePriorityToLeaveTriage: Boolean

  """Whether to move issues to bottom of the column when changing state."""
  setIssueSortOrderOnStateChange: String

  """The timezone of the team."""
  timezone: String

  """Whether triage mode is enabled for the team."""
  triageEnabled: Boolean

  """How many upcoming cycles to create."""
  upcomingCycleCount: Float
}

type TeamEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Team!
}

"""Team filtering options."""
input TeamFilter {
  """Compound filters, all of which need to be matched by the team."""
  and: [TeamFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the team description."""
  description: NullableStringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the teams issues must satisfy."""
  issues: IssueCollectionFilter

  """Comparator for the team key."""
  key: StringComparator

  """Comparator for the team name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the team."""
  or: [TeamFilter!]

  """Filters that the teams parent must satisfy."""
  parent: NullableTeamFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""Defines the membership of a user to a team."""
type TeamMembership implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """Whether the user is the owner of the team."""
  owner: Boolean!

  """The order of the item in the users team list."""
  sortOrder: Float!

  """The team that the membership is associated with."""
  team: Team!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user that the membership is associated with."""
  user: User!
}

type TeamMembershipConnection {
  edges: [TeamMembershipEdge!]!
  nodes: [TeamMembership!]!
  pageInfo: PageInfo!
}

input TeamMembershipCreateInput {
  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """Internal. Whether the user is the owner of the team."""
  owner: Boolean

  """The position of the item in the users list."""
  sortOrder: Float

  """The identifier of the team associated with the membership."""
  teamId: String!

  """The identifier of the user associated with the membership."""
  userId: String!
}

type TeamMembershipEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: TeamMembership!
}

type TeamMembershipPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The team membership that was created or updated."""
  teamMembership: TeamMembership
}

input TeamMembershipUpdateInput {
  """Internal. Whether the user is the owner of the team."""
  owner: Boolean

  """The position of the item in the users list."""
  sortOrder: Float
}

"""A team notification subscription."""
type TeamNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer associated with the notification subscription."""
  customer: Customer

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team subscribed to."""
  team: Team!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user view associated with the notification subscription."""
  user: User

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

type TeamPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The team that was created or updated."""
  team: Team
}

"""Issue team sorting options."""
input TeamSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input TeamUpdateInput {
  """Whether to enable resolved thread AI summaries."""
  aiThreadSummariesEnabled: Boolean

  """
  Period after which closed and completed issues are automatically archived, in months.
  """
  autoArchivePeriod: Float

  """
  [INTERNAL] Whether to automatically close all sub-issues when a parent issue in this team is closed.
  """
  autoCloseChildIssues: Boolean

  """
  [INTERNAL] Whether to automatically close a parent issue in this team if all its sub-issues are closed.
  """
  autoCloseParentIssues: Boolean

  """Period after which issues are automatically closed, in months."""
  autoClosePeriod: Float

  """The canceled workflow state which auto closed issues will be set to."""
  autoCloseStateId: String

  """The color of the team."""
  color: String

  """The cooldown time after each cycle in weeks."""
  cycleCooldownTime: Int

  """The duration of each cycle in weeks."""
  cycleDuration: Int

  """The date to begin cycles on."""
  cycleEnabledStartDate: DateTime

  """Auto assign completed issues to current active cycle setting."""
  cycleIssueAutoAssignCompleted: Boolean

  """Auto assign started issues to current active cycle setting."""
  cycleIssueAutoAssignStarted: Boolean

  """Only allow issues with cycles in Active Issues."""
  cycleLockToActive: Boolean

  """The day of the week that a new cycle starts."""
  cycleStartDay: Float

  """Whether the team uses cycles."""
  cyclesEnabled: Boolean

  """What to use as an default estimate for unestimated issues."""
  defaultIssueEstimate: Float

  """Default status for newly created issues."""
  defaultIssueStateId: String

  """The identifier of the default project template of this team."""
  defaultProjectTemplateId: String

  """The identifier of the default template for members of this team."""
  defaultTemplateForMembersId: String

  """The identifier of the default template for non-members of this team."""
  defaultTemplateForNonMembersId: String

  """The description of the team."""
  description: String

  """Whether to group recent issue history entries."""
  groupIssueHistory: Boolean

  """The icon of the team."""
  icon: String

  """
  Whether the team should inherit estimation settings from its parent. Only applies to sub-teams.
  """
  inheritIssueEstimation: Boolean

  """
  [Internal] Whether the team should inherit its product intelligence scope from its parent. Only applies to sub-teams.
  """
  inheritProductIntelligenceScope: Boolean

  """
  [Internal] Whether the team should inherit workflow statuses from its parent.
  """
  inheritWorkflowStatuses: Boolean

  """Whether to allow zeros in issues estimates."""
  issueEstimationAllowZero: Boolean

  """Whether to add additional points to the estimate scale."""
  issueEstimationExtended: Boolean

  """
  The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
  """
  issueEstimationType: String

  """[DEPRECATED] Whether issues without priority should be sorted first."""
  issueOrderingNoPriorityFirst: Boolean @deprecated(reason: "This setting is no longer in use.")

  """
  Whether new users should join this team by default. Mutation restricted to workspace admins!
  """
  joinByDefault: Boolean

  """The key of the team."""
  key: String

  """
  The workflow state into which issues are moved when they are marked as a duplicate of another issue.
  """
  markedAsDuplicateWorkflowStateId: String

  """The name of the team."""
  name: String

  """The parent team ID."""
  parentId: String

  """Whether the team is private or not."""
  private: Boolean

  """
  [Internal] The scope of product intelligence suggestion data for the team.
  """
  productIntelligenceScope: ProductIntelligenceScope

  """Whether an issue needs to have a priority set before leaving triage."""
  requirePriorityToLeaveTriage: Boolean

  """
  Whether the team is managed by SCIM integration. Mutation restricted to workspace admins and only unsetting is allowed!
  """
  scimManaged: Boolean

  """Whether to move issues to bottom of the column when changing state."""
  setIssueSortOrderOnStateChange: String

  """Whether to send new issue comment notifications to Slack."""
  slackIssueComments: Boolean

  """Whether to send issue status update notifications to Slack."""
  slackIssueStatuses: Boolean

  """Whether to send new issue notifications to Slack."""
  slackNewIssue: Boolean

  """The timezone of the team."""
  timezone: String

  """Whether triage mode is enabled for the team."""
  triageEnabled: Boolean

  """How many upcoming cycles to create."""
  upcomingCycleCount: Float
}

"""A template object used for creating entities faster."""
type Template implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the template."""
  creator: User

  """Template description."""
  description: String

  """The unique identifier of the entity."""
  id: ID!

  """The original template inherited from."""
  inheritedFrom: Template

  """The user who last updated the template."""
  lastUpdatedBy: User

  """The name of the template."""
  name: String!

  """
  The organization that the template is associated with. If null, the template is associated with a particular team.
  """
  organization: Organization!

  """The sort order of the template."""
  sortOrder: Float!

  """
  The team that the template is associated with. If null, the template is global to the workspace.
  """
  team: Team

  """Template data."""
  templateData: JSON!

  """The entity type this template is for."""
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type TemplateConnection {
  edges: [TemplateEdge!]!
  nodes: [Template!]!
  pageInfo: PageInfo!
}

input TemplateCreateInput {
  """The template description."""
  description: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The template name."""
  name: String!

  """The position of the template in the templates list."""
  sortOrder: Float

  """
  The identifier or key of the team associated with the template. If not given, the template will be shared across all teams.
  """
  teamId: String

  """
  The template data as JSON encoded attributes of the type of entity, such as an issue.
  """
  templateData: JSON!

  """The template type, e.g. 'issue'."""
  type: String!
}

type TemplateEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Template!
}

type TemplatePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The template that was created or updated."""
  template: Template!
}

input TemplateUpdateInput {
  """The template description."""
  description: String

  """The template name."""
  name: String

  """The position of the template in the templates list."""
  sortOrder: Float

  """
  The identifier or key of the team associated with the template. If set to null, the template will be shared across all teams.
  """
  teamId: String

  """
  The template data as JSON encoded attributes of the type of entity, such as an issue.
  """
  templateData: JSON
}

"""Customer tier sorting options."""
input TierSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""A time schedule."""
type TimeSchedule implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The schedule entries."""
  entries: [TimeScheduleEntry!]

  """The identifier of the external schedule."""
  externalId: String

  """The URL to the external schedule."""
  externalUrl: String

  """The unique identifier of the entity."""
  id: ID!

  """The identifier of the Linear integration populating the schedule."""
  integration: Integration

  """The name of the schedule."""
  name: String!

  """The organization of the schedule."""
  organization: Organization!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

type TimeScheduleConnection {
  edges: [TimeScheduleEdge!]!
  nodes: [TimeSchedule!]!
  pageInfo: PageInfo!
}

input TimeScheduleCreateInput {
  """The schedule entries."""
  entries: [TimeScheduleEntryInput!]!

  """The unique identifier of the external schedule."""
  externalId: String

  """The URL to the external schedule."""
  externalUrl: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the schedule."""
  name: String!
}

type TimeScheduleEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: TimeSchedule!
}

type TimeScheduleEntry {
  """The end date of the schedule in ISO 8601 date-time format."""
  endsAt: DateTime!

  """The start date of the schedule in ISO 8601 date-time format."""
  startsAt: DateTime!

  """
  The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id.
  """
  userEmail: String

  """
  The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference.
  """
  userId: String
}

input TimeScheduleEntryInput {
  """The end date of the schedule in ISO 8601 date-time format."""
  endsAt: DateTime!

  """The start date of the schedule in ISO 8601 date-time format."""
  startsAt: DateTime!

  """
  The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id.
  """
  userEmail: String

  """
  The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference.
  """
  userId: String
}

type TimeSchedulePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
  timeSchedule: TimeSchedule!
}

input TimeScheduleUpdateInput {
  """The schedule entries."""
  entries: [TimeScheduleEntryInput!]

  """The unique identifier of the external schedule."""
  externalId: String

  """The URL to the external schedule."""
  externalUrl: String

  """The name of the schedule."""
  name: String
}

"""
Represents a date in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) 
"""
scalar TimelessDate

"""
Represents a date in ISO 8601 format or a duration. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings (e.g '-P2W1D'), which are not converted to dates.
"""
scalar TimelessDateOrDuration

"""Issue title sorting options."""
input TitleSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input TokenUserAccountAuthInput {
  """The email which to login via the magic login code."""
  email: String!

  """An optional invite link for an organization."""
  inviteLink: String

  """The identifiers of the teams to auto-join."""
  teamIdsToJoin: [String!] @deprecated(reason: "Not used anymore")

  """The timezone of the user's browser."""
  timezone: String!

  """The magic login code."""
  token: String!
}

"""A team's triage responsibility."""
type TriageResponsibility implements Node {
  """The action to take when an issue is added to triage."""
  action: TriageResponsibilityAction!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user currently responsible for triage."""
  currentUser: User

  """The unique identifier of the entity."""
  id: ID!

  """Set of users used for triage responsibility."""
  manualSelection: TriageResponsibilityManualSelection

  """The team to which the triage responsibility belongs to."""
  team: Team!

  """The time schedule used for scheduling."""
  timeSchedule: TimeSchedule

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""Which action should be taken after an issue is added to triage."""
enum TriageResponsibilityAction {
  assign
  notify
}

type TriageResponsibilityConnection {
  edges: [TriageResponsibilityEdge!]!
  nodes: [TriageResponsibility!]!
  pageInfo: PageInfo!
}

input TriageResponsibilityCreateInput {
  """The action to take when an issue is added to triage."""
  action: String!

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The manual selection of users responsible for triage."""
  manualSelection: TriageResponsibilityManualSelectionInput

  """The identifier of the team associated with the triage responsibility."""
  teamId: String!

  """
  The identifier of the time schedule used for scheduling triage responsibility
  """
  timeScheduleId: String
}

type TriageResponsibilityEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: TriageResponsibility!
}

type TriageResponsibilityManualSelection {
  """
  [Internal] The index of the current userId used for the assign action when having more than one user.
  """
  assignmentIndex: Int

  """The set of users responsible for triage."""
  userIds: [String!]!
}

"""Manual triage responsibility using a set of users."""
input TriageResponsibilityManualSelectionInput {
  """
  [Internal] The index of the current userId used for the assign action when having more than one user.
  """
  assignmentIndex: Int

  """The set of users responsible for triage."""
  userIds: [String!]!
}

type TriageResponsibilityPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
  triageResponsibility: TriageResponsibility!
}

input TriageResponsibilityUpdateInput {
  """The action to take when an issue is added to triage."""
  action: String

  """The manual selection of users responsible for triage."""
  manualSelection: TriageResponsibilityManualSelectionInput

  """
  The identifier of the time schedule used for scheduling triage responsibility.
  """
  timeScheduleId: String
}

"""A universally unique identifier as specified by RFC 4122."""
scalar UUID

"""Issue update date sorting options."""
input UpdatedAtSort {
  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

"""Object representing Google Cloud upload policy, plus additional data."""
type UploadFile {
  """The asset URL for the uploaded file. (assigned automatically)."""
  assetUrl: String!

  """The content type."""
  contentType: String!

  """The filename."""
  filename: String!
  headers: [UploadFileHeader!]!
  metaData: JSONObject

  """The size of the uploaded file."""
  size: Int!

  """The signed URL the for the uploaded file. (assigned automatically)."""
  uploadUrl: String!
}

type UploadFileHeader {
  """Upload file header key."""
  key: String!

  """Upload file header value."""
  value: String!
}

type UploadPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """Object describing the file to be uploaded."""
  uploadFile: UploadFile
}

"""A user that has access to the the resources of an organization."""
type User implements Node {
  """Whether the user account is active or disabled (suspended)."""
  active: Boolean!

  """Whether the user is an organization administrator."""
  admin: Boolean!

  """Whether the user is an app."""
  app: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """Issues assigned to the user."""
  assignedIssues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """The background color of the avatar for users without set avatar."""
  avatarBackgroundColor: String!

  """An URL to the user's avatar image."""
  avatarUrl: String

  """[DEPRECATED] Hash for the user to be used in calendar URLs."""
  calendarHash: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Number of issues created."""
  createdIssueCount: Int!

  """Issues created by the user."""
  createdIssues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """Issues delegated to this user."""
  delegatedIssues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """A short description of the user, either its title or bio."""
  description: String

  """Reason why is the account disabled."""
  disableReason: String

  """The user's display (nick) name. Unique within each organization."""
  displayName: String!

  """The user's drafts"""
  drafts(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): DraftConnection!

  """The user's email address."""
  email: String!

  """The user's GitHub user ID."""
  gitHubUserId: String

  """
  Whether the user is a guest in the workspace and limited to accessing a subset of teams.
  """
  guest: Boolean!

  """The unique identifier of the entity."""
  id: ID!

  """The initials of the user."""
  initials: String!

  """[DEPRECATED] Unique hash for the user to be used in invite URLs."""
  inviteHash: String! @deprecated(reason: "This hash is not in use anymore, this value will always be empty.")

  """Whether the user is assignable."""
  isAssignable: Boolean!

  """Whether the user is the currently authenticated user."""
  isMe: Boolean!

  """Whether the user is mentionable."""
  isMentionable: Boolean!

  """The user's issue drafts"""
  issueDrafts(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueDraftConnection!

  """The last time the user was seen online."""
  lastSeen: DateTime

  """The user's full name."""
  name: String!

  """Organization the user belongs to."""
  organization: Organization!

  """The emoji to represent the user current status."""
  statusEmoji: String

  """The label of the user current status."""
  statusLabel: String

  """A date at which the user current status should be cleared."""
  statusUntilAt: DateTime

  """
  Memberships associated with the user. For easier access of the same data, use `teams` query.
  """
  teamMemberships(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamMembershipConnection!

  """Teams the user is part of."""
  teams(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned teams."""
    filter: TeamFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): TeamConnection!

  """The local timezone of the user."""
  timezone: String

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """User's profile URL."""
  url: String!
}

type UserAdminPayload {
  """Whether the operation was successful."""
  success: Boolean!
}

"""
Public information of the OAuth application, plus whether the application has been authorized for the given scopes.
"""
type UserAuthorizedApplication {
  """Details of the app user's existing token, if any."""
  appUserAuthentication: AppUserAuthentication

  """
  Error associated with the application needing to be requested for approval in the workspace.
  """
  approvalErrorCode: String

  """OAuth application's client ID."""
  clientId: String!

  """Whether the application was created by Linear."""
  createdByLinear: Boolean!

  """Information about the application."""
  description: String

  """Name of the developer."""
  developer: String!

  """Url of the developer (homepage or docs)."""
  developerUrl: String!

  """OAuth application's ID."""
  id: String!

  """Image of the application."""
  imageUrl: String

  """Whether the user has authorized the application for the given scopes."""
  isAuthorized: Boolean!

  """Application name."""
  name: String!

  """Whether or not webhooks are enabled for the application."""
  webhooksEnabled: Boolean!
}

"""User filtering options."""
input UserCollectionFilter {
  """Comparator for the user's activity status."""
  active: BooleanComparator

  """Comparator for the user's admin status."""
  admin: BooleanComparator

  """Compound filters, all of which need to be matched by the user."""
  and: [UserCollectionFilter!]

  """Comparator for the user's app status."""
  app: BooleanComparator

  """Filters that the users assigned issues must satisfy."""
  assignedIssues: IssueCollectionFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the user's display name."""
  displayName: StringComparator

  """Comparator for the user's email."""
  email: StringComparator

  """Filters that needs to be matched by all users."""
  every: UserFilter

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the user's invited status."""
  invited: BooleanComparator

  """
  Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
  """
  isMe: BooleanComparator

  """Comparator for the collection length."""
  length: NumberComparator

  """Comparator for the user's name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the user."""
  or: [UserCollectionFilter!]

  """Filters that needs to be matched by some users."""
  some: UserFilter

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type UserConnection {
  edges: [UserEdge!]!
  nodes: [User!]!
  pageInfo: PageInfo!
}

enum UserContextViewType {
  assigned
}

type UserEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: User!
}

"""User filtering options."""
input UserFilter {
  """Comparator for the user's activity status."""
  active: BooleanComparator

  """Comparator for the user's admin status."""
  admin: BooleanComparator

  """Compound filters, all of which need to be matched by the user."""
  and: [UserFilter!]

  """Comparator for the user's app status."""
  app: BooleanComparator

  """Filters that the users assigned issues must satisfy."""
  assignedIssues: IssueCollectionFilter

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the user's display name."""
  displayName: StringComparator

  """Comparator for the user's email."""
  email: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Comparator for the user's invited status."""
  invited: BooleanComparator

  """
  Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user.
  """
  isMe: BooleanComparator

  """Comparator for the user's name."""
  name: StringComparator

  """Compound filters, one of which need to be matched by the user."""
  or: [UserFilter!]

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

"""The types of flags that the user can have."""
enum UserFlagType {
  all
  analyticsWelcomeDismissed
  canPlaySnake
  canPlayTetris
  commandMenuClearShortcutTip
  completedOnboarding
  cycleWelcomeDismissed
  desktopDownloadToastDismissed
  desktopInstalled
  desktopTabsOnboardingDismissed
  dueDateShortcutMigration
  editorSlashCommandUsed
  emptyActiveIssuesDismissed
  emptyBacklogDismissed
  emptyCustomViewsDismissed
  emptyMyIssuesDismissed
  emptyParagraphSlashCommandTip
  figmaPluginBannerDismissed
  figmaPromptDismissed
  helpIslandFeatureInsightsDismissed
  importBannerDismissed
  initiativesBannerDismissed
  insightsHelpDismissed
  insightsWelcomeDismissed
  issueLabelSuggestionUsed
  issueMovePromptCompleted
  joinTeamIntroductionDismissed
  listSelectionTip
  migrateThemePreference
  milestoneOnboardingIsSeenAndDismissed
  projectBacklogWelcomeDismissed
  projectBoardOnboardingIsSeenAndDismissed
  projectUpdatesWelcomeDismissed
  projectWelcomeDismissed
  pulseWelcomeDismissed
  rewindBannerDismissed
  slackCommentReactionTipShown
  teamsPageIntroductionDismissed
  threadedCommentsNudgeIsSeen
  triageWelcomeDismissed
  tryCyclesDismissed
  tryGithubDismissed
  tryInvitePeopleDismissed
  tryRoadmapsDismissed
  tryTriageDismissed
  updatedSlackThreadSyncIntegration
}

"""Operations that can be applied to UserFlagType."""
enum UserFlagUpdateOperation {
  clear
  decr
  incr
  lock
}

"""A user notification subscription."""
type UserNotificationSubscription implements Entity & Node & NotificationSubscription {
  """Whether the subscription is active or not."""
  active: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  The type of view to which the notification subscription context is associated with.
  """
  contextViewType: ContextViewType

  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The contextual custom view associated with the notification subscription.
  """
  customView: CustomView

  """The customer associated with the notification subscription."""
  customer: Customer

  """
  The contextual cycle view associated with the notification subscription.
  """
  cycle: Cycle

  """The unique identifier of the entity."""
  id: ID!

  """
  The contextual initiative view associated with the notification subscription.
  """
  initiative: Initiative

  """
  The contextual label view associated with the notification subscription.
  """
  label: IssueLabel

  """The type of subscription."""
  notificationSubscriptionTypes: [String!]!

  """
  The contextual project view associated with the notification subscription.
  """
  project: Project

  """The user that subscribed to receive notifications."""
  subscriber: User!

  """The team associated with the notification subscription."""
  team: Team

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user subscribed to."""
  user: User!

  """
  The type of user view to which the notification subscription context is associated with.
  """
  userContextViewType: UserContextViewType
}

type UserPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The user that was created or updated."""
  user: User
}

"""The different permission roles available to users on an organization."""
enum UserRoleType {
  admin
  app
  guest
  user
}

"""The settings of a user as a JSON object."""
type UserSettings implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """
  Whether to auto-assign newly created issues to the current user by default.
  """
  autoAssignToSelf: Boolean!

  """Hash for the user to be used in calendar URLs."""
  calendarHash: String

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The user's notification category preferences."""
  notificationCategoryPreferences: NotificationCategoryPreferences!

  """The user's notification channel preferences."""
  notificationChannelPreferences: NotificationChannelPreferences!

  """
  The notification delivery preferences for the user. Note: notificationDisabled field is deprecated in favor of notificationChannelPreferences.
  """
  notificationDeliveryPreferences: NotificationDeliveryPreferences!

  """Whether to show full user names instead of display names."""
  showFullUserNames: Boolean!

  """Whether this user is subscribed to changelog email or not."""
  subscribedToChangelog: Boolean!

  """Whether this user is subscribed to DPA emails or not."""
  subscribedToDPA: Boolean!

  """Whether this user is subscribed to invite accepted emails or not."""
  subscribedToInviteAccepted: Boolean!

  """
  Whether this user is subscribed to privacy and legal update emails or not.
  """
  subscribedToPrivacyLegalUpdates: Boolean!

  """The email types the user has unsubscribed from."""
  unsubscribedFrom: [String!]! @deprecated(reason: "Use individual subscription fields instead. This field's value is now outdated.")

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The user associated with these settings."""
  user: User!
}

type UserSettingsFlagPayload {
  """The flag key which was updated."""
  flag: String

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The flag value after update."""
  value: Int
}

type UserSettingsFlagsResetPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type UserSettingsPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The user's settings."""
  userSettings: UserSettings!
}

input UserSettingsUpdateInput {
  """[Internal] How often to generate a feed summary."""
  feedSummarySchedule: FeedSummarySchedule

  """The user's notification category preferences."""
  notificationCategoryPreferences: NotificationCategoryPreferencesInput

  """The user's notification channel preferences."""
  notificationChannelPreferences: PartialNotificationChannelPreferencesInput

  """The user's notification delivery preferences."""
  notificationDeliveryPreferences: NotificationDeliveryPreferencesInput

  """The user's settings."""
  settings: JSONObject

  """Whether this user is subscribed to changelog email or not."""
  subscribedToChangelog: Boolean

  """Whether this user is subscribed to DPA emails or not."""
  subscribedToDPA: Boolean

  """
  Whether this user is subscribed to general marketing communications or not.
  """
  subscribedToGeneralMarketingCommunications: Boolean

  """Whether this user is subscribed to invite accepted emails or not."""
  subscribedToInviteAccepted: Boolean

  """
  Whether this user is subscribed to privacy and legal update emails or not.
  """
  subscribedToPrivacyLegalUpdates: Boolean

  """The types of emails the user has unsubscribed from."""
  unsubscribedFrom: [String!] @deprecated(reason: "Use individual subscription fields instead. This field is now ignored.")

  """[Internal] The user's usage warning history."""
  usageWarningHistory: JSONObject
}

input UserUpdateInput {
  """The avatar image URL of the user."""
  avatarUrl: String

  """The user description or a short bio."""
  description: String

  """The display name of the user."""
  displayName: String

  """The name of the user."""
  name: String

  """The emoji part of the user status."""
  statusEmoji: String

  """The label part of the user status."""
  statusLabel: String

  """When the user status should be cleared."""
  statusUntilAt: DateTime

  """The local timezone of the user."""
  timezone: String
}

"""View preferences."""
type ViewPreferences implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The unique identifier of the entity."""
  id: ID!

  """The view preferences"""
  preferences: ViewPreferencesValues!

  """The view preference type."""
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """The view type."""
  viewType: String!
}

input ViewPreferencesCreateInput {
  """The custom view these view preferences are associated with."""
  customViewId: String

  """The cycle these view preferences are associated with."""
  cycleId: String @deprecated(reason: "Not used")

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """[Internal] The initiative these view preferences are associated with."""
  initiativeId: String

  """The default parameters for the insight on that view."""
  insights: JSONObject

  """The label these view preferences are associated with."""
  labelId: String

  """View preferences object."""
  preferences: JSONObject!

  """The project these view preferences are associated with."""
  projectId: String

  """The project label these view preferences are associated with."""
  projectLabelId: String

  """The team these view preferences are associated with."""
  teamId: String

  """
  The type of view preferences (either user or organization level preferences).
  """
  type: ViewPreferencesType!

  """The user profile these view preferences are associated with."""
  userId: String

  """The view type of the view preferences are associated with."""
  viewType: ViewType!
}

type ViewPreferencesPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The view preferences entity being mutated."""
  viewPreferences: ViewPreferences!
}

"""
The type of view preferences (either user or organization level preferences).
"""
enum ViewPreferencesType {
  organization
  user
}

input ViewPreferencesUpdateInput {
  """The default parameters for the insight on that view."""
  insights: JSONObject

  """View preferences."""
  preferences: JSONObject
}

type ViewPreferencesValues {
  """The issue grouping."""
  issueGrouping: String

  """Whether to show completed issues."""
  showCompletedIssues: String

  """The issue ordering."""
  viewOrdering: String
}

"""The client view this custom view is targeting."""
enum ViewType {
  activeIssues
  allIssues
  archive
  backlog
  board
  completedCycle
  customView
  customViews
  customer
  customers
  cycle
  dashboards
  embeddedCustomerNeeds
  feedAll
  feedCreated
  feedFollowing
  feedPopular
  inbox
  initiative
  initiativeOverview
  initiativeOverviewSubInitiatives
  initiatives
  initiativesCompleted
  initiativesPlanned
  issueIdentifiers
  label
  myIssues
  myIssuesActivity
  myIssuesCreatedByMe
  myIssuesSubscribedTo
  myReviews
  project
  projectCustomerNeeds
  projectDocuments
  projectLabel
  projects
  projectsAll
  projectsBacklog
  projectsClosed
  quickView
  reviews
  roadmap
  roadmapAll
  roadmapBacklog
  roadmapClosed
  roadmaps
  search
  splitSearch
  subIssues
  teams
  triage
  userProfile
  userProfileCreatedByUser
  workspaceMembers
}

"""A webhook used to send HTTP notifications over data updates."""
type Webhook implements Node {
  """
  Whether the Webhook is enabled for all public teams, including teams created after the webhook was created.
  """
  allPublicTeams: Boolean!

  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The time at which the entity was created."""
  createdAt: DateTime!

  """The user who created the webhook."""
  creator: User

  """Whether the Webhook is enabled."""
  enabled: Boolean!

  """
  [INTERNAL] Webhook failure events associated with the webhook (last 50).
  """
  failures: [WebhookFailureEvent!]!

  """The unique identifier of the entity."""
  id: ID!

  """Webhook label."""
  label: String

  """The resource types this webhook is subscribed to."""
  resourceTypes: [String!]!

  """Secret token for verifying the origin on the recipient side."""
  secret: String

  """
  The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization or multiple teams.
  """
  team: Team

  """
  [INTERNAL] The teams that the webhook is associated with. Used to represent a webhook that targets multiple teams, potentially in addition to all public teams of the organization.
  """
  teamIds: [String!]

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!

  """Webhook URL."""
  url: String
}

type WebhookConnection {
  edges: [WebhookEdge!]!
  nodes: [Webhook!]!
  pageInfo: PageInfo!
}

input WebhookCreateInput {
  """Whether this webhook is enabled for all public teams."""
  allPublicTeams: Boolean

  """Whether this webhook is enabled."""
  enabled: Boolean = true

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """Label for the webhook."""
  label: String

  """List of resources the webhook should subscribe to."""
  resourceTypes: [String!]!

  """A secret token used to sign the webhook payload."""
  secret: String

  """The identifier or key of the team associated with the Webhook."""
  teamId: String

  """The URL that will be called on data changes."""
  url: String!
}

type WebhookEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: Webhook!
}

"""Entity representing a webhook execution failure."""
type WebhookFailureEvent {
  """The time at which the entity was created."""
  createdAt: DateTime!

  """
  The unique execution ID of the webhook push. This is retained between retries of the same push.
  """
  executionId: String!

  """The HTTP status code returned by the recipient."""
  httpStatus: Float

  """The unique identifier of the entity."""
  id: ID!

  """The HTTP response body returned by the recipient or error occured."""
  responseOrError: String

  """The URL that the webhook was trying to push to."""
  url: String!

  """The webhook that this failure event is associated with."""
  webhook: Webhook!
}

type WebhookPayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The webhook entity being mutated."""
  webhook: Webhook!
}

input WebhookUpdateInput {
  """Whether this webhook is enabled."""
  enabled: Boolean

  """Label for the webhook."""
  label: String

  """List of resources the webhook should subscribe to."""
  resourceTypes: [String!]

  """A secret token used to sign the webhook payload."""
  secret: String

  """The URL that will be called on data changes."""
  url: String
}

"""A state in a team workflow."""
type WorkflowState implements Node {
  """
  The time at which the entity was archived. Null if the entity has not been archived.
  """
  archivedAt: DateTime

  """The state's UI color as a HEX string."""
  color: String!

  """The time at which the entity was created."""
  createdAt: DateTime!

  """Description of the state."""
  description: String

  """The unique identifier of the entity."""
  id: ID!

  """The state inherited from"""
  inheritedFrom: WorkflowState

  """Issues belonging in this state."""
  issues(
    """A cursor to be used with first for forward pagination"""
    after: String

    """A cursor to be used with last for backward pagination."""
    before: String

    """Filter returned issues."""
    filter: IssueFilter

    """
    The number of items to forward paginate (used with after). Defaults to 50.
    """
    first: Int

    """Should archived resources be included (default: false)"""
    includeArchived: Boolean

    """
    The number of items to backward paginate (used with before). Defaults to 50.
    """
    last: Int

    """
    By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
    """
    orderBy: PaginationOrderBy
  ): IssueConnection!

  """The state's name."""
  name: String!

  """The position of the state in the team flow."""
  position: Float!

  """The team to which this state belongs to."""
  team: Team!

  """
  The type of the state. One of "triage", "backlog", "unstarted", "started", "completed", "canceled".
  """
  type: String!

  """
  The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
      been updated after creation.
  """
  updatedAt: DateTime!
}

"""A generic payload return from entity archive mutations."""
type WorkflowStateArchivePayload implements ArchivePayload {
  """The archived/unarchived entity. Null if entity was deleted."""
  entity: WorkflowState

  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!
}

type WorkflowStateConnection {
  edges: [WorkflowStateEdge!]!
  nodes: [WorkflowState!]!
  pageInfo: PageInfo!
}

input WorkflowStateCreateInput {
  """The color of the state."""
  color: String!

  """The description of the state."""
  description: String

  """
  The identifier in UUID v4 format. If none is provided, the backend will generate one.
  """
  id: String

  """The name of the state."""
  name: String!

  """The position of the state."""
  position: Float

  """The team associated with the state."""
  teamId: String!

  """The workflow type."""
  type: String!
}

type WorkflowStateEdge {
  """Used in `before` and `after` args"""
  cursor: String!
  node: WorkflowState!
}

"""Workflow state filtering options."""
input WorkflowStateFilter {
  """
  Compound filters, all of which need to be matched by the workflow state.
  """
  and: [WorkflowStateFilter!]

  """Comparator for the created at date."""
  createdAt: DateComparator

  """Comparator for the workflow state description."""
  description: StringComparator

  """Comparator for the identifier."""
  id: IDComparator

  """Filters that the workflow states issues must satisfy."""
  issues: IssueCollectionFilter

  """Comparator for the workflow state name."""
  name: StringComparator

  """
  Compound filters, one of which need to be matched by the workflow state.
  """
  or: [WorkflowStateFilter!]

  """Comparator for the workflow state position."""
  position: NumberComparator

  """Filters that the workflow states team must satisfy."""
  team: TeamFilter

  """Comparator for the workflow state type."""
  type: StringComparator

  """Comparator for the updated at date."""
  updatedAt: DateComparator
}

type WorkflowStatePayload {
  """The identifier of the last sync operation."""
  lastSyncId: Float!

  """Whether the operation was successful."""
  success: Boolean!

  """The state that was created or updated."""
  workflowState: WorkflowState!
}

"""Issue workflow state sorting options."""
input WorkflowStateSort {
  """Whether to sort closed issues by recency"""
  closedIssuesOrderedByRecency: Boolean = false

  """Whether nulls should be sorted first or last"""
  nulls: PaginationNulls = last

  """The order for the individual sort"""
  order: PaginationSortOrder
}

input WorkflowStateUpdateInput {
  """The color of the state."""
  color: String

  """The description of the state."""
  description: String

  """The name of the state."""
  name: String

  """The position of the state."""
  position: Float
}

"""
[INTERNAL] Public information of the OAuth application, plus the userIds and scopes for those users.
"""
type WorkspaceAuthorizedApplication {
  """OAuth application's ID."""
  appId: String!

  """OAuth application's client ID."""
  clientId: String!

  """Description of the application."""
  description: String

  """Developer of the application."""
  developer: String

  """Developer URL of the application."""
  developerUrl: String

  """Image of the application."""
  imageUrl: String

  """
  UserIds and membership dates of everyone who has authorized the application with the set of scopes.
  """
  memberships: [AuthMembership!]!

  """Application name."""
  name: String!

  """Scopes that are authorized for this application for a given user."""
  scope: [String!]!

  """Total number of members that authorized the application."""
  totalMembers: Float!

  """Whether or not webhooks are enabled for the application."""
  webhooksEnabled: Boolean!
}

"""
[INTERNAL] Public information of the OAuth application, plus the app user and aggregate membership count.
"""
type WorkspaceAuthorizedApplicationWithAppUser {
  """OAuth application's ID."""
  appId: String!

  """The app user associated with this client, if one exists."""
  appUser: AuthMembership

  """OAuth application's client ID."""
  clientId: String!

  """Description of the application."""
  description: String

  """Developer of the application."""
  developer: String

  """Developer URL of the application."""
  developerUrl: String

  """Image of the application."""
  imageUrl: String

  """Application name."""
  name: String!

  """Scopes that are authorized for this application for a given user."""
  scope: [String!]!

  """
  Total number of members (including the app user, if it exists) that authorized the application.
  """
  totalMembers: Float!

  """Whether or not webhooks are enabled for the application."""
  webhooksEnabled: Boolean!
}

"""
[INTERNAL] Public information of the OAuth application with its memberships
"""
type WorkspaceAuthorizedApplicationWithMemberships {
  """Details of the OAuth application"""
  client: AuthorizedApplication!

  """
  UserIds and membership dates of everyone who has authorized the application
  """
  memberships: [AuthMembership!]!

  """Total number of members that authorized the application."""
  totalMembers: Float!
}

input ZendeskSettingsInput {
  """
  Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
  """
  automateTicketReopeningOnCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
  """
  automateTicketReopeningOnComment: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear issue is completed.
  """
  automateTicketReopeningOnCompletion: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is cancelled.
  """
  automateTicketReopeningOnProjectCancellation: Boolean

  """
  Whether a ticket should be automatically reopened when its linked Linear project is completed.
  """
  automateTicketReopeningOnProjectCompletion: Boolean

  """The ID of the Linear bot user."""
  botUserId: String

  """
  [INTERNAL] Temporary flag indicating if the integration has the necessary scopes for Customers
  """
  canReadCustomers: Boolean

  """
  [ALPHA] Whether customer and customer requests should not be automatically created when conversations are linked to a Linear issue.
  """
  disableCustomerRequestsAutoCreation: Boolean

  """
  Whether an internal message should be added when someone comments on an issue.
  """
  sendNoteOnComment: Boolean

  """
  Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
  """
  sendNoteOnStatusChange: Boolean

  """The subdomain of the Zendesk organization being connected."""
  subdomain: String!

  """
  [INTERNAL] Flag indicating if the integration supports OAuth refresh tokens
  """
  supportsOAuthRefresh: Boolean

  """The URL of the connected Zendesk organization."""
  url: String!
}